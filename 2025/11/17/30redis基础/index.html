

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="無鎏雲">
  <meta name="keywords" content="">
  
    <meta name="description" content="redisRedis为什么这么快(1)纯内存操作这是最最主要的原因Redis数据读写操作发生在内存中,访问速度是纳秒级别,而数据库频繁读写磁盘的速度是毫秒级别,两者相差多个数量级. (2)高效的IO模型Redis使用单线程事件循环配合IO多路复用技术,让单线程可以同时处理多个网络连接上的IO事件,避免了多线程模型中的上下文切换和锁竞争问题. 事件循环:无限循环,不断轮询并处理就绪的事件,直到Red">
<meta property="og:type" content="article">
<meta property="og:title" content="30redis基础">
<meta property="og:url" content="http://example.com/2025/11/17/30redis%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="NoFlowCloud">
<meta property="og:description" content="redisRedis为什么这么快(1)纯内存操作这是最最主要的原因Redis数据读写操作发生在内存中,访问速度是纳秒级别,而数据库频繁读写磁盘的速度是毫秒级别,两者相差多个数量级. (2)高效的IO模型Redis使用单线程事件循环配合IO多路复用技术,让单线程可以同时处理多个网络连接上的IO事件,避免了多线程模型中的上下文切换和锁竞争问题. 事件循环:无限循环,不断轮询并处理就绪的事件,直到Red">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/image-20240725232549832.png">
<meta property="og:image" content="http://example.com/img/1755344031729-caab8f72-4605-475d-847a-95fe2a16cd19.webp">
<meta property="og:image" content="http://example.com/img/1baff6929e63428ab4ce6ead35657953.jpeg">
<meta property="og:image" content="http://example.com/img/1719035634188-584809ba-ea0b-48ff-a547-9ee4d1b4d365.png">
<meta property="og:image" content="http://example.com/img/1719035634415-c436d60e-58a7-4dfc-9e69-db8e2f96d19c.png">
<meta property="og:image" content="http://example.com/img/1720432496274-b95e1802-1ecd-4210-a987-733265534c64.png">
<meta property="og:image" content="http://example.com/img/1720432496229-46da5ac0-0e89-45cd-b1f8-151f7c6d4660.png">
<meta property="og:image" content="http://example.com/img/1719804939236-89f12a47-b851-4d06-a5f3-399e1119db57.png">
<meta property="og:image" content="http://example.com/img/1719804939577-56390d43-28b7-4d20-accf-55c79a53142e.png">
<meta property="article:published_time" content="2025-11-17T01:07:57.000Z">
<meta property="article:modified_time" content="2025-12-17T06:53:42.319Z">
<meta property="article:author" content="無鎏雲">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/image-20240725232549832.png">
  
  
  
  <title>30redis基础 - NoFlowCloud</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Noflowcloud-Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="30redis基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-11-17 09:07" pubdate>
          2025年11月17日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.1k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          68 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">30redis基础</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h2><p>(1)纯内存操作这是最最主要的原因Redis数据读写操作发生在内存中,访问速度是纳秒级别,而数据库频繁读写磁盘的速度是毫秒级别,两者相差多个数量级.</p>
<p>(2)高效的IO模型Redis使用单线程事件循环配合IO多路复用技术,让单线程可以同时处理多个网络连接上的IO事件,避免了多线程模型中的上下文切换和锁竞争问题.</p>
<p>事件循环:无限循环,不断轮询并处理就绪的事件,直到Redis服务停止,整个循环会处理两类事件:文件事件(建立TCP,客户端读写)和时间事件(定时任务),先IO后定时,循环往复.</p>
<p>(3)优化的内部数据结构Redis提供多种数据类型,内部采用高度优化的编码方式Redis会根据数据大小和类型动态选择最合适的内部编码,以在性能和空间效率之间取得最佳平衡.</p>
<p>(4)简洁高效的通信协议Redis使用自己设计的RESP协议该协议实现简单,解析性能好,且是二进制安全的客户端和服务端之间的序列化&#x2F;反序列开销很小,有助于提升整体的交互速度.</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因</p>
<p> Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会<strong>额外创建 6 个线程</strong>（<em>这里的线程数不包括主线程</em>）：</p>
<ul>
<li>Redis-server ： Redis的主线程，主要负责执行命令；</li>
<li>bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；</li>
<li>通过 <code>bio_close_file</code> 后台线程来释放 AOF &#x2F; RDB 等过程中产生的临时文件资源。</li>
<li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（AOF 文件）。</li>
<li>通过 <code>bio_lazy_free</code> 后台线程释放大对象（已删除）占用的内存空间.</li>
<li>io_thd_1、io_thd_2、io_thd_3：三个 I&#x2F;O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I&#x2F;O 多线程，用来分担 Redis 网络 I&#x2F;O 的压力。</li>
</ul>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 &gt; 1，需要修改 redis 配置文件 <code>redis.conf</code>：</p>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h2 id="为什么用Redis而不用本地缓存呢"><a href="#为什么用Redis而不用本地缓存呢" class="headerlink" title="为什么用Redis而不用本地缓存呢"></a>为什么用Redis而不用本地缓存呢</h2><p><strong>本地缓存</strong>是指将数据存储在本地应用程序或服务器上，通常用于加速数据访问和提高响应速度。</p>
<p>(1)数据一致性</p>
<p>Redis -&gt; 数据一致</p>
<p>本地缓存 -&gt; 多服务器同时部署时存在数据不一致问题</p>
<p>(2)内存限制</p>
<p>Redis -&gt; 独立部署,内存空间更大</p>
<p>本地缓存 -&gt; 受限于单台服务器内存</p>
<p>(3)数据丢失风险</p>
<p>Redis -&gt; 可持久化,数据不易丢失</p>
<p>本地缓存 -&gt; 服务器宕机数据丢失</p>
<p>(4)管理维护</p>
<p>Redis -&gt; 集中管理, 提供丰富的管理工具</p>
<p>本地缓存 -&gt; 分散,管理不便</p>
<p>(5)拓展功能丰富</p>
<p>Redis -&gt; 功能丰富,支持多种数据结构以功能</p>
<p>本地缓存 -&gt; 功能有限,通常只支持简单的键值对存储.</p>
<h1 id="键值对数据库是怎么实现的？"><a href="#键值对数据库是怎么实现的？" class="headerlink" title="键值对数据库是怎么实现的？"></a>键值对数据库是怎么实现的？</h1><p>在开始讲数据结构之前，先给介绍下 Redis 是怎样实现键值对（key-value）数据库的。</p>
<p>Redis 的键值对中的 key 就是字符串对象，而 <strong>value 可以是字符串对象，也可以是集合数据类型的对象</strong>，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。</p>
<p>举个例子，我这里列出几种 Redis 新增键值对的命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt; SET name &quot;xiaolincoding&quot;<br>OK<br><br>&gt; HSET person name &quot;xiaolincoding&quot; age 18<br>0<br><br>&gt; RPUSH stu &quot;xiaolin&quot; &quot;xiaomei&quot;<br>(integer) 4<br></code></pre></td></tr></table></figure>

<p>这些命令代表着：</p>
<ul>
<li>第一条命令：name 是一个<strong>字符串键</strong>，因为键的<strong>值是一个字符串对象</strong>；</li>
<li>第二条命令：person 是一个<strong>哈希表键</strong>，因为键的<strong>值是一个包含两个键值对的哈希表对象</strong>；</li>
<li>第三条命令：stu 是一个<strong>列表键</strong>，因为键的<strong>值是一个包含两个元素的列表对象</strong>；</li>
</ul>
<p>这些键值对是如何保存在 Redis 中的呢？</p>
<p>Redis 是使用了一个「哈希表」保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p>
<p>Redis 的哈希桶是怎么保存键值对数据的呢？</p>
<p>哈希桶存放的是指向键值对数据的指针（dictEntry*），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void * key 和 void * value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void * value 指针找到。</p>
<h1 id="redis底层数据"><a href="#redis底层数据" class="headerlink" title="redis底层数据"></a>redis底层数据</h1><p>简单讲一下Redis的数据类型及应用场景</p>
<p>(1)数据类型String可存储字符串,整数,浮点数,支持直接读写,自增自减等</p>
<p>Hash存储键值对的无序散列表,可单独对某个键值对进行增删改查</p>
<p>List基于双向链表实现的有序数据结构,链表每个节点存储一个字符串,支持双端插入&#x2F;删除数据</p>
<p>Set存储不重复元素的无序集合,元素均为字符串,支持交集,并集,差集等</p>
<p>Zset在Set基础上为每个元素关联一个分数(score),通过分数对元素进行有序排序.</p>
<p>(2)应用场景基础类型</p>
<p>String -&gt; 缓存对象,常规计数,分布式锁,共享session信息等</p>
<p>List -&gt; 消息队列(生产者需要自行实现全局唯一ID)</p>
<p>Hash -&gt; 缓存对象,购物车等</p>
<p>Set -&gt; 聚合计算场景,比如点赞,共同关注,抽奖活动等</p>
<p>ZSet -&gt; 排序场景,如排行榜拓展类型</p>
<p>BitMap -&gt; 二进制状态统计场景,如用户登录状态,连续见到的用户总数</p>
<p>HyperLogLog-&gt;UV统计,用概率换空间</p>
<p>GEO-&gt; 地理位置存储</p>
<p>stream -&gt; 消息队列,自动生成全局唯一消息ID,支持以消费组形式消费.（难以解决堆积和丢失问题）</p>
<h2 id="String-是使用什么存储的-为什么不用-c-语言中的字符串"><a href="#String-是使用什么存储的-为什么不用-c-语言中的字符串" class="headerlink" title="String 是使用什么存储的?为什么不用 c 语言中的字符串?"></a><strong>String 是使用什么存储的?为什么不用 c 语言中的字符串?</strong></h2><p>Redis 的 String 字符串是用 SDS 数据结构存储的。</p>
<p>下图就是 Redis 5.0 的 SDS 的数据结构：</p>
<p><img src="/./../img/image-20240725232549832.png" srcset="/img/loading.gif" lazyload alt="image-20240725232549832"></p>
<p>结构中的每个成员变量分别介绍下：</p>
<ul>
<li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</li>
<li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li>
<li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>位</th>
</tr>
</thead>
<tbody><tr>
<td>sdshdr5</td>
<td>&lt; 1</td>
<td>&lt;8</td>
</tr>
<tr>
<td>sdshdr8</td>
<td>1</td>
<td>8</td>
</tr>
<tr>
<td>sdshdr16</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>sdshdr32</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>sdshdr64</td>
<td>8</td>
<td>64</td>
</tr>
</tbody></table>
<ul>
<li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li>
</ul>
<p>比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>
<p>SDS 相比于 C 语言中的字符串有如下提升：</p>
<ol>
<li><strong>可以避免缓冲区溢出</strong>：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li>
<li><strong>获取字符串长度的复杂度较低</strong>：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li>
<li><strong>减少内存分配次数</strong>：为了避免修改（增加&#x2F;减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li>
<li><strong>二进制安全</strong>：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li>
</ol>
<h2 id="List-类型的底层数据结构"><a href="#List-类型的底层数据结构" class="headerlink" title="List 类型的底层数据结构"></a>List 类型的底层数据结构</h2><p>是由<strong>双向链表或压缩列表</strong>实现的：</p>
<ul>
<li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>（7.0Listpack）</p>
<h2 id="Hash-类型的底层数据"><a href="#Hash-类型的底层数据" class="headerlink" title="Hash 类型的底层数据"></a>Hash 类型的底层数据</h2><p>结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p>
<p><strong>信息流展示</strong></p>
<ul>
<li>举例：最新文章、最新动态。</li>
<li>相关命令：<code>LPUSH</code>、<code>LRANGE</code>。</li>
</ul>
<h2 id="Set底层"><a href="#Set底层" class="headerlink" title="Set底层"></a>Set底层</h2><p>当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p>
<p><img src="/./../img/1755344031729-caab8f72-4605-475d-847a-95fe2a16cd19.webp" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="Zset底层"><a href="#Zset底层" class="headerlink" title="Zset底层"></a>Zset底层</h2><p>Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。</p>
<p>*<em>Zset 的底层是 *<em>跳表（skiplist）+ 字典（dict）*</em>，但小 Zset 用压缩列表（ziplist）（listpack）节省内存</em>*</p>
<p><strong>“跳表负责有序遍历，字典负责快速查找”</strong> —— 两者互补，避免了纯跳表的 O(log N) 查找缺陷。</p>
<h3 id="Redis-的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者-B-树？"><a href="#Redis-的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者-B-树？" class="headerlink" title="Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+ 树？"></a>Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+ 树？</h3><table>
<thead>
<tr>
<th>维度</th>
<th>红黑树</th>
<th>跳表</th>
<th>为什么 Redis 选跳表</th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现复杂度</strong></td>
<td>❌ 高（需处理旋转、颜色平衡）</td>
<td>✅ 低（仅需随机层数+指针）</td>
<td>Redis 代码库追求简洁，红黑树代码量是跳表的 <strong>3倍</strong>（实测：Redis ZSet 代码 150行 vs 红黑树 450+行）</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>❌ 高（每个节点需额外存储颜色、父指针）</td>
<td>✅ 低（仅需 <code>value</code> + <code>forward</code> 指针）</td>
<td>跳表节点结构更紧凑，<strong>内存节省 20%+</strong>（Redis 10 万 ZSet 元素实测）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>⚠️ 最坏 O(log n)，但常数因子高</td>
<td>✅ 平均 O(log n)，常数因子低</td>
<td><strong>Redis 是单线程</strong>，跳表的随机性避免了红黑树的平衡开销，<strong>实际性能几乎一致</strong></td>
</tr>
</tbody></table>
<h3 id="Zset-的两种实现方式（精准条件）"><a href="#Zset-的两种实现方式（精准条件）" class="headerlink" title="Zset 的两种实现方式（精准条件）"></a>Zset 的两种实现方式（精准条件）</h3><table>
<thead>
<tr>
<th>条件</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>元素数量</td>
<td>≤ <code>zset-max-ziplist-entries</code></td>
<td><strong>128</strong></td>
</tr>
<tr>
<td>成员长度</td>
<td>≤ <code>zset-max-ziplist-value</code></td>
<td><strong>64 字节</strong></td>
</tr>
<tr>
<td>分数长度</td>
<td>≤ <code>zset-max-ziplist-value</code></td>
<td><strong>64 字节</strong></td>
</tr>
</tbody></table>
<p>为什么用 ziplist？</p>
<ul>
<li><strong>内存占用</strong>：压缩列表是连续内存块，无指针开销（比跳表节省 30%+ 内存）</li>
<li><strong>适用场景</strong>：小规模 Zset（如用户标签、小范围排序）</li>
</ul>
<p>为什么 Zset 的 ziplist 不用普通压缩列表？ <strong>答</strong>：Zset 的 ziplist <strong>专门设计</strong>，将成员和分数交替存储（<code>member, score, member, score</code>），避免了普通 ziplist 的遍历问题。</p>
<p>✅ <strong>跳表（skiplist）+ 字典实现</strong>（大 Zset 主流）</p>
<p><strong>为什么需要字典？</strong><br> <strong>“跳表只能按分数排序，但无法快速查成员！”</strong><br> 例如：<code>ZRANGEBYSCORE</code> 用跳表，<code>ZSCORE</code> 用字典 → O(1) 查找。</p>
<h2 id="Hash底层"><a href="#Hash底层" class="headerlink" title="Hash底层"></a><strong>Hash底层</strong></h2><h2 id="Hash的存储机制：两种实现方式"><a href="#Hash的存储机制：两种实现方式" class="headerlink" title="Hash的存储机制：两种实现方式"></a>Hash的存储机制：两种实现方式</h2><h3 id="1-压缩列表（ziplist）实现（内存优化）"><a href="#1-压缩列表（ziplist）实现（内存优化）" class="headerlink" title="1. 压缩列表（ziplist）实现（内存优化）"></a>1. 压缩列表（ziplist）实现（内存优化）</h3><p>当Hash满足以下条件时，Redis会使用**压缩列表（ziplist）**存储：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">hash</span>-<span class="hljs-built_in">max</span>-ziplist-entries <span class="hljs-number">512</span>  <span class="hljs-comment"># 元素数量阈值（默认512）</span><br><span class="hljs-built_in">hash</span>-<span class="hljs-built_in">max</span>-ziplist-value <span class="hljs-number">64</span>     <span class="hljs-comment"># 单个键/值长度阈值（默认64字节）</span><br></code></pre></td></tr></table></figure>

<h4 id="为什么用ziplist？"><a href="#为什么用ziplist？" class="headerlink" title="为什么用ziplist？"></a>为什么用ziplist？</h4><ul>
<li><strong>内存占用低</strong>：压缩列表是连续内存块，没有指针开销</li>
<li><strong>适用场景</strong>：小Hash（元素少+键值小）</li>
</ul>
<h4 id="ziplist结构（简要）"><a href="#ziplist结构（简要）" class="headerlink" title="ziplist结构（简要）"></a>ziplist结构（简要）</h4><ul>
<li><code>entry</code>包含：<code>prevlen</code>（前节点长度）、<code>encoding</code>（类型+长度）、<code>data</code>（实际数据）</li>
</ul>
<hr>
<h3 id="2-哈希表（hashtable）实现（性能优先）"><a href="#2-哈希表（hashtable）实现（性能优先）" class="headerlink" title="2. 哈希表（hashtable）实现（性能优先）"></a>2. 哈希表（hashtable）实现（性能优先）</h3><p>当Hash超过上述阈值时，Redis会<strong>自动转换为哈希表</strong>实现。</p>
<h4 id="哈希表核心机制"><a href="#哈希表核心机制" class="headerlink" title="哈希表核心机制"></a>哈希表核心机制</h4><ol>
<li><strong>哈希函数</strong>：使用MurmurHash2算法（高效、低冲突）</li>
<li><strong>冲突解决</strong>：链地址法（每个桶维护一个链表）</li>
<li>动态扩容：<ul>
<li>当<code>used / size &gt; 0.7</code>时扩容（负载因子）</li>
<li>扩容为当前大小的2倍（如4→8→16→32…）</li>
<li><strong>增量式rehash</strong>：将数据逐步从ht[0]迁移到ht[1]</li>
</ul>
</li>
</ol>
<p><img src="/./../img/1baff6929e63428ab4ce6ead35657953.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dict</span>&#123;<br><br><br><br>    dictType *type;<br><br><br><br>    <span class="hljs-type">void</span> *privdata;<br><br><br><br>    dictht ht[<span class="hljs-number">2</span>];<br><br><br><br>    <span class="hljs-type">long</span> rehashidx;<br><br><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> iterators;<br><br>&#125; dict;<br></code></pre></td></tr></table></figure>

<p>​    **ht[2]：**表示在一个Dict结构中，包含有两个dictht的结构，也就是我们说的两张哈希表。</p>
<p>​    **rehashidx：**是dict在rehash时的偏移索引，具体如何工作在后边的rehash过程中会详细讲。</p>
<h4 id="dictht"><a href="#dictht" class="headerlink" title="dictht"></a>dictht</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictht</span>&#123;<br>    dictEntry **table;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br><br>&#125;dictht<br><br></code></pre></td></tr></table></figure>

<p>​     ****table：<strong>指向实际hash存储。存储可以看做是一个数组，所以是*table表示。（源码中的</strong>table是一个二级指针，也就是指向dictEntry*的指针）。</p>
<p>​    **size：**哈希表的大小。实际就是dictEntry有多少元素空间。</p>
<p>​    **sizemask：**哈希表大小的掩码表示，总是等于size-1.这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面，索引计算规则是index&#x3D;hash&amp;sizemask，前提是size的大小是二次方幂，这一点与JAVA哈希表底层计算索引是一样的原理。</p>
<p>​    **used：**表示已经使用的节点数量。通过这个字段可以很方便地查询到目前dict元素总量。</p>
<h3 id="Q1：为什么Redis的Hash在底层用字典（dict）而不是直接用哈希表？"><a href="#Q1：为什么Redis的Hash在底层用字典（dict）而不是直接用哈希表？" class="headerlink" title="Q1：为什么Redis的Hash在底层用字典（dict）而不是直接用哈希表？"></a>Q1：为什么Redis的Hash在底层用字典（dict）而不是直接用哈希表？</h3><p><strong>答</strong>：字典（dict）是Redis对哈希表的<strong>封装</strong>，提供了以下关键能力：</p>
<ul>
<li>两个哈希表实现增量式rehash</li>
<li>类型特性函数（dictType）支持多种数据类型</li>
<li>迭代器支持</li>
<li>通过<code>privdata</code>传递私有数据</li>
</ul>
<blockquote>
<p>💡 <strong>加分点</strong>：可以补充”Redis的字典是高度可定制的，可以用于实现String、Hash、Set等不同数据结构。”</p>
</blockquote>
<hr>
<h3 id="Q2：Redis的Hash在什么情况下会从ziplist转换为hashtable？"><a href="#Q2：Redis的Hash在什么情况下会从ziplist转换为hashtable？" class="headerlink" title="Q2：Redis的Hash在什么情况下会从ziplist转换为hashtable？"></a>Q2：Redis的Hash在什么情况下会从ziplist转换为hashtable？</h3><p><strong>答</strong>：当满足以下任一条件时：</p>
<ol>
<li><code>hash-max-ziplist-entries</code>：Hash中元素数量超过阈值（默认512）</li>
<li><code>hash-max-ziplist-value</code>：某个字段名或值的长度超过阈值（默认64字节）</li>
</ol>
<blockquote>
<p>💡 <strong>面试官会追问</strong>：为什么设置这两个阈值？ <strong>答</strong>：为了在<strong>内存效率</strong>和<strong>操作性能</strong>之间取得平衡：</p>
<ul>
<li>小Hash：用ziplist节省内存</li>
<li>大Hash：用hashtable保证操作速度</li>
</ul>
</blockquote>
<hr>
<h3 id="Q3：Redis的哈希表扩容时，为什么是2倍扩容？"><a href="#Q3：Redis的哈希表扩容时，为什么是2倍扩容？" class="headerlink" title="Q3：Redis的哈希表扩容时，为什么是2倍扩容？"></a>Q3：Redis的哈希表扩容时，为什么是2倍扩容？</h3><p><strong>答</strong>：2倍扩容是<strong>经验法则</strong>：</p>
<ol>
<li>避免频繁扩容（如果扩容因子是1.5，会频繁触发扩容）</li>
<li>保证负载因子在合理范围（0.5-0.7）</li>
<li>简单且高效（2的幂次方，计算索引快）</li>
</ol>
<blockquote>
<p>💡 <strong>面试官会追问</strong>：为什么负载因子选0.7？ <strong>答</strong>：根据哈希表理论，负载因子在0.7左右时，链表长度平均为1.5-2，平衡了内存利用率和查询性能。</p>
</blockquote>
<p>“Redis的Hash底层用字典（dict）实现，字典基于哈希表+链地址法；小Hash用ziplist节省内存，大Hash用hashtable保证性能——通过两个哈希表实现增量式rehash，避免扩容卡顿，这是Redis性能与内存平衡的完美体现！”</p>
<h2 id="哈希表扩容"><a href="#哈希表扩容" class="headerlink" title="哈希表扩容"></a>哈希表扩容</h2><p>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p>
<ul>
<li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</li>
<li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li>
<li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li>
</ul>
<h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>Redis 采用了<strong>渐进式 rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</p>
<p>举个例子，如果ht[0]中已经使用的节点数量为500，那么扩容时ht[1]被分配的空间是1024而不是1000。这么做是为了维护扩容后表的大小始终是2次方幂。</p>
<p>实现步骤</p>
<ol>
<li><strong>初始化新表与状态变量</strong> Redis 为 <em>ht[1]</em> 分配内存空间，并将 <em>rehashidx</em> 设置为 0，表示迁移开始。</li>
<li><strong>分批迁移数据</strong> 每次对字典执行增删改查操作时，除了完成用户请求，还会迁移 <em>ht[0]</em> 中 <em>rehashidx</em> 指向的哈希桶到 <em>ht[1]</em>。迁移完成后，<em>rehashidx</em> 加 1。</li>
<li><strong>主动迁移</strong> 为避免迁移因操作频率低而停滞，Redis 的定时任务会批量迁移多个哈希桶（如一次迁移 100 个）。</li>
<li><strong>读写操作适配双表</strong> 查询、删除、更新操作会先查找 <em>ht[1]</em>，再查找 <em>ht[0]</em>；新增操作只写入 <em>ht[1]</em>，避免旧表产生新数据。</li>
<li><strong>完成迁移</strong> 当 <em>rehashidx</em> 等于 <em>ht[0]</em> 的容量时，迁移完成。Redis 释放 <em>ht[0]</em> 的内存，将 <em>ht[1]</em> 赋值为 <em>ht[0]</em>，并重置 <em>ht[1]</em> 和 <em>rehashidx</em>。</li>
</ol>
<p>如果rehashidx刚好在一个已删除的空位置上，那么是直接返回还是尝试往下找？我们来看一下dictRehash函数的源码：</p>
<p>​    可以看到，答案是会继续往下去找，但是有个上限是n*10，即最多再找这么多次，n是传进来的参数，调用的时候实际值为1，即最多往后再找10个，这么做是防止因为连续碰到空位置导致主线程操作被阻塞。</p>
<h3 id="哈希表扩容的时候，有读请求怎么查？"><a href="#哈希表扩容的时候，有读请求怎么查？" class="headerlink" title="哈希表扩容的时候，有读请求怎么查？"></a>哈希表扩容的时候，有读请求怎么查？</h3><p>查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。</p>
<h2 id="介绍一下-Redis-中的-listpack"><a href="#介绍一下-Redis-中的-listpack" class="headerlink" title="介绍一下 Redis 中的 listpack"></a>介绍一下 Redis 中的 listpack</h2><p>quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。</p>
<p>因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。</p>
<p>于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p>
<p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p>
<p>我们先看看 listpack 结构：</p>
<p><img src="/./../img/1719035634188-584809ba-ea0b-48ff-a547-9ee4d1b4d365.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>listpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。</p>
<p>每个 listpack 节点结构如下：</p>
<p><img src="/./../img/1719035634415-c436d60e-58a7-4dfc-9e69-db8e2f96d19c.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>主要包含三个方面内容：</p>
<ul>
<li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li>
<li>data，实际存放的数据；</li>
<li>len，encoding+data的总长度；</li>
</ul>
<p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p>
<p><strong>Listpack 通过移除 <code>prevlen</code> 字段，让插入&#x2F;删除操作从 O(N) 变为 O(1)——它保留了 ziplist 的内存紧凑性，却彻底消灭了连锁更新，是 Redis 5.0 的最佳列表实现！</strong></p>
<h2 id="Listpack-vs-Ziplist：全面对比"><a href="#Listpack-vs-Ziplist：全面对比" class="headerlink" title="Listpack vs Ziplist：全面对比"></a>Listpack vs Ziplist：全面对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Ziplist</th>
<th>Listpack</th>
<th>优势</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>prevlen</code> 字段</strong></td>
<td>✅ 存在</td>
<td>❌ <strong>不存在</strong></td>
<td>✅ <strong>彻底消除连锁更新</strong></td>
</tr>
<tr>
<td><strong>节点长度计算</strong></td>
<td>依赖 <code>prevlen</code></td>
<td>通过 <code>encoding</code></td>
<td>✅ 更高效</td>
</tr>
<tr>
<td><strong>插入&#x2F;删除复杂度</strong></td>
<td>O(N)</td>
<td><strong>O(1)</strong></td>
<td>✅ 大幅提升性能</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>极低（小列表）</td>
<td><strong>略高但可忽略</strong></td>
<td>✅ 仍比普通链表节省 30%+</td>
</tr>
<tr>
<td><strong>最大元素数</strong></td>
<td>65535（需遍历）</td>
<td>255（用 <code>zsize</code> 计算）</td>
<td>✅ 无限制</td>
</tr>
<tr>
<td><strong>Redis 版本</strong></td>
<td>早期</td>
<td><strong>5.0+ 默认</strong></td>
<td>✅ 已成为标准</td>
</tr>
</tbody></table>
<h3 id="ziplist是怎么实现的？"><a href="#ziplist是怎么实现的？" class="headerlink" title="ziplist是怎么实现的？"></a>ziplist是怎么实现的？</h3><p>压缩列表是 Redis 为了节约内存而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组。</p>
<p><img src="/./../img/1720432496274-b95e1802-1ecd-4210-a987-733265534c64.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>压缩列表在表头有三个字段：</p>
<ul>
<li>*<strong>zlbytes*</strong>，记录整个压缩列表占用对内存字节数；</li>
<li>*<strong>zltail*</strong>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li>
<li>*<strong>zllen*</strong>，记录压缩列表包含的节点数量；</li>
<li>*<strong>zlend*</strong>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li>
</ul>
<p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p>
<p>另外，压缩列表节点（entry）的构成如下：</p>
<p><img src="/./../img/1720432496229-46da5ac0-0e89-45cd-b1f8-151f7c6d4660.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>压缩列表节点包含三部分内容：</p>
<ul>
<li><strong>prevlen</strong>，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；</li>
<li><strong>encoding</strong>，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。</li>
<li><strong>data</strong>，记录了当前节点的实际数据，类型和长度都由 encoding 决定；</li>
</ul>
<p>当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</strong>。</p>
<p>为什么ziplist能节省内存？ <strong>答</strong>：通过动态编码（如整数直接存储，字符串用长度编码），避免了字符串的额外长度存储，内存占用比普通哈希表低30%+。</p>
<p>压缩列表的缺点是会发生连锁更新的问题，因此<strong>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong>。</p>
<p>所以说，<strong>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题</strong>。</p>
<p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p>
<h3 id="Redis为什么使用跳表而不是用B-树"><a href="#Redis为什么使用跳表而不是用B-树" class="headerlink" title="Redis为什么使用跳表而不是用B+树?"></a>Redis为什么使用跳表而不是用B+树?</h3><p>Redis 是内存数据库，<strong>跳表在实现简单性、写入性能、内存访问模式等方面的综合优势</strong>，使其成为更合适的选择。</p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">跳表优势</th>
<th align="left">B+ 树劣势</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>内存访问</strong></td>
<td align="left">符合CPU缓存局部性，指针跳转更高效</td>
<td align="left">节点结构复杂，缓存不友好</td>
</tr>
<tr>
<td align="left"><strong>实现复杂度</strong></td>
<td align="left">代码简洁，无复杂平衡操作</td>
<td align="left">节点分裂&#x2F;合并逻辑复杂，代码量大</td>
</tr>
<tr>
<td align="left"><strong>写入性能</strong></td>
<td align="left">插入&#x2F;删除仅需调整局部指针</td>
<td align="left">插入可能触发递归节点分裂，成本高</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">结构紧凑，无内部碎片</td>
<td align="left">节点预分配可能浪费内存</td>
</tr>
</tbody></table>
<ul>
<li><strong>锁竞争</strong>：在并发环境下，B+ 树的锁粒度较粗（如页锁），容易成为性能瓶颈。</li>
<li><strong>细粒度锁或无锁</strong>：跳表可以通过分段锁或无锁结构（如 CAS）实现高效并发。</li>
</ul>
<p>Redis 选择使用跳表<strong>锁竞争</strong>：在并发环境下，B+ 树的锁粒度较粗（如页锁），容易成为性能瓶颈。（Skip List）而不是 B+ 树来实现有序集合（Sorted Set）等数据结构，是经过多方面权衡后的结果。</p>
<h3 id="跳表是怎么实现的？"><a href="#跳表是怎么实现的？" class="headerlink" title="跳表是怎么实现的？"></a>跳表是怎么实现的？</h3><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p>
<p>那跳表长什么样呢？我这里举个例子，下图展示了一个层级为 3 的跳表。</p>
<p><img src="/./../img/1719804939236-89f12a47-b851-4d06-a5f3-399e1119db57.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：</p>
<ul>
<li>L0 层级共有 5 个节点，分别是节点1、2、3、4、5；</li>
<li>L1 层级共有 3 个节点，分别是节点 2、3、5；</li>
<li>L2 层级只有 1 个节点，也就是节点 3 。</li>
</ul>
<p>如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。</p>
<p>可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。</p>
<p>那跳表节点是怎么实现多层级的呢？这就需要看「跳表节点」的数据结构了，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    <span class="hljs-comment">//Zset 对象的元素值</span><br>    sds ele;<br>    <span class="hljs-comment">//元素权重值</span><br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-comment">//后向指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br>  <br>    <span class="hljs-comment">//节点的level数组，保存每层上的前向指针和跨度</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;<br>    &#125; level[];<br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure>

<p>Zset 对象要同时保存「元素」和「元素的权重」，对应到跳表节点结构里就是 sds 类型的 ele 变量和 double 类型的 score 变量。每个跳表节点都有一个后向指针（struct zskiplistNode *backward），指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</p>
<p>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的<strong>zskiplistLevel 结构体类型的 level 数组</strong>。</p>
<p>level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。</p>
<p>比如，下面这张图，展示了各个节点的跨度。</p>
<p><img src="/./../img/1719804939577-56390d43-28b7-4d20-accf-55c79a53142e.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>第一眼看到跨度的时候，以为是遍历操作有关，实际上并没有任何关系，遍历操作只需要用前向指针（struct zskiplistNode *forward）就可以完成了。</p>
<p>Redis <strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p>
<p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p>
<p>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</p>
<p>虽然我前面讲解跳表的时候，图中的跳表的「头节点」都是 3 层高，但是其实<strong>如果层高最大限制是 64，那么在创建跳表「头节点」的时候，就会直接创建 64 层高的头节点</strong>。</p>
<h1 id="数据结构场景"><a href="#数据结构场景" class="headerlink" title="数据结构场景"></a>数据结构场景</h1><ul>
<li>在绝大多数情况下，<strong>String</strong> 更适合存储对象数据，尤其是当对象结构简单且整体读写是主要操作时。</li>
<li>如果你需要频繁操作对象的部分字段或节省内存，<strong>Hash</strong> 可能是更好的选择。</li>
</ul>
<p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p>
<ul>
<li>用户 id 为 key</li>
<li>商品 id 为 field，商品数量为 value</li>
</ul>
<p><code>Set</code> 的常见应用场景如下：</p>
<ul>
<li>存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code> 更适合一些）、文章点赞、动态点赞等等。</li>
<li>需要获取多个数据源交集、并集和差集的场景：共同好友（交集）、共同粉丝（交集）、共同关注（交集）、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集）等等。</li>
<li>需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。</li>
</ul>
<h3 id="使用-Set-实现抽奖系统怎么做？"><a href="#使用-Set-实现抽奖系统怎么做？" class="headerlink" title="[使用 Set 实现抽奖系统怎么做？]"></a>[使用 Set 实现抽奖系统怎么做？]</h3><p>如果想要使用 <code>Set</code> 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：</p>
<ul>
<li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li>
<li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li>
<li><code>SRANDMEMBER key count</code>：随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li>
</ul>
<p>end</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/redis/" class="print-no-link">#redis</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>30redis基础</div>
      <div>http://example.com/2025/11/17/30redis基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>無鎏雲</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年11月17日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/17/%E5%8A%9B%E6%89%A3208Trie%E6%A0%91/" title="208-Trie树">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">208-Trie树</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/16/24%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/" title="24分库分表和冷热分离">
                        <span class="hidden-mobile">24分库分表和冷热分离</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
