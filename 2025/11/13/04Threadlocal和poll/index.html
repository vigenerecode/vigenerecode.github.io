

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="無鎏雲">
  <meta name="keywords" content="">
  
    <meta name="description" content="Threadlocal是什么是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。 通常，我们会使用 synchronzed 关键字 或者 lock 来控制线程对临界区资源的同步顺序，但这种加锁的方式会让未获取到锁的线程进行阻塞，很显然，这种方式的时间效率不会特别高。 线程安全问题的核心在于多个线程会对">
<meta property="og:type" content="article">
<meta property="og:title" content="04Threadlocal和poll">
<meta property="og:url" content="http://example.com/2025/11/13/04Threadlocal%E5%92%8Cpoll/index.html">
<meta property="og:site_name" content="NoFlowCloud">
<meta property="og:description" content="Threadlocal是什么是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。 通常，我们会使用 synchronzed 关键字 或者 lock 来控制线程对临界区资源的同步顺序，但这种加锁的方式会让未获取到锁的线程进行阻塞，很显然，这种方式的时间效率不会特别高。 线程安全问题的核心在于多个线程会对">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/02ede02b26c85d797a995abf520e08b5.png">
<meta property="og:image" content="http://example.com/img/14e547adfd9dfea589e2e0141ff52718.png">
<meta property="article:published_time" content="2025-11-13T11:07:57.000Z">
<meta property="article:modified_time" content="2025-11-13T17:00:58.524Z">
<meta property="article:author" content="無鎏雲">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/02ede02b26c85d797a995abf520e08b5.png">
  
  
  
  <title>04Threadlocal和poll - NoFlowCloud</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Noflowcloud-Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="04Threadlocal和poll"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-11-13 19:07" pubdate>
          2025年11月13日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          40 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">04Threadlocal和poll</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Threadlocal是什么"><a href="#Threadlocal是什么" class="headerlink" title="Threadlocal是什么"></a>Threadlocal是什么</h1><p>是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。</p>
<p>通常，我们会使用 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/synchronized-1.html">synchronzed 关键字</a> 或者 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/lock.html">lock</a> 来控制线程对临界区资源的同步顺序，但这种加锁的方式会让未获取到锁的线程进行阻塞，很显然，这种方式的时间效率不会特别高。</p>
<p><strong>线程安全问题的核心在于多个线程会对同一个临界区的共享资源进行访问</strong>，那如果每个线程都拥有自己的“共享资源”，各用各的，互不影响，这样就不会出现线程安全的问题了，对吧？</p>
<p>事实上，这就是一种“<strong>空间换时间</strong>”的思想，每个线程拥有自己的“共享资源”，虽然内存占用变大了，但由于不需要同步，也就减少了线程可能存在的阻塞问题，从而提高时间上的效率。</p>
<p>ThreadLocal 并不在 java.util.concurrent 并发包下，而是在 java.lang 包下，但我更倾向于把它当作是一种并发容器。顾名思义，<strong>ThreadLocal 就是线程的“本地变量”，即每个线程都拥有该变量的一个副本，达到人手一份的目的，这样就可以避免共享资源的竞争</strong>。</p>
<h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><p>set 方法<br>set 方法用于设置当前线程中 ThreadLocal 的变量值，该方法的源码如下：</p>
<pre><code class="hljs">public void set(T value) &#123;
	//1. 获取当前线程实例对象
    Thread t = Thread.currentThread();
//2. 通过当前线程实例获取到ThreadLocalMap对象
ThreadLocalMap map = getMap(t);

if (map != null)
   //3. 如果Map不为null,则以当前ThreadLocal实例为key,值为value进行存入
   map.set(this, value);
else
  //4.map为null,则新建ThreadLocalMap并存入value
  createMap(t, value);&#125;
</code></pre>
<p>通过 Thread.currentThread() 方法获取当前调用此方法的线程实例。<br>每个线程都有自己的 ThreadLocalMap，这个映射表存储了线程的局部变量，其中键是 ThreadLocal 对象，值为特定于线程的对象。<br>如果 Map 不为 null，则以当前 ThreadLocal 实例为 key，值为 value 进行存入；如果 map 为 null，则新建 ThreadLocalMap 并存入 value。<br>通过源码我们知道，value 是存放在 ThreadLocalMap 里的。来看下 ThreadLocalMap 是什么，先有个简单的认识，后面会细讲。</p>
<p>ThreadLocalMap 是怎样来的呢？通过getMap(t)：</p>
<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title class_">ThreadLocalMap</span> <span class="hljs-title function_">getMap</span>(<span class="hljs-params">Thread</span> <span class="hljs-params">t</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">t</span>.<span class="hljs-property">ThreadLocals</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该方法直接返回当前线程对象 t 的一个成员变量 ThreadLocals：</p>
<p>以当前 ThreadLocal 实例作为 key，值为 value 存放到 ThreadLocalMap 中，然后将当前线程对象的 ThreadLocals 赋值为 ThreadLocalMap 对象。</p>
<p>set 方法的重要性在于它确保了每个线程都有自己的变量副本。由于这些变量是存储在与线程关联的映射表中的，所以不同的线程之间的这些变量互不影响。</p>
<h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap 是 ThreadLocal 类的静态内部类，它是一个定制的哈希表，专门用于保存每个线程中的线程局部变量。</p>
<p>和大多数容器一样，ThreadLocalMap 内部维护了一个 Entry 类型的数组 类型的数组 table，长度为 2 的幂次方。</p>
<p>Entry 继承了弱引用 <code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，它的 value 字段用于存储与特定 ThreadLocal 对象关联的值。使用弱引用作为键允许垃圾收集器在不再需要的情况下回收 ThreadLocal 实例。</p>
<h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><p>哈希表存储</p>
<p><strong>ThreadLocalMap 是使用开放地址法来处理哈希冲突的</strong>，和 HashMap 不同，之所以采用不同的方式主要是因为：</p>
<p>ThreadLocalMap 中的哈希值分散的比较均匀，很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象，冲突的概率就更小了。</p>
<h2 id="插入时"><a href="#插入时" class="headerlink" title="插入时"></a>插入时</h2><p>ThreadLocal 的 hashCode 是通过 <code>nextHashCode()</code> 方法获取的，该方法实际上是用 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/atomic.html">AtomicInteger</a> 加上 0x61c88647 来实现的。</p>
<p>0x61c88647 是一个魔数，用于 ThreadLocal 的哈希码递增。这个值的选择并不是随机的，它是一个质数，具有以下特性：</p>
<ul>
<li>质数：它是一个质数，这意味着它不能被除 1 和它本身之外的任何数字整除。</li>
<li>黄金比例：这个数字大约等于黄金比例的 32 位浮点表示的一半。黄金比例具有一些有趣的数学特性，其中之一是与斐波那契数列的关系。</li>
<li>递增分布：在 ThreadLocal 中，这个数字用于在哈希表中分散不同线程的哈希码，从而减少冲突。每当创建新的 ThreadLocal 对象时，都会将此值添加到上一个 ThreadLocal 的哈希码中。这个递增的步长有助于在哈希表中均匀地分配 ThreadLocal 对象。</li>
<li>性能优化：通过使用这个特定的值，算法能够确保哈希码的均匀分布，从而减少哈希冲突的可能性。这对于哈希表的性能至关重要，因为冲突可能会降低查找的效率。</li>
</ul>
<h4 id="02、怎样确定新值插入的位置？"><a href="#02、怎样确定新值插入的位置？" class="headerlink" title="02、怎样确定新值插入的位置？"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/thread/ThreadLocal.html#_02%E3%80%81%E6%80%8E%E6%A0%B7%E7%A1%AE%E5%AE%9A%E6%96%B0%E5%80%BC%E6%8F%92%E5%85%A5%E7%9A%84%E4%BD%8D%E7%BD%AE">02、怎样确定新值插入的位置？</a></h4><p>通过这行代码：<code>key.ThreadLocalHashCode &amp; (len-1)</code>。</p>
<p>同 <a target="_blank" rel="noopener" href="https://javabetter.cn/collection/hashmap.html">HashMap</a> 一样，通过当前 key 的 hashcode 与哈希表大小相与。原理我们在 HashMap 的时候已经讲过了，不记得的小伙伴可以回去看一遍。</p>
<h4 id="03、怎样解决-hash-冲突？"><a href="#03、怎样解决-hash-冲突？" class="headerlink" title="03、怎样解决 hash 冲突？"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/thread/ThreadLocal.html#_03%E3%80%81%E6%80%8E%E6%A0%B7%E8%A7%A3%E5%86%B3-hash-%E5%86%B2%E7%AA%81">03、怎样解决 hash 冲突？</a></h4><p>通过 <code>nextIndex(i, len)</code>，该方法中的<code>((i + 1 &lt; len) ? i + 1 : 0);</code> 能不断往后线性探测，当到哈希表末尾的时候再从 0 开始，成环形。</p>
<h4 id="04、怎样解决“脏”Entry？"><a href="#04、怎样解决“脏”Entry？" class="headerlink" title="04、怎样解决“脏”Entry？"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/thread/ThreadLocal.html#_04%E3%80%81%E6%80%8E%E6%A0%B7%E8%A7%A3%E5%86%B3-%E8%84%8F-entry">04、怎样解决“脏”Entry？</a></h4><p>我们知道，使用 ThreadLocal 有可能存在内存泄漏的问题，针对这种 key 为 null 的 Entry，我们称之为“stale entry”，直译为不新鲜的 entry，我把它理解为“脏 entry”。</p>
<p>当然了，Josh Bloch 和 Doug Lea 已经替我们考虑了这种情况，源码中提供了这些解决方案：</p>
<p>在向ThreadLocalMap添加新条目时，可以检查是否有“脏”Entry（键为null的Entry），并用新的条目替换它。这就是源码中的replaceStaleEntry方法所做的事情。</p>
<h1 id="Key和value"><a href="#Key和value" class="headerlink" title="Key和value"></a>Key和value</h1><p><code>ThreadLocalMap</code> 的 <code>key</code> 和 <code>value</code> 引用机制：</p>
<ul>
<li><strong>key 是弱引用</strong>：<code>ThreadLocalMap</code> 中的 key 是 <code>ThreadLocal</code> 的弱引用 (<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>)。 这意味着，如果 <code>ThreadLocal</code> 实例不再被任何强引用指向，垃圾回收器会在下次 GC 时回收该实例，导致 <code>ThreadLocalMap</code> 中对应的 key 变为 <code>null</code>。</li>
<li><strong>value 是强引用</strong>：即使 <code>key</code> 被 GC 回收，<code>value</code> 仍然被 <code>ThreadLocalMap.Entry</code> 强引用存在，无法被 GC 回收。</li>
</ul>
<p>当 <code>ThreadLocal</code> 实例失去强引用后，其对应的 value 仍然存在于 <code>ThreadLocalMap</code> 中，因为 <code>Entry</code> 对象强引用了它。如果线程持续存活（例如线程池中的线程），<code>ThreadLocalMap</code> 也会一直存在，导致 key 为 <code>null</code> 的 entry 无法被垃圾回收，即会造成内存泄漏。</p>
<p>也就是说，内存泄漏的发生需要同时满足两个条件：</p>
<ol>
<li><code>ThreadLocal</code> 实例不再被强引用；</li>
<li>线程持续存活，导致 <code>ThreadLocalMap</code> 长期存在。</li>
</ol>
<p>虽然 <code>ThreadLocalMap</code> 在 <code>get()</code>, <code>set()</code> 和 <code>remove()</code> 操作时会尝试清理 key 为 null 的 entry，但这种清理机制是被动的，并不完全可靠。</p>
<h2 id="如何避免内存泄漏的发生？"><a href="#如何避免内存泄漏的发生？" class="headerlink" title="如何避免内存泄漏的发生？"></a><strong>如何避免内存泄漏的发生？</strong></h2><ol>
<li>在使用完 <code>ThreadLocal</code> 后，务必调用 <code>remove()</code> 方法。 这是最安全和最推荐的做法。 <code>remove()</code> 方法会从 <code>ThreadLocalMap</code> 中显式地移除对应的 entry，彻底解决内存泄漏的风险。 即使将 <code>ThreadLocal</code> 定义为 <code>static final</code>，也强烈建议在每次使用后调用 <code>remove()</code>。</li>
<li>在线程池等线程复用的场景下，使用 <code>try-finally</code> 块可以确保即使发生异常，<code>remove()</code> 方法也一定会被执行。</li>
</ol>
<h2 id="为什么ThreadLocal的key必须是弱引用？——详细解释"><a href="#为什么ThreadLocal的key必须是弱引用？——详细解释" class="headerlink" title="为什么ThreadLocal的key必须是弱引用？——详细解释"></a>为什么ThreadLocal的key必须是弱引用？——详细解释</h2><p>核心问题：为什么<code>tl = null</code>后ThreadLocal实例无法被回收？</p>
<p><strong>关键点</strong>：当<code>tl = null</code>后，<strong>ThreadLocalMap仍然持有对ThreadLocal实例的强引用</strong>，导致GC无法回收它。</p>
<h3 id="场景分析（key是强引用的情况）"><a href="#场景分析（key是强引用的情况）" class="headerlink" title="场景分析（key是强引用的情况）"></a>场景分析（key是强引用的情况）</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">ThreadLocal&lt;<span class="hljs-built_in">String</span>&gt; tl = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;(); <span class="hljs-comment">// 创建ThreadLocal实例</span><br>tl.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// ThreadLocalMap存储：key = tl（强引用），value = &quot;hello&quot;</span><br>tl = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 外部引用被置为null</span><br></code></pre></td></tr></table></figure>

<ol>
<li><strong>初始状态</strong>：<ul>
<li><code>tl</code>是一个强引用，指向ThreadLocal实例</li>
<li>ThreadLocalMap（属于当前线程）中存储了一个Entry：<code>key = tl</code>（强引用），<code>value = &quot;hello&quot;</code></li>
</ul>
</li>
<li><strong><code>tl = null</code>后</strong>：<ul>
<li>外部代码不再持有对ThreadLocal实例的强引用</li>
<li>但<strong>ThreadLocalMap仍然持有对ThreadLocal实例的强引用</strong></li>
<li>因为key是强引用，所以ThreadLocalMap对ThreadLocal实例的引用是强引用</li>
</ul>
</li>
<li><strong>GC行为</strong>：<ul>
<li>GC会检查所有对象的引用</li>
<li>ThreadLocal实例被ThreadLocalMap强引用，所以不会被回收</li>
<li>ThreadLocal实例内存泄漏：一直占用内存</li>
</ul>
</li>
</ol>
<h3 id="为什么这样会导致内存泄漏？"><a href="#为什么这样会导致内存泄漏？" class="headerlink" title="为什么这样会导致内存泄漏？"></a>为什么这样会导致内存泄漏？</h3><p>想象一下：</p>
<ul>
<li>你创建了一个ThreadLocal实例，然后将其设置为null</li>
<li>但ThreadLocalMap（属于线程）仍然”抓着”这个实例不放</li>
<li>线程可能长期存活（如线程池中的线程）</li>
<li>这个ThreadLocal实例会一直占用内存，直到线程结束</li>
</ul>
<h3 id="对比：key是弱引用的情况"><a href="#对比：key是弱引用的情况" class="headerlink" title="对比：key是弱引用的情况"></a>对比：key是弱引用的情况</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">ThreadLocal&lt;<span class="hljs-built_in">String</span>&gt; tl = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;(); <span class="hljs-comment">// 创建ThreadLocal实例</span><br>tl.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// ThreadLocalMap存储：key = tl（弱引用），value = &quot;hello&quot;</span><br>tl = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 外部引用被置为null</span><br></code></pre></td></tr></table></figure>

<ol>
<li><strong><code>tl = null</code>后</strong>：<ul>
<li>外部代码不再持有对ThreadLocal实例的强引用（运行完栈不再指向队中的ThreadLocal实例）</li>
<li>ThreadLocalMap中key是弱引用，所以ThreadLocalMap对ThreadLocal实例的引用是弱引用</li>
</ul>
</li>
<li><strong>GC行为</strong>：<ul>
<li>GC会回收ThreadLocal实例（因为没有强引用）</li>
<li>ThreadLocalMap中的key会变成null</li>
<li>为后续清理提供机会</li>
</ul>
</li>
</ol>
<h3 id="为什么”ThreadLocalMap仍然持有对tl的强引用”会导致问题？"><a href="#为什么”ThreadLocalMap仍然持有对tl的强引用”会导致问题？" class="headerlink" title="为什么”ThreadLocalMap仍然持有对tl的强引用”会导致问题？"></a>为什么”ThreadLocalMap仍然持有对tl的强引用”会导致问题？</h3><p>这是理解的关键：</p>
<ul>
<li><strong>ThreadLocalMap是Thread的一部分</strong>，而Thread通常不会很快结束（特别是线程池中的线程）</li>
<li><strong>ThreadLocalMap的生命周期与Thread相同</strong>，线程存活，ThreadLocalMap就存活</li>
<li><strong>当key是强引用时，ThreadLocalMap对ThreadLocal实例的引用阻止了GC回收</strong></li>
</ul>
<h3 id="为什么不能让ThreadLocalMap的key是弱引用，value是弱引用？"><a href="#为什么不能让ThreadLocalMap的key是弱引用，value是弱引用？" class="headerlink" title="为什么不能让ThreadLocalMap的key是弱引用，value是弱引用？"></a>为什么不能让ThreadLocalMap的key是弱引用，value是弱引用？</h3><ul>
<li>如果value也是弱引用，那么即使ThreadLocal实例还在，value也可能被GC提前回收</li>
<li>这违背了ThreadLocal的设计目标：<strong>只要线程还活着，就应该能获取到存储的值</strong></li>
<li>例如：<code>String value = tl.get()</code> 可能返回null，即使之前set过</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>核心原因</strong>：ThreadLocal的key必须是弱引用，是为了确保当外部代码不再需要ThreadLocal实例时，ThreadLocal实例可以被GC回收，避免内存泄漏。</p>
<p><strong>为什么”tl无法被GC回收”</strong>：因为ThreadLocalMap（属于线程）对ThreadLocal实例的引用是强引用，阻止了GC回收。</p>
<blockquote>
<p>💡 <strong>重要提示</strong>：即使key是弱引用，ThreadLocal的value仍然是强引用，如果忘记调用<code>remove()</code>，value仍然会泄漏。所以，<strong>正确使用ThreadLocal的关键是：使用完后调用<code>remove()</code></strong>。</p>
</blockquote>
<h1 id="Threadpool"><a href="#Threadpool" class="headerlink" title="Threadpool"></a>Threadpool</h1><h2 id="一、什么是线程池"><a href="#一、什么是线程池" class="headerlink" title="一、什么是线程池"></a>一、什么是线程池</h2><p>线程池其实是一种池化的技术实现，池化技术的核心思想就是实现资源的复用，避免资源的重复创建和销毁带来的性能开销。线程池可以管理一堆线程，让线程执行完任务之后不进行销毁，而是继续去处理其它线程已经提交的任务。</p>
<p>使用线程池的好处</p>
<p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h2 id="二、线程池的构造"><a href="#二、线程池的构造" class="headerlink" title="二、线程池的构造"></a>二、线程池的构造</h2><p>Java 主要是通过构建 ThreadPoolExecutor 来创建线程池的。</p>
<ul>
<li>corePoolSize：线程池中用来工作的核心线程数量。</li>
<li>maximumPoolSize：最大线程数，线程池允许创建的最大线程数。</li>
<li>keepAliveTime：超出 corePoolSize 后创建的线程存活时间或者是所有线程最大存活时间，取决于配置。</li>
<li>unit：keepAliveTime 的时间单位。</li>
<li>workQueue：任务队列，是一个阻塞队列，当线程数达到核心线程数后，会将任务存储在阻塞队列中。</li>
<li>threadFactory ：线程池内部创建线程所用的工厂。</li>
<li>handler：拒绝策略；当队列已满并且线程数量达到最大线程数量时，会调用该方法处理任务。</li>
</ul>
<h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><img src="/./../img/02ede02b26c85d797a995abf520e08b5.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="线程池中线程实现复用的原理"><a href="#线程池中线程实现复用的原理" class="headerlink" title="线程池中线程实现复用的原理"></a>线程池中线程实现复用的原理</h2><p>线程池的核心功能就是实现线程的重复利用，那么线程池是如何实现线程的复用呢？</p>
<p>线程在线程池内部其实被封装成了一个 Worker 对象</p>
<p>runWorker 内部使用了 while 死循环，当第一个任务执行完之后，会不断地通过 getTask 方法获取任务，只要能获取到任务，就会调用 run 方法继续执行任务，这就是线程能够复用的主要原因。</p>
<p>但是如果从 getTask 获取不到方法的话，就会调用 finally 中的 processWorkerExit 方法，将线程退出。</p>
<p>这里有个一个细节就是，因为 Worker 继承了 AQS，每次在执行任务之前都会调用 Worker 的 lock 方法，执行完任务之后，会调用 unlock 方法，这样做的目的就可以通过 Woker 的加锁状态判断出当前线程是否正在执行任务。</p>
<p>如果想知道线程是否正在执行任务，只需要调用 Woker 的 tryLock 方法，根据是否加锁成功就能判断，加锁成功说明当前线程没有加锁，也就没有执行任务了，在调用 shutdown 方法关闭线程池的时候，就时用这种方式来判断线程有没有在执行任务，如果没有的话，会尝试打断没有执行任务的线程。</p>
<h2 id="线程是如何获取任务以及如何实现超时的"><a href="#线程是如何获取任务以及如何实现超时的" class="headerlink" title="线程是如何获取任务以及如何实现超时的"></a>线程是如何获取任务以及如何实现超时的</h2><p><img src="/./../img/14e547adfd9dfea589e2e0141ff52718.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="线程池的-5-种状态"><a href="#线程池的-5-种状态" class="headerlink" title="线程池的 5 种状态"></a>线程池的 5 种状态</h2><p>线程池内部有 5 个常量来代表线程池的五种状态</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> RUNNING    = <span class="hljs-number">-1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure>

<ul>
<li>RUNNING：线程池创建时就是这个状态，能够接收新任务，以及对已添加的任务进行处理。</li>
<li>SHUTDOWN：调用 shutdown 方法，线程池就会转换成 SHUTDOWN 状态，此时线程池不再接收新任务，但能继续处理已添加的任务到队列中。</li>
<li>STOP：调用 shutdownNow 方法，线程池就会转换成 STOP 状态，不接收新任务，也不能继续处理已添加的任务到队列中任务，并且会尝试中断正在处理的任务的线程。</li>
<li>TIDYING：SHUTDOWN 状态下，任务数为 0， 其他所有任务已终止，线程池会变为 TIDYING 状态；线程池在 SHUTDOWN 状态，任务队列为空且执行中任务为空，线程池会变为 TIDYING 状态；线程池在 STOP 状态，线程池中执行中任务为空时，线程池会变为 TIDYING 状态。</li>
<li>TERMINATED：线程池彻底终止。线程池在 TIDYING 状态执行完 <code>terminated()</code> 方法就会转变为 TERMINATED 状态。</li>
</ul>
<p>线程池状态具体是存在 ctl 成员变量中的，ctl 中不仅存储了线程池的状态还存储了当前线程池中线程数的大小</p>
<p>所以也可以看出 shutdown 方法和 shutdownNow 方法的主要区别就是，shutdown 之后还能处理在队列中的任务，shutdownNow 直接就将任务从队列中移除，线程池里的线程就不再处理了。</p>
<h2 id="Executors-构建线程池以及问题分析"><a href="#Executors-构建线程池以及问题分析" class="headerlink" title="Executors 构建线程池以及问题分析"></a>Executors 构建线程池以及问题分析</h2><p>虽然 JDK 提供了快速创建线程池的方法，但其实不推荐使用 Executors 来创建线程池。</p>
<p>Executors 返回线程池对象的弊端如下(后文会详细介绍到)：</p>
<p>FixedThreadPool 和 SingleThreadExecutor:使用的是阻塞队列 LinkedBlockingQueue，任务队列最大长度为 Integer.MAX_VALUE，可以看作是无界的，可能堆积大量的请求，从而导致 OOM。</p>
<p>CachedThreadPool:使用的是同步队列 SynchronousQueue, 允许创建的线程数量为 Integer.MAX_VALUE ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</p>
<p>ScheduledThreadPool 和 SingleThreadScheduledExecutor:使用的无界的延迟阻塞队列DelayedWorkQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</p>
<h2 id="回收核心吗？"><a href="#回收核心吗？" class="headerlink" title="回收核心吗？"></a>回收核心吗？</h2><p><code>ThreadPoolExecutor</code> 默认不会回收核心线程，即使它们已经空闲了。这是为了减少创建线程的开销，因为核心线程通常是要长期保持活跃的。但是，如果线程池是被用于周期性使用的场景，且频率不高（周期之间有明显的空闲时间），可以考虑将 <code>allowCoreThreadTimeOut(boolean value)</code> 方法的参数设置为 <code>true</code>，这样就会回收空闲（时间间隔由 <code>keepAliveTime</code> 指定）的核心线程了</p>
<h2 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h2><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolExecutor</code> 定义一些策略:</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：调用执行者自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果你的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
</ul>
<p>不过，如果走到<code>CallerRunsPolicy</code>的任务是个非常耗时的任务，且处理提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。</p>
<ul>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<h2 id="线程池中线程异常后，销毁还是复用？"><a href="#线程池中线程异常后，销毁还是复用？" class="headerlink" title="线程池中线程异常后，销毁还是复用？"></a>线程池中线程异常后，销毁还是复用？</h2><p>直接说结论，需要分两种情况：</p>
<p>使用execute()提交任务：</p>
<p>​	当任务通过execute()提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么该异常会导致当前线程终止，并且异常会被打印到控制台或日志文件中。线程池会检测到这种线程终止，并创建一个新线程来替换它，从而保持配置的线程数不变。</p>
<p>使用submit()提交任务：</p>
<p>​	对于通过submit()提交的任务，如果在任务执行中发生异常，这个异常不会直接打印出来。相反，异常会被封装在由submit()返回的Future对象中。当调用Future.get()方法时，可以捕获到一个ExecutionException。在这种情况下，线程不会因为异常而终止，它会继续存在于线程池中，准备执行后续的任务。</p>
<p>简单来说：使用execute()时，未捕获异常导致线程终止，线程池创建新线程替代；使用submit()时，异常被封装在Future中，线程继续复用。这种设计允许submit()提供更灵活的错误处理机制，因为它允许调用者决定如何处理异常，而execute()则适用于那些不需要关注执行结果的场景。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>end</p>
<p>?</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/JUC/" class="print-no-link">#JUC</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>04Threadlocal和poll</div>
      <div>http://example.com/2025/11/13/04Threadlocal和poll/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>無鎏雲</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年11月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/13/Git%E4%B8%8EGitLab%E7%9A%84%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/" title="Git">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Git</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/13/03%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%EF%BC%88%E6%97%A0hashmap%EF%BC%89/" title="03并发容器（无hashmap）">
                        <span class="hidden-mobile">03并发容器（无hashmap）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
