

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="無鎏雲">
  <meta name="keywords" content="">
  
    <meta name="description" content="x线程入门多线程的很多概念听起来就很难理解。比方说：  进程，是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发。 线程，是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。  总结来说，进程和线程都是操作系统用于并发执行的方式，但是它们在资源管理、独立性、开销以及影响范围等方面有所不同。  进程是操作系统分配资源的基本单位，线程是操作系统调度的基本">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC">
<meta property="og:url" content="http://example.com/2025/11/13/00JUC(%E7%BA%BF%E7%A8%8B-sync)/index.html">
<meta property="og:site_name" content="NoFlowCloud">
<meta property="og:description" content="x线程入门多线程的很多概念听起来就很难理解。比方说：  进程，是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发。 线程，是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。  总结来说，进程和线程都是操作系统用于并发执行的方式，但是它们在资源管理、独立性、开销以及影响范围等方面有所不同。  进程是操作系统分配资源的基本单位，线程是操作系统调度的基本">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/image-20251112145648703.png">
<meta property="og:image" content="http://example.com/img/thread-state-and-method-20230829143200.png">
<meta property="og:image" content="http://example.com/img/thread-bring-some-problem-119223c9-83a9-42e1-9a0c-f9c706a1e793.png">
<meta property="og:image" content="http://example.com/img/jmm-a610752d-ef73-47f2-b02c-6954eb3d62bf.png">
<meta property="og:image" content="http://example.com/img/image-20251112220823274.png">
<meta property="article:published_time" content="2025-11-12T17:07:57.000Z">
<meta property="article:modified_time" content="2025-11-12T15:59:17.575Z">
<meta property="article:author" content="無鎏雲">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/image-20251112145648703.png">
  
  
  
  <title>JUC - NoFlowCloud</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Noflowcloud-Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JUC"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-11-13 01:07" pubdate>
          2025年11月13日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          64 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">JUC</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="x线程入门"><a href="#x线程入门" class="headerlink" title="x线程入门"></a>x线程入门</h1><p>多线程的很多概念听起来就很难理解。比方说：</p>
<ul>
<li>进程，是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发。</li>
<li>线程，是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。</li>
</ul>
<p>总结来说，进程和线程都是操作系统用于并发执行的方式，但是它们在资源管理、独立性、开销以及影响范围等方面有所不同。</p>
<ul>
<li>进程是操作系统分配资源的基本单位，线程是操作系统调度的基本单位。</li>
<li>进程拥有独立的内存空间，线程共享所属进程的内存空间。</li>
<li>进程的创建和销毁需要资源的分配和回收，开销较大；线程的创建和销毁只需要保存寄存器和栈信息，开销较小。</li>
<li>进程间的通信比较复杂，而线程间的通信比较简单。</li>
<li>进程间是相互独立的，一个进程崩溃不会影响其他进程；线程间是相互依赖的，一个线程崩溃可能影响整个程序的稳定性。</li>
</ul>
<h2 id="线程创建方法Thread-start"><a href="#线程创建方法Thread-start" class="headerlink" title="线程创建方法Thread.start()"></a>线程创建方法Thread.start()</h2><p>根据知识库信息，Java中创建线程主要有以下四种方式，每种方式都有其适用场景和优缺点：</p>
<h3 id="继承thread类"><a href="#继承thread类" class="headerlink" title="继承thread类"></a>继承thread类</h3><p><strong>特点</strong>：</p>
<ul>
<li>直接继承<code>Thread</code>类，重写<code>run()</code>方法</li>
<li>代码简单直观，新手容易理解</li>
<li>无法实现多继承（Java单继承限制）</li>
</ul>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现<code>Runnable</code>接口</h3><p><strong>特点</strong>：</p>
<ul>
<li>实现<code>Runnable</code>接口，重写<code>run()</code>方法</li>
<li>线程与任务解耦，任务逻辑独立于线程管理</li>
<li>支持Lambda表达式简化代码</li>
</ul>
<ol start="3">
<li>实现Callable接口（带返回值）</li>
</ol>
<h3 id="callable"><a href="#callable" class="headerlink" title="callable"></a>callable</h3><p><strong>特点</strong>：</p>
<ul>
<li>实现<code>Callable</code>接口，重写<code>call()</code>方法</li>
<li>可返回任务执行结果（通过<code>FutureTask</code>）</li>
<li>可抛出受检异常</li>
<li>需要配合<code>FutureTask</code>使用</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Callable</span></span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> call() throws Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Callable任务执行&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务结果&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用方式</span><br>Callable&lt;<span class="hljs-keyword">String</span>&gt; callable = <span class="hljs-keyword">new</span><span class="hljs-type"></span> MyCallable();<br>FutureTask&lt;<span class="hljs-keyword">String</span>&gt; futureTask = <span class="hljs-keyword">new</span><span class="hljs-type"></span> FutureTask&lt;&gt;(callable);<br><span class="hljs-keyword">new</span><span class="hljs-type"></span> Thread(futureTask).start();<br><br><span class="hljs-comment">// 获取结果</span><br><span class="hljs-keyword">String</span> result = futureTask.<span class="hljs-keyword">get</span>(); <span class="hljs-comment">// 阻塞等待结果</span><br></code></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：</p>
<ul>
<li>需要获取异步任务结果的场景</li>
<li>需要处理异常的场景</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 优点：可以返回执行结果，可抛出受检异常</li>
<li>❌ 缺点：需要额外使用<code>FutureTask</code>，代码稍复杂，阻塞等待</li>
</ul>
<h3 id="使用线程池（最佳实践）"><a href="#使用线程池（最佳实践）" class="headerlink" title="使用线程池（最佳实践）"></a>使用线程池（最佳实践）</h3><p><strong>特点</strong>：</p>
<ul>
<li>通过<code>ExecutorService</code>创建线程池</li>
<li>避免频繁创建和销毁线程，资源管理高效</li>
<li>可控制并发数量，提高系统稳定性</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-regexp">// 创建固定大小的线程池</span><br><span class="hljs-regexp">ExecutorService executor = Executors.newFixedThreadPool(5);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">//</span> 提交任务<br>executor.submit<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    System.out.println(<span class="hljs-string">&quot;线程池任务执行&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 关闭线程池</span><br><span class="hljs-function"><span class="hljs-title">executor</span>.<span class="hljs-title">shutdown</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：</p>
<ul>
<li>生产环境，需要高效管理线程的场景</li>
<li>高并发处理（如批量处理10万条订单数据）</li>
<li>需要超时重试的场景（如调用第三方接口）</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>✅ 优点：资源管理高效，系统稳定性高，可控制并发数量</li>
</ul>
<h2 id="关于线程的一些疑问"><a href="#关于线程的一些疑问" class="headerlink" title="[关于线程的一些疑问]"></a>[关于线程的一些疑问]</h2><h3 id="❤1、为什么要重写-run-方法？"><a href="#❤1、为什么要重写-run-方法？" class="headerlink" title="[❤1、为什么要重写 run 方法？]"></a>[❤1、为什么要重写 run 方法？]</h3><p>这是因为默认的<code>run()</code>方法不会做任何事情。</p>
<p>为了让线程执行一些实际的任务，我们需要提供自己的<code>run()</code>方法实现，这就需要重写<code>run()</code>方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>  public void run() &#123;<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;MyThread running&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们重写了<code>run()</code>方法，使其打印出一条消息。当我们创建并启动这个线程的实例时，它就会打印出这条消息。</p>
<h3 id="❤2、run-方法和-start-方法有什么区别？"><a href="#❤2、run-方法和-start-方法有什么区别？" class="headerlink" title="[❤2、run 方法和 start 方法有什么区别？]"></a>[❤2、run 方法和 start 方法有什么区别？]</h3><ul>
<li><code>run()</code>：封装线程执行的代码，直接调用相当于调用普通方法。</li>
<li><code>start()</code>：启动线程，然后由 JVM 调用此线程的 <code>run()</code> 方法。</li>
</ul>
<h3 id="❤3、通过继承-Thread-的方法和实现-Runnable-接口的方式创建多线程，哪个好？"><a href="#❤3、通过继承-Thread-的方法和实现-Runnable-接口的方式创建多线程，哪个好？" class="headerlink" title="❤3、通过继承 Thread 的方法和实现 Runnable 接口的方式创建多线程，哪个好？"></a><strong>❤3、通过继承 Thread 的方法和实现 Runnable 接口的方式创建多线程，哪个好？</strong></h3><p>实现 Runable 接口好，原因有两个：</p>
<ul>
<li>♠①、避免了 Java 单继承的局限性，Java 不支持多重继承，因此如果我们的类已经继承了另一个类，就不能再继承 Thread 类了。</li>
<li>♠②、适合多个相同的程序代码去处理同一资源的情况，把线程、代码和数据有效的分离，更符合面向对象的设计思想。Callable 接口与 Runnable 非常相似，但可以返回一个结果。</li>
</ul>
<h2 id="线程几种方法"><a href="#线程几种方法" class="headerlink" title="线程几种方法"></a>线程几种方法</h2><h3 id="1wait和sleep"><a href="#1wait和sleep" class="headerlink" title="1wait和sleep"></a>1wait和sleep</h3><p>wait是object的顺便用，sleep只能线程使用；wait只能在锁下使用，无锁环境用wait报错</p>
<p>sleep 和 wait 区别：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>Thread.sleep()</code></th>
<th align="left"><code>Object.wait()</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>锁行为</strong></td>
<td align="left"><strong>不释放锁</strong></td>
<td align="left"><strong>释放锁</strong></td>
</tr>
<tr>
<td align="left"><strong>所属类</strong></td>
<td align="left"><code>Thread</code> 类的静态方法</td>
<td align="left"><code>Object</code> 类的实例方法</td>
</tr>
<tr>
<td align="left"><strong>唤醒方式</strong></td>
<td align="left">时间到自动唤醒</td>
<td align="left">需要 <code>notify()</code>&#x2F;<code>notifyAll()</code> 或超时</td>
</tr>
<tr>
<td align="left"><strong>同步要求</strong></td>
<td align="left">不需要在同步块中</td>
<td align="left">必须在同步块中</td>
</tr>
</tbody></table>
<p><img src="/./../img/image-20251112145648703.png" srcset="/img/loading.gif" lazyload alt="image-20251112145648703"></p>
<h3 id="2）join"><a href="#2）join" class="headerlink" title="2）join()"></a>2）join()</h3><p>等待这个线程执行完才会轮到后续线程得到 cpu 的执行权，使用这个也要捕获异常。</p>
<h3 id="3）setDaemon"><a href="#3）setDaemon" class="headerlink" title="3）setDaemon()"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/thread/wangzhe-thread.html#_3-setdaemon">3）setDaemon()</a></h3><p>将此线程标记为守护线程，准确来说，就是服务其他的线程，像 Java 中的垃圾回收线程，就是典型的守护线程。</p>
<h3 id="4）yield"><a href="#4）yield" class="headerlink" title="4）yield()"></a><a target="_blank" rel="noopener" href="https://javabetter.cn/thread/wangzhe-thread.html#_4-yield">4）yield()</a></h3><p>yield() 方法是一个静态方法，用于暗示当前线程愿意放弃其当前的时间片，允许其他线程执行。然而，它只是向线程调度器提出建议，调度器可能会忽略这个建议。具体行为取决于操作系统和 <a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/what-is-jvm.html">JVM</a> 的线程调度策略。</p>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>我们通过 Future 来获取 Callable 任务的执行结果，那么 Future 是什么呢？</p>
<p>Future 位于 <code>java.util.concurrent</code> 包下，它是一个接口：</p>
<p>Future 提供了三种功能：</p>
<ul>
<li>1）判断任务是否完成；</li>
<li>2）能够中断任务；</li>
<li>3）能够获取任务执行结果。</li>
</ul>
<p>由于 Future 只是一个接口，如果直接 new 的话，编译器是会有一个 ⚠️ 警告的，它会提醒我们最好使用 FutureTask。</p>
<ul>
<li><strong>FutureTask本身</strong>：是一个线程安全的类，用于封装异步计算任务</li>
<li><strong>FutureTask的get()方法</strong>：会阻塞等待任务完成</li>
<li><strong>不是阻塞等待结构</strong>，而是提供了一个<strong>阻塞等待机制</strong>（通过get()方法）来获取任务结果</li>
</ul>
<p>简单来说，FutureTask是”任务容器”，而它的get()方法提供了”阻塞等待”功能。</p>
<h2 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h2><p> Java 线程的 6 个状态：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// <span class="hljs-keyword">Thread</span>.State 源码<br>public enum State &#123;<br><span class="hljs-built_in">    NEW,</span><br><span class="hljs-built_in">    RUNNABLE,</span><br><span class="hljs-built_in">    BLOCKED,</span><br><span class="hljs-built_in">    WAITING,</span><br><span class="hljs-built_in">    TIMED_WAITING,</span><br>    TERMINATED<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><p>处于 NEW 状态的线程此时尚未启动。这里的尚未启动指的是还没调用 Thread 实例的<code>start()</code>方法。</p>
<h4 id="关于-start-的两个引申问题"><a href="#关于-start-的两个引申问题" class="headerlink" title="[关于 start 的两个引申问题]"></a>[关于 start 的两个引申问题]</h4><ol>
<li><p>反复调用同一个线程的 start 方法是否可行？</p>
</li>
<li><p>假如一个线程执行完毕（此时处于 TERMINATED 状态），再次调用这个线程的 start 方法是否可行？</p>
</li>
<li><p>都不行，在调用 start 之后，threadStatus 的值会改变（<code>threadStatus !=0</code>），再次调用 start 方法会抛出 IllegalThreadStateException 异常。</p>
</li>
<li><p>threadStatus 为 2 代表当前线程状态为 TERMINATED（下面会讲）。</p>
</li>
</ol>
<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><p>表示当前线程正在运行中。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配资源。</p>
<h3 id="Blocked"><a href="#Blocked" class="headerlink" title="Blocked"></a>Blocked</h3><p>阻塞状态。处于 BLOCKED 状态的线程正等待<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/lock.html">锁</a>（锁会在后面细讲）的释放以进入同步区。</p>
<h3 id="waitting"><a href="#waitting" class="headerlink" title="waitting"></a>waitting</h3><p>等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒。</p>
<p>调用下面这 3 个方法会使线程进入等待状态：</p>
<ul>
<li><code>Object.wait()</code>：使当前线程处于等待状态直到另一个线程唤醒它；</li>
<li><code>Thread.join()</code>：等待线程执行完毕，底层调用的是 Object 的 wait 方法；</li>
<li><code>LockSupport.park()</code>：除非获得调用许可，否则禁用当前线程进行线程调度。<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/LockSupport.html">LockSupport</a> 我们在后面会细讲。</li>
</ul>
<h3 id="timed-waiting"><a href="#timed-waiting" class="headerlink" title="timed_waiting"></a>timed_waiting</h3><p>超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。</p>
<p>调用如下方法会使线程进入超时等待状态：</p>
<ul>
<li><code>Thread.sleep(long millis)</code>：使当前线程睡眠指定时间；</li>
<li><code>Object.wait(long timeout)</code>：线程休眠指定时间，等待期间可以通过<code>notify()</code>&#x2F;<code>notifyAll()</code>唤醒；</li>
<li><code>Thread.join(long millis)</code>：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行；</li>
<li><code>LockSupport.parkNanos(long nanos)</code>： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/LockSupport.html">LockSupport</a> 我们在后面会细讲；</li>
<li><code>LockSupport.parkUntil(long deadline)</code>：同上，也是禁止线程进行调度指定时间；</li>
</ul>
<h3 id="terminated"><a href="#terminated" class="headerlink" title="terminated"></a>terminated</h3><p>终止状态。此时线程已执行完毕。</p>
<h3 id="线程状态的转换"><a href="#线程状态的转换" class="headerlink" title="[线程状态的转换]"></a>[线程状态的转换]</h3><p><img src="/./../img/thread-state-and-method-20230829143200.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p><img src="/./../img/thread-bring-some-problem-119223c9-83a9-42e1-9a0c-f9c706a1e793.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>线程安全问题：多个线程操作同一个共享整据，导致线程安全问题</p>
<h2 id="并发编程三大问题"><a href="#并发编程三大问题" class="headerlink" title="并发编程三大问题"></a>并发编程三大问题</h2><ul>
<li><strong>原子性：<strong>即不可分割性。比如 a&#x3D;0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作是原子操作。再比如：a++； 这个操作实际是a &#x3D; a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要</strong>使用同步技术（sychronized）或者锁（Lock）来让它变成一个原子操作</strong>。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：<strong>AtomicInteger、AtomicLong、AtomicReference</strong>等。</li>
<li>**可见性：**每个线程都有自己的工作内存，所以当某个线程修改完某个变量之后，在其他的线程中，未必能观察到该变量已经被修改。**在 Java 中 volatile、synchronized 和 final 实现可见性。**volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。</li>
<li>**有序性：**java的有序性跟线程相关。一个线程内部所有操作都是有序的，如果是多个线程所有操作都是无序的。因为JMM的工作内存和主内存之间存在延迟，而且java会对一些指令进行重新排序。volatile和synchronized可以保证程序的有序性，volatile和synchronized能保证指令不进行重排序。<ul>
<li>volatile关键字本身就包含了禁止指令重排序的语义</li>
<li>synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li>
<li><strong>指令重排</strong>: 多线程环境中线程交替执行,由于编译器优化重排的存在,;两个线程中使用的变量能否保证–致性是无法确定的，结果无法预测</li>
</ul>
</li>
</ul>
<h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p>Java 内存模型（Java Memory Model，JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则。它主要涉及到多线程环境下的共享变量可见性、指令重排等问题，是理解并发编程中的关键概念。</p>
<p>并发编程的线程之间存在两个问题：</p>
<ul>
<li>线程间如何通信？即：线程之间以何种机制来交换信息</li>
<li>线程间如何同步？即：线程以何种机制来控制不同线程间发生的相对顺序</li>
</ul>
<p>有两种并发模型可以解决这两个问题：</p>
<ul>
<li>消息传递并发模型</li>
<li>共享内存并发模型</li>
</ul>
<p>这两种模型之间的区别如下图所示：</p>
<p><img src="/./../img/jmm-a610752d-ef73-47f2-b02c-6954eb3d62bf.png" srcset="/img/loading.gif" lazyload alt="两种并发模型的比较">两种并发模型的比较</p>
<p><strong>Java 使用的是共享内存并发模型</strong>。</p>
<p>Java 线程之间的通信由 Java 内存模型（简称 JMM）控制，从抽象的角度来说，JMM 定义了线程和主存之间的抽象关系。</p>
<ol>
<li>所有的共享变量都存在主存中。</li>
<li>每个线程都保存了一份该线程使用到的共享变量的副本。</li>
<li>如果线程 A 与线程 B 之间要通信的话，必须经历下面 2 个步骤：<ol>
<li>线程 A 将本地内存 A 中更新过的共享变量刷新到主存中去。</li>
<li>线程 B 到主存中去读取线程 A 之前已经更新过的共享变量。</li>
</ol>
</li>
</ol>
<p><strong>所以，线程 A 无法直接访问线程 B 的工作内存，线程间通信必须经过主存。</strong></p>
<p>注意，根据 JMM 的规定，<strong>线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主存中读取</strong>。</p>
<h2 id="回答话术"><a href="#回答话术" class="headerlink" title="回答话术"></a>回答话术</h2><p>Java 内存模型 (JMM) 是一个抽象的概念模型，它规定了线程如何通过主内存进行交互。而具体的“工作内存”与“主内存”之间的数据同步，其底层是依赖于硬件（CPU）的缓存一致性协议来完成的，其中最著名的是 MESI 协议</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JMM</span><br><span class="hljs-keyword"></span>		了解: 在cpu与内存之间 存在 一个缓冲区 目的是为了匹配二者之间运行速度不一致的问题<br>		<span class="hljs-keyword">JMM是什么: </span><span class="hljs-keyword">java </span>memory model<br>			它规定了线程如何通过主内存进行交互 线程安全问题<br>			<span class="hljs-keyword">JMM是JVM中对于线程安全保障的一种规范(接口)</span><br><span class="hljs-keyword"></span>		<span class="hljs-keyword">JMM为什么-底层原理</span><br><span class="hljs-keyword"></span>			<span class="hljs-keyword">JMM保证三大特性 </span><br>				原子性:通过<span class="hljs-keyword">synchronized和Lock保证 </span>多线程并发操作不可分割<br>				可见性 MESI协议 基于硬件的一个一致性协议 主内存与线程的工作内存之间的一致性<br>				有序性 内存屏障 可以通过<span class="hljs-keyword">synchronize和volatile来实现禁止指令重排</span><br><span class="hljs-keyword"></span>		<span class="hljs-keyword">JMM如何使用(实现类)</span><br><span class="hljs-keyword"></span>			<span class="hljs-keyword">synchronized</span><br><span class="hljs-keyword"></span>			Lock<br>			volatile 中文翻译: 不稳定的<br></code></pre></td></tr></table></figure>

<h3 id="什么是共享变量？"><a href="#什么是共享变量？" class="headerlink" title="什么是共享变量？"></a>什么是共享变量？</h3><p>对于每一个线程来说，栈都是私有的，而堆是共有的。</p>
<p>也就是说，在栈中的变量（局部变量、方法定义的参数、异常处理的参数）不会在线程之间共享，也就不会有内存可见性的问题，也不受内存模型的影响。而在堆中的变量是共享的，一般称之为共享变量。</p>
<p>所以，内存可见性]针对的是<strong>堆中的共享变量</strong>。</p>
<h3 id="如何保证内存可见性？"><a href="#如何保证内存可见性？" class="headerlink" title="如何保证内存可见性？"></a>如何保证内存可见性？</h3><p>那么怎么知道这个共享变量的被其他线程更新了呢？这就是 JMM 的功劳了，也是 JMM 存在的必要性之一。<strong>JMM 通过控制主存与每个线程的本地内存之间的交互，来提供内存可见性保证</strong>。</p>
<p>Java 中的 <a target="_blank" rel="noopener" href="https://javabetter.cn/thread/volatile.html">volatile 关键字</a>可以保证多线程操作共享变量的可见性以及禁止指令重排序，<a target="_blank" rel="noopener" href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>不仅保证可见性，同时也保证了原子性（互斥性）。</p>
<p>在更底层，JMM 通过内存屏障来实现内存的可见性以及禁止重排序。为了程序员更方便地理解，设计者提出了 happens-before 的概念（下文会细讲），它更加简单易懂，从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则，以及这些规则的具体实现方法。</p>
<h3 id="JMM-与-Java-运行时内存区域的区别"><a href="#JMM-与-Java-运行时内存区域的区别" class="headerlink" title="JMM 与 Java 运行时内存区域的区别"></a>JMM 与 Java 运行时内存区域的区别</h3><ul>
<li><p>区别</p>
<p>两者是不同的概念。JMM 是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开。而 Java 运行时内存的划分是具体的，是 JVM 运行 Java 程序时必要的内存划分。</p>
</li>
<li><p>联系</p>
<p>都存在私有数据区域和共享数据区域。一般来说，JMM 中的主存属于共享数据区域，包含了堆和方法区；同样，JMM 中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。</p>
</li>
</ul>
<h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><ul>
<li>指令重排是为了提高 CPU 性能，但是可能会导致一些问题，比如多线程环境下的内存可见性问题。</li>
</ul>
<p>指令重排一般分为以下三种：</p>
<ul>
<li><strong>编译器优化重排</strong></li>
<li><strong>指令并行重排</strong></li>
<li><strong>内存系统重排</strong></li>
</ul>
<p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p>
<h2 id="happensbefore"><a href="#happensbefore" class="headerlink" title="happensbefore"></a>happensbefore</h2><p>happens-before 规则是 JMM 提供的强大的内存可见性保证，只要遵循 happens-before 规则，那么我们写的程序就能保证在 JMM 中具有强的内存可见性。</p>
<p>总之，<strong>如果操作 A happens-before 操作 B，那么操作 A 在内存上所做的操作对操作 B 都是可见的，不管它们在不在一个线程。</strong></p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><pre><code class="hljs">volatile 不稳定的
	volatile是什么
		JMM规范的一种实现 即是一种轻量级的同步机制 所谓轻量的一种理解就是不保证原子性
		只保证有序性和可见性
	volatile为什么(原理)
		可见性 MESI协议 基于硬件的一个一致性协议 主内存与线程的工作内存之间的一致性
		有序性 内存屏障 可以通过synchronize和volatile来实现禁止指令重排
	volatile怎么用
		volatile 只能修饰变量 不能修饰方法
		需要注意的是synchronized 不能修饰变量 它可以修饰方法和代码块
		为了解决volatile不保证原子性的缺陷,可以使用原子类 原子类的底层是CAS
</code></pre>
<h2 id="volatile-会禁止指令重排"><a href="#volatile-会禁止指令重排" class="headerlink" title="[volatile 会禁止指令重排]"></a>[volatile 会禁止指令重排]</h2><p>当我们使用 volatile 关键字来修饰一个变量时，Java 内存模型会插入内存屏障（一个处理器指令，可以对 CPU 或编译器重排序做出约束）来确保以下两点：</p>
<ul>
<li><p>写屏障（Write Barrier）：当一个 volatile 变量被写入时，写屏障确保在该屏障之前的所有变量的写入操作都提交到主内存。</p>
</li>
<li><p>读屏障（Read Barrier）：当读取一个 volatile 变量时，读屏障确保在该屏障之后的所有读操作都从主内存中读取。volatile 可以保证</p>
<p>线程可见性且提供了一定的有序性，但是无法保证原子性。</p>
<p>在 JVM 底层 volatile 是采用“内存屏障”来实现的。</p>
<p>观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码就能发现，加入 volatile 关键字时，会多出一个 lock 前缀指令，lock 前缀指令实际上相当于一个内存屏障（也称内存栅栏），内存屏障会提供 3 个功能：</p>
<ul>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他 CPU 中对应的缓存行无效。</li>
</ul>
</li>
</ul>
<h2 id="Volatile和synchronized区别"><a href="#Volatile和synchronized区别" class="headerlink" title="Volatile和synchronized区别"></a>Volatile和synchronized区别</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>volatile</code></th>
<th align="left"><code>synchronized</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left">变量访问修饰符</td>
<td align="left">方法或代码块修饰符</td>
</tr>
<tr>
<td align="left"><strong>原子性</strong></td>
<td align="left"><strong>不保证</strong>原子性（对单个读&#x2F;写是原子的，但复合操作如i++不是）</td>
<td align="left"><strong>保证</strong>原子性，整个同步块是一个不可分割的原子操作</td>
</tr>
<tr>
<td align="left"><strong>可见性</strong></td>
<td align="left"><strong>保证</strong>可见性</td>
<td align="left"><strong>保证</strong>可见性</td>
</tr>
<tr>
<td align="left"><strong>有序性</strong></td>
<td align="left"><strong>保证</strong>有序性（禁止指令重排序）</td>
<td align="left"><strong>保证</strong>有序性（一个unlock操作先于后面对同一个锁的lock操作）</td>
</tr>
<tr>
<td align="left"><strong>线程阻塞</strong></td>
<td align="left"><strong>不会</strong>引起线程阻塞</td>
<td align="left"><strong>会</strong>引起线程阻塞（互斥同步，是悲观锁）</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">单一变量的可见性、状态标志</td>
<td align="left">多行代码的复合操作，需要保证原子性</td>
</tr>
</tbody></table>
<h1 id="隐式锁-synchronized"><a href="#隐式锁-synchronized" class="headerlink" title="隐式锁(synchronized)"></a>隐式锁(synchronized)</h1><p>java中的锁包含了内部锁和显示锁。内部锁是通过synchronized关键字实现的 ;显示锁是通过Lock接口来进行实现。</p>
<p><strong>synchronized概述</strong></p>
<p>特点：</p>
<p>1、synchronized关键字可以用来修饰方法(静态和非静态)和代码块。</p>
<p>2、被synchronized修饰的方法被称之为同步方法，被synchronized修饰的代码块被称之同步代码块。</p>
<p>3、同步方法整个方法体都是临界区。同步代码块中所包裹的代码是临界区。</p>
<p><strong>同步代码块的格式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (对象) &#123;<br>    <br>    <span class="hljs-comment">// 在此代码块中访问共享数据</span><br>&#125;<br><br>该对象可以是任意的对象，这个对象可以简单的理解就是一把锁：但是需要保证多个线程在访问的时候使用的是同一个对象(但是这个对象本质上不是一个锁，专业的术语将其称之为<span class="hljs-string">&quot;监视器&quot;</span>(摄像头))<br></code></pre></td></tr></table></figure>

<h2 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a><strong>synchronized原理</strong></h2><p><strong>synchronized同步代码块的情况</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;synchronized&quot;</span>);<br>        &#125;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过javap查看字节码文件信息，如下所示：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">javap -c SynchronizedDemo.class<br></code></pre></td></tr></table></figure>

<p>Java虚拟机包含了一个很实用的命令javap，该命令可以反编译已经编译过的Java Class文件，输出该类文件的详细信息。-c，该选项可以输出类中的所有方法以及字节码信息</p>
<p>其中:  monitor就是监视器的含义</p>
<p><img src="/./../img/image-20251112220823274.png" srcset="/img/loading.gif" lazyload alt="image-20251112220823274"></p>
<p>在字节码层面由 <code>monitorenter</code> &#x2F; <code>monitorexit</code> 指令实现。Javac 会生成一个保护区域（try&#x2F;finally 风格）的结构：正常路径在结束时 <code>monitorexit</code>，异常路径通过异常处理器也会执行 <code>monitorexit</code>，保证锁总是释放，随后重新抛出异常。当执行 <code>monitorenter</code>指令时，线程试图获取锁也就是获取 <code>monitor</code>(monitor对象存在于每个Java对象的<strong>对象头</strong>中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。</p>
<h2 id="sync到底锁什么？四种锁？"><a href="#sync到底锁什么？四种锁？" class="headerlink" title="sync到底锁什么？四种锁？"></a>sync到底锁什么？四种锁？</h2><p>在 JDK 1.6 以前，所有的锁都是”重量级“锁，因为使用的是操作系统的互斥锁，当一个线程持有锁时，其他试图进入synchronized块的线程将被阻塞，直到锁被释放。涉及到了线程上下文切换和用户态与内核态的切换，因此效率较低。</p>
<p>这也是为什么很多开发者会认为 synchronized 性能很差的原因。</p>
<p>那为了减少获得锁和释放锁带来的性能消耗，JDK 1.6 引入了“偏向锁”和“轻量级锁” 的概念，对 synchronized 做了一次重大的升级，升级后的 synchronized 性能可以说上了一个新台阶。</p>
<p>在 JDK 1.6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：</p>
<ol>
<li>无锁状态</li>
<li>偏向锁状态（15关闭，18废弃）<strong>性能收益不明显；JVM 内部代码维护成本太高</strong></li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ol>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗 CPU。</td>
<td>追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗 CPU。</td>
<td>线程阻塞，响应时间缓慢。</td>
<td>追求吞吐量。同步块执行时间较长。</td>
</tr>
</tbody></table>
<h3 id="锁什么"><a href="#锁什么" class="headerlink" title="锁什么"></a>锁什么</h3><p>对象的“锁”是存放在每个 Java 对象都有一个对象头。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>一个线程在第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID。当下次该线程进入这个同步块时，会去检查锁的 Mark Word 里面是不是放的自己的线程 ID。</p>
<p>如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费 CAS 操作来加锁和解锁；如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，这个时候要分两种情况：</p>
<ul>
<li><p>成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；</p>
</li>
<li><p>失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为 0，并设置锁标志位为 00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</p>
<h4 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h4><p>偏向锁使用了一种<strong>等到竞争出现才释放锁的机制</strong>，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p>
<p>偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：</p>
<ol>
<li>在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。</li>
<li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和 Mark Word，使其变成无锁状态。</li>
<li>唤醒被停止的线程，将当前锁升级成轻量级锁。</li>
</ol>
</li>
</ul>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>JVM 会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为 Displaced Mark Word。如果一个线程获得锁的时候发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word 里面。</p>
<p>然后线程尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示 Mark Word 已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</p>
<blockquote>
<p>自旋：不断尝试去获取锁，一般用循环来实现。</p>
</blockquote>
<p>JDK 采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p>
<p>自旋也不是一直进行下去的，如果自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。同时这个锁就会<strong>升级成重量级锁</strong>。</p>
<p>在释放锁时，当前线程会使用 CAS 操作将 Displaced Mark Word 的内容复制回锁的 Mark Word 里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么 CAS 操作会失败，此时会释放锁并唤醒被阻塞的线程。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁依赖于操作系统的互斥锁（mutex，用于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段） 实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU。</p>
<h2 id="锁的升级流程"><a href="#锁的升级流程" class="headerlink" title="锁的升级流程"></a>锁的升级流程</h2><p>每一个线程在准备获取共享资源时： </p>
<p>第一步，检查 MarkWord 里面是不是放的自己的 ThreadId ,如果是，表示当前线程是处于 “偏向锁” </p>
<p>第二步，如果 MarkWord 不是自己的 ThreadId，锁升级，这时候，用 CAS 来执行切换，新的线程根据 MarkWord 里面现有的 ThreadId，通知之前线程暂停，之前线程将 Markword 的内容置为空。</p>
<p>第三步，两个线程都把锁对象的 HashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarKword 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord。</p>
<p>第四步，第三步中成功执行 CAS 的获得资源，失败的则进入自旋 。</p>
<p>第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 。</p>
<p>第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</p>
<h2 id="ReentrantLock-和-synchronized-区别"><a href="#ReentrantLock-和-synchronized-区别" class="headerlink" title="ReentrantLock 和 synchronized 区别"></a>ReentrantLock 和 synchronized 区别</h2><p>（1）synchronized是独占锁，加锁和解锁的过程自动进行，易于操作，但不够灵活。ReentrantLock也是独占锁，加锁和解锁的过程需要手动进行，不易操作，但非常灵活。</p>
<p>（2）synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。</p>
<p>（3）synchronized不可响应中断，一个线程获取不到锁就一直等着；ReentrantLock可以响应中断。</p>
<p>（4）synchronized:Java中的关键字，是由JVM来维护的。是JVM层面的锁。</p>
<p>Lock：是JDK5以后才出现的具体的类。使用lock是调用对应的API。是API层面的锁。</p>
<p>synchronized是底层是通过monitorenter进行加锁（底层是通过monitor对象来完成的，其中的wait&#x2F;notify等方法也是依赖于monitor对象的。只有在同步块或者是同步方法中才可以调用wait&#x2F;notify等方法的。因为只有在同步块或者是同步方法中，JVM才会调用monitory对象的）；通过monitorexit来退出锁的。</p>
<p>而lock是通过调用对应的API方法来获取锁和释放锁的。</p>
<p>（5）synchronized;非公平锁</p>
<p>lock：两者都可以的。默认是非公平锁。在其构造方法的时候可以传入Boolean值。</p>
<p>true：公平锁</p>
<p>false：非公平锁</p>
<h1 id="显式锁-Lock"><a href="#显式锁-Lock" class="headerlink" title="显式锁(Lock)"></a>显式锁(Lock)</h1><p>相比同步锁，JUC包中的Lock锁的功能更加强大，它提供了各种各样的锁（公平锁，非公平锁，共享锁，独占锁……），所以使用起来很灵活。</p>
<blockquote>
<p>锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。</p>
</blockquote>
<p>end?</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/JUC/" class="print-no-link">#JUC</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JUC</div>
      <div>http://example.com/2025/11/13/00JUC(线程-sync)/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>無鎏雲</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年11月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/09/15/leetcode-%E5%9B%9E%E6%BA%AF%E7%9A%84j-%E5%92%8Cj-1%E5%92%8C-j/" title="leetcode:回溯的j--和j-1和--j">
                        <span class="hidden-mobile">leetcode:回溯的j--和j-1和--j</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
