

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="無鎏雲">
  <meta name="keywords" content="">
  
    <meta name="description" content="堆堆、栈、方法区的关系：  HotSpot是使用指针的方式来访问对象： Java堆中会存放指向类元数据的地址 堆空间概述Java栈中的reference存储的是指向堆中的对象的地址  一个Java程序运行起来对应一个进程，一个进程对应一个JVM实例，一个JVM实例中有一个运行时数据区，一个运行时数据区中只存在一个堆内存和一个方法区。  一个进程中可以包含多个线程，因此堆内存和方法区是线程共享的。堆">
<meta property="og:type" content="article">
<meta property="og:title" content="11堆">
<meta property="og:url" content="http://example.com/2025/11/14/11%E5%A0%86/index.html">
<meta property="og:site_name" content="NoFlowCloud">
<meta property="og:description" content="堆堆、栈、方法区的关系：  HotSpot是使用指针的方式来访问对象： Java堆中会存放指向类元数据的地址 堆空间概述Java栈中的reference存储的是指向堆中的对象的地址  一个Java程序运行起来对应一个进程，一个进程对应一个JVM实例，一个JVM实例中有一个运行时数据区，一个运行时数据区中只存在一个堆内存和一个方法区。  一个进程中可以包含多个线程，因此堆内存和方法区是线程共享的。堆">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/pqmd75qtz-_a66lc6uWYi-1763121941242-1.png">
<meta property="og:image" content="http://example.com/img/neicun-jiegou-20231225154450.png">
<meta property="og:image" content="http://example.com/img/what-is-jvm-20231223155202.png">
<meta property="og:image" content="http://example.com/img/neicun-jiegou-20240110195211.png">
<meta property="og:image" content="http://example.com/img/image-20251114202938085.png">
<meta property="og:image" content="http://example.com/img/2knl9vfp81_hoQSSZ5fLP.gif">
<meta property="og:image" content="http://example.com/img/-n83l7j40p_9u1Vtn0PUf.gif">
<meta property="og:image" content="http://example.com/img/gt802yy-r1_V6nc6kONPH.gif">
<meta property="og:image" content="http://example.com/img/ei8pop8k1q_GLa6wPJHmS.png">
<meta property="article:published_time" content="2025-11-14T05:07:57.000Z">
<meta property="article:modified_time" content="2025-11-15T12:40:03.259Z">
<meta property="article:author" content="無鎏雲">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/pqmd75qtz-_a66lc6uWYi-1763121941242-1.png">
  
  
  
  <title>11堆 - NoFlowCloud</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Noflowcloud-Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="11堆"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-11-14 13:07" pubdate>
          2025年11月14日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          56 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">11堆</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p><strong>堆、栈、方法区的关系：</strong></p>
<p><img src="/./../img/pqmd75qtz-_a66lc6uWYi-1763121941242-1.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>HotSpot</strong>是使用指针的方式来访问对象：</p>
<p>Java堆中会存放指向<code>类元数据</code>的地址</p>
<h1 id="堆空间概述"><a href="#堆空间概述" class="headerlink" title="堆空间概述"></a>堆空间概述</h1><p>Java栈中的reference存储的是指向堆中的对象的地址</p>
<ul>
<li><p>一个Java程序运行起来对应一个进程，一个进程对应一个JVM实例，一个JVM实例中有一个运行时数据区，一个运行时数据区中只存在一个堆内存和一个方法区。</p>
</li>
<li><p>一个进程中可以包含多个线程，因此堆内存和方法区是线程共享的。堆中还有一小部分空间，是每个线程独有的，叫做线程私有缓冲区（Thread Local Allocation Buffer，TLAB），解决程序运行时的数据安全问题。</p>
</li>
<li><p>一个线程各自拥有一套Java栈、本地方法栈和程序计数器。</p>
</li>
<li><p>一个进程拥有自己一套jvm； </p>
<ul>
<li>user-service.jar</li>
<li>hispital-service.jar</li>
<li>。。。。</li>
<li><code>java -jar xxx.jar</code>： 启动一个进程。 一个进程分配很多线程。</li>
</ul>
</li>
<li><p>堆是Java内存管理的<strong>核心区域</strong>，在<code>JVM启动的时候被创建</code>，堆内存的大小是可以调节的。当创建一个引用类型的对象时，JVM会为对象在堆中分配一个内存空间。堆是垃<code>圾回收的重点区域</code>。</p>
</li>
<li><p>口诀：</p>
<ul>
<li>频繁收集年轻代，少量收集老年代，基本不动永久代（方法区）</li>
</ul>
</li>
</ul>
<h2 id="堆和对象"><a href="#堆和对象" class="headerlink" title="堆和对象"></a>堆和对象</h2><p>以前，Java 中“几乎”所有的对象都会在堆中分配，但随着 <a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/jit.html">JIT</a> 编译器的发展和逃逸技术的逐渐成熟，所有的对象都分配到堆上渐渐变得不那么“绝对”了。从 JDK 7 开始，Java 虚拟机已经默认开启逃逸分析了，</p>
<p><strong>意味着如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p>
<p><img src="/./../img/neicun-jiegou-20231225154450.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>栈就是前面提到的 JVM 栈（主要存储局部变量、方法参数、对象引用等），属于线程私有，通常随着方法调用的结束而消失，也就无需进行垃圾收集；堆前面也讲了，属于线程共享的内存区域，几乎所有的对象都在对上分配，生命周期不由单个方法调用所决定，可以在方法调用结束后继续存在，直到不在被任何变量引用，然后被垃圾收集器回收。</p>
<p>简单解释一下 JIT 和逃逸分析（后面讲 <a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/jit.html">JIT</a> 会细讲）。</p>
<p>常见的编译型语言如 C++，通常会把代码直接编译成 CPU 所能理解的机器码来运行。而 Java 为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由 javac 编译成通用的中间形式——字节码，然后再由解释器逐条将字节码解释为机器码来执行。所以在性能上，Java 可能会干不过 C++ 这类编译型语言。</p>
<p><img src="/./../img/what-is-jvm-20231223155202.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>为了优化 Java 的性能 ，JVM 在解释器之外引入了 JIT 编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。</p>
<p>逃逸分析（Escape Analysis）是一种编译器优化技术，用于判断对象的作用域和生命周期。如果编译器确定一个对象不会逃逸出方法或线程的范围，它可以选择在栈上分配这个对象，而不是在堆上。这样做可以减少垃圾回收的压力，并提高性能。</p>
<h1 id="元空间和方法区"><a href="#元空间和方法区" class="headerlink" title="元空间和方法区"></a>元空间和方法区</h1><p>方法区是 Java 虚拟机规范上的一个逻辑区域，在不同的 JDK 版本上有着不同的实现。在 JDK 7 的时候，方法区被称为永久代（PermGen），而在 JDK 8 的时候，永久代被彻底移除，取而代之的是元空间。</p>
<p><img src="/./../img/neicun-jiegou-20240110195211.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>JDK 7 之前，只有常量池的概念，都在方法区中。</p>
<p>JDK 7 的时候，字符串常量池从方法区中拿出来放到了堆中，运行时常量池还在方法区中（也就是永久代中）。</p>
<p>JDK 8 的时候，HotSpot 移除了永久代，取而代之的是元空间。字符串常量池还在堆中，而运行时常量池跑到了元空间。</p>
<p>元空间的大小不再受限于 JVM 启动时设置的最大堆大小，而是直接利用本地内存，也就是操作系统的内存。有效地解决了 OutOfMemoryError 错误。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>在讲字节码的时候，我们详细的讲过常量池，它是字节码文件的资源仓库，先是一个常量池大小，从 1 到 n-1，0 为保留索引，然后是常量池项的集合，包括类信息、字段信息、方法信息、接口信息、字符串常量等。</p>
<p>运行时常量池，顾名思义，就是在运行时期间，JVM 会将字节码文件中的常量池加载到内存中，存放在运行时常量池中。</p>
<p>也就是说，常量池是在字节码文件中，而运行时常量池在元空间当中（JDK 8 及以后），讲的是一个东西，但形态不一样，就好像一个是固态，一个是液态；或者一个是模子，一个是模子里的锅碗瓢盆。</p>
<p><strong>字符串常量池</strong>：</p>
<ul>
<li>在JDK 7及之后的版本中，字符串常量池被移动到了<strong>堆内存</strong>中（Heap）</li>
<li>JDK 7之前，字符串常量池位于永久代（PermGen）</li>
</ul>
<p><strong>运行时常量池</strong>：</p>
<ul>
<li>运行时常量池属于<strong>方法区</strong>（Method Area）</li>
<li>在JDK 8及之后，方法区由<strong>元空间</strong>（Metaspace）实现</li>
<li>元空间使用的是<strong>本地内存</strong>（直接从操作系统申请），而不是堆内存</li>
</ul>
<p>具体来说：</p>
<ul>
<li>JDK 7：字符串常量池移到堆中，运行时常量池仍在方法区（永久代）</li>
<li>JDK 8及之后：永久代被彻底移除，改用元空间（Metaspace）作为方法区的实现，运行时常量池在元空间中，而字符串常量池仍在堆中</li>
</ul>
<p>所以，当前（JDK 8+）环境下，字符串常量池确实在堆里面，而运行时常量池在方法区（具体实现为元空间，使用本地内存，不是堆内存）。</p>
<p>这是JDK 7版本的重要改进，将字符串常量池从永久代移到堆中，是为了让字符串常量池能更好地参与垃圾回收，避免永久代内存不足导致的OOM问题。</p>
<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>字符串常量池我们在讲字符串的时候已经详细讲过了，它的作用是存放字符串常量，也就是我们在代码中写的字符串。依然在堆中。</p>
<p>OK，方法区（不管是永久代还是元空间的实现）和堆一样，是线程共享的区域。</p>
<h1 id="运行时数据区的主要组成"><a href="#运行时数据区的主要组成" class="headerlink" title="运行时数据区的主要组成"></a>运行时数据区的主要组成</h1><p>来总结一下运行时数据区的主要组成：</p>
<p>PC 寄存器（PC Register），也叫程序计数器（Program Counter Register），是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器。</p>
<p>JVM 栈（Java Virtual Machine Stack），与 PC 寄存器一样，JVM 栈也是线程私有的。每一个 JVM 线程都有自己的 JVM 栈（也叫方法栈），这个栈与线程同时创建，它的生命周期与线程相同。</p>
<p>本地方法栈（Native Method Stack），JVM 可能会使用到传统的栈来支持 Native 方法的执行，这个栈就是本地方法栈。</p>
<p>堆（Heap），在 JVM 中，堆是可供各条线程共享的运行时内存区域，也是供所有类实例和数据对象分配内存的区域。</p>
<p>方法区（Method area），JDK 8 开始，使用元空间取代了永久代。方法区是 JVM 中的一个逻辑区域，用于存储类的结构信息，包括类的定义、方法的定义、字段的定义以及字节码指令。不同的是，元空间不再是 JVM 内存的一部分，而是通过本地内存（Native Memory）来实现的。</p>
<p>在 JVM 启动时，元空间的大小由 MaxMetaspaceSize 参数指定，JVM 在运行时会自动调整元空间的大小，以适应不同的程序需求。</p>
<h1 id="堆的分代"><a href="#堆的分代" class="headerlink" title="堆的分代"></a>堆的分代</h1><p><img src="/./../img/image-20251114202938085.png" srcset="/img/loading.gif" lazyload alt="image-20251114202938085"></p>
<h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p><strong>内存结构：</strong></p>
<ul>
<li><p>新生代又分为两部分： <code>伊甸园区（Eden space）和幸存者区（Survivor pace）</code> 。</p>
</li>
<li><p>幸存者区有两个： <code>0区（Survivor 0 space）和1区（Survivor 1 space）</code>。</p>
</li>
</ul>
<p><strong>工作过程：</strong></p>
<p>（1）新创建的对象先放在伊甸园区。</p>
<p>（2）当伊甸园的空间用完时，程序又需要创建新对象，此时，触发JVM的垃圾回收器对<code>伊甸园区进行垃圾回收``（Minor GC/Young GC）</code>，将伊甸园区中不再被引用的对象销毁。（GC 伊甸园+某个幸存者区）</p>
<p>（3）然后将伊甸园区的剩余对象<code>移动到空的幸存0区</code>。</p>
<p>（4）此时，<code>伊甸园区清空</code>。</p>
<p>（5）被移到幸存者0区的对象上有一个<code>年龄计数器，值是1</code>。</p>
<p>（6）然后再次将新对象放入伊甸园区。</p>
<p>（7）如果伊甸园区的空间再次用完，则<code>再次触发垃圾回收</code>，<code>对伊甸园区和s0区进行垃圾回收</code>，销毁不再引用的对象。</p>
<p>（8）此时s1区为空，然后将伊甸园区和s0区的剩余对象<code>移动到空的s1区</code>。</p>
<p>（9）此时，<code>伊甸园区和s0区清空</code>。</p>
<p>（10）从伊甸园区被移到s1区的对象上有一个<code>年龄计数器，值是1</code>。从s0区被移到s1区的对象上的<code>年龄计数器+1</code>，值是2。</p>
<p>（11）然后再次将新对象放入伊甸园区。如果<code>再次经历垃圾回收</code>，那么伊甸园区和s1区的剩余对象<code>移动到s0区</code>。对象上的年龄计数器+1。</p>
<p>（12）当对象上的<strong>年龄计数器</strong>达到<strong>15</strong>时（<strong>-XX:MaxTenuringThreshold</strong>），则晋升到老年代。</p>
<p><strong>总结：</strong> 针对幸存者s0，s1，复制（复制算法）之后有交换，谁空谁是<code>to</code></p>
<p>每次垃圾回收后，幸存者区都有一个会被清空，此时这个区域称为<code>to区</code>，另一个区域被称为<code>from区</code>，下一次垃圾回收时，<code>伊甸园区和from区对象会被移动到to区</code></p>
<h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>经历多次<code>Minor GC</code>仍然存在的对象（默认是15次）会被移入老年代，老年代的对象比较稳定，不会频繁的GC。</p>
<p>若老年代也满了，那么这个时候将产生<code>Major GC（同时触发Full GC）</code>，进行老年代的垃圾回收。</p>
<p>若老年代执行了Full GC之后发现依然无法进行对象的保存，就会<code>产生OOM异常OutOfMemoryError</code>。</p>
<h2 id="永久代-元空间"><a href="#永久代-元空间" class="headerlink" title="永久代&#x2F;元空间"></a>永久代&#x2F;元空间</h2><p><strong>JDK1.7</strong></p>
<ul>
<li><p><code>-XX:PermSize：</code>设置永久代初始分配空间，默认值是20.75M。</p>
</li>
<li><p><code>-XX:MaxPermSize：</code>设置永久代最大可分配空间，32位机器默认值是64M，64位机器默认82M。</p>
</li>
</ul>
<p><strong>JDK1.8</strong></p>
<ul>
<li><p><code>-XX:MetaspaceSize：</code>设置元空间初始分配空间，64位系统，默认值是21M。</p>
</li>
<li><p><code>-XX:MaxMetaspaceSize：</code>设置元空间最大可分配空间，，默认是-1。</p>
</li>
</ul>
<p>永久代是一个常驻内存区域，用于存放JDK自身所携带的 Class，Interface 的元数据，也就是说它存储的是运行环境必须的类信息，<code>被装载进此区域的数据是不会被垃圾回收器回收掉的</code>，<code>关闭 JVM 才会释放此区域所占用的内存</code>。</p>
<p>如果出现<code>java.lang.OutOfMemoryError: </code><strong>PermGen space</strong>，说明是Java虚拟机对<code>永久代内存设置不够</code>。一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。</p>
<p>尽管方法区在逻辑上属于堆的一部分，<strong>对于HotSpotJVM而言，方法区还有一个别名叫做<code>Non-Heap(非堆)</code>，目的就是要和堆分开。</strong></p>
<p>对<code>于HotSpot虚拟机</code>，很多开发者<code>习惯将方法区称之为永久代</code> ，但严格说两者不同，或者说是使用永久代来实现方法区而已。</p>
<h2 id="常用命令行（了解）"><a href="#常用命令行（了解）" class="headerlink" title="常用命令行（了解）"></a>常用命令行（了解）</h2><p>查看java进程：<code>jps -l</code></p>
<p>查看某个java进程所有参数：<code>jinfo 进程号</code></p>
<p>查看某个java进程总结性垃圾回收统计：<code>jstat -gc 进程号</code></p>
<h1 id="Java的垃圾回收"><a href="#Java的垃圾回收" class="headerlink" title="Java的垃圾回收"></a>Java的垃圾回收</h1><h2 id="什么是GC"><a href="#什么是GC" class="headerlink" title="什么是GC"></a>什么是GC</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是</p>
<p>GC： <strong>堆</strong> 内存中对象的分配与回收。</p>
<p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p>
<p>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p>
<h3 id="GC种类"><a href="#GC种类" class="headerlink" title="GC种类"></a>GC种类</h3><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>
<h2 id="GC种类总结："><a href="#GC种类总结：" class="headerlink" title="GC种类总结："></a>GC种类总结：</h2><p><strong>部分收集：</strong></p>
<ul>
<li>年轻代收集（Minor GC  &#x2F;  Young GC）：新生代垃圾收集（伊甸园区 + 幸存者区）</li>
<li>老年代收集（Major GC &#x2F; Old GC）：老年代垃圾收集</li>
<li>Full GC &#x3D; Minor + Major </li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代。<code>G1垃圾收集器有这种方式</code></li>
</ul>
<p><strong>整堆收集（Full GC）：</strong></p>
<ul>
<li>整个<code>Java堆</code>和<code>方法区</code>的垃圾收集</li>
</ul>
<p><strong>年轻代GC触发机制（Minor GC ）：</strong></p>
<p>年轻代的Eden空间不足，触发Minor GC。</p>
<p>每次Minor GC在清理Eden的同时会清理Survivor From区。</p>
<p><code>Minor GC非常频繁</code>，<code>回收速度块</code>。</p>
<p>引发<code>STW（Stop The World）</code>，暂停其他用户线程，垃圾回收结束，用户线程恢复。</p>
<p><strong>老年代GC触发机制（Major GC 和 Full GC）：</strong></p>
<p>老年代满了，对象从老年代消失是因为发生了Major GC和Full GC。</p>
<p>Major GC比Minor GC速度慢10倍以上，<strong>STW时间更长</strong>。</p>
<p>如果Major GC后，内存还不足，就报OOM。</p>
<p><strong>Full GC触发机制：</strong></p>
<p>（1）调用System.gc()，系统建议执行Full GC，但是不是必然执行。</p>
<p>（2）老年代空间不足</p>
<p>（3）方法区空间不足</p>
<p>（4）通过Minor GC后进入老年代平均大小大于老年代可用内存</p>
<ul>
<li><p>频繁在新生代收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="center">Minor GC</th>
<th align="center">Major GC</th>
<th align="center">Full GC</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>作用区域</strong></td>
<td align="center">仅年轻代 (Young Gen)</td>
<td align="center">仅老年代 (Old Gen)</td>
<td align="center"><strong>整个堆</strong> (Young + Old + Metaspace)</td>
</tr>
<tr>
<td align="left"><strong>触发频率</strong></td>
<td align="center"><strong>高</strong></td>
<td align="center"><strong>低</strong></td>
<td align="center"><strong>非常低</strong> (应尽量避免)</td>
</tr>
<tr>
<td align="left"><strong>执行速度</strong></td>
<td align="center"><strong>快</strong></td>
<td align="center"><strong>慢</strong></td>
<td align="center"><strong>非常慢</strong></td>
</tr>
<tr>
<td align="left"><strong>STW停顿</strong></td>
<td align="center">短，通常可忽略</td>
<td align="center">较长，影响明显</td>
<td align="center"><strong>很长，严重影响应用</strong></td>
</tr>
<tr>
<td align="left"><strong>触发原因</strong></td>
<td align="center">Eden区满</td>
<td align="center">老年代满</td>
<td align="center">1. 老年代满 2. 元空间满 3. <code>System.gc()</code> 4. 空间分配担保失败</td>
</tr>
</tbody></table>
<p>为什么要“担保”？</p>
<p>想象一个场景：你要进行Minor GC了。理想情况下，Eden区里大部分对象都是垃圾，被回收掉，只有一小部分存活对象会晋升到老年代。</p>
<p>但<strong>最坏的情况</strong>是：Eden区里几乎<strong>所有对象都存活</strong>了，这次Minor GC后，存活对象的总大小非常大，需要全部晋升到老年代。</p>
<p>“空间分配担保”机制就是为了应对这种最坏情况，<strong>确保老年代有足够的能力“兜底”</strong>，接收所有这些可能晋升上来的对象。如果老年代没能力兜底，冒然进行Minor GC就会导致内存不足的错误。</p>
<p>“允许担保”的含义</p>
<p><code>-XX:-HandlePromotionFailure</code> 这个参数的名字直译是“<strong>是否处理晋升失败</strong>”。</p>
<ul>
<li><strong><code>-XX:+HandlePromotionFailure</code></strong>：<strong>允许</strong>担保（JDK 6 Update 24之后默认即为此状态）。JVM会尝试做担保检查，如果检查失败，就提前进行Full GC来腾空间。</li>
<li><strong><code>-XX:-HandlePromotionFailure</code></strong>：<strong>不允许</strong>担保。JVM直接不做复杂的检查了，只要老年代剩余空间看起来不太够，就干脆地、安全地先进行一次Full GC。</li>
</ul>
<p>这个参数在JDK 6 Update 25之后就<strong>不再有实际作用</strong>了，规则已经固化</p>
</li>
</ul>
<h2 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法"></a>垃圾判断算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>引用计数算法（Reachability Counting）是通过在对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。</p>
<p>如果该对象被其它对象引用，则它的引用计数加 1，如果删除对该对象的引用，那么它的引用计数就减 1，当该对象的引用计数为 0 时，那么该对象就会被回收。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>可达性分析算法（Reachability Analysis）的基本思路是，通过 GC Roots 作为起点，然后向下搜索，当一个对象到 GC Roots 之间没有任何引用相连时，即从 GC Roots 到该对象节点不可达，则证明该对象是需要垃圾收集的。</p>
<h3 id="GCROOTS"><a href="#GCROOTS" class="headerlink" title="GCROOTS"></a>GCROOTS</h3><p>所谓的 GC Roots，就是一组必须活跃的引用，不是对象，它们是程序运行时的起点，是一切引用链的源头。在 Java 中，GC Roots 包括以下几种：</p>
<ul>
<li>虚拟机栈中的引用（方法的参数、局部变量等）</li>
<li>本地方法栈中 JNI （本地方法）的引用</li>
<li>类静态变量</li>
<li>运行时常量池中的常量（String 或 Class 类型）</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a><strong>垃圾回收算法</strong></h2><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收。</p>
<p>在介绍JVM垃圾回收算法前，先介绍一个概念：<strong>Stop-the-World：</strong></p>
<p>Stop-the-world意味着 JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。</p>
<p>当Stop-the-world发生时，除了GC所需的线程以外，<code>所有线程都处于等待状态直到GC任务完成</code>。</p>
<p>事实上，<code>GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有高吞吐 、低停顿的特点。</code></p>
<h3 id="标记清除（Mark-Sweep）"><a href="#标记清除（Mark-Sweep）" class="headerlink" title="标记清除（Mark-Sweep）"></a>标记清除（Mark-Sweep）</h3><p><code>标记-清除算法</code>是几种GC算法中最基础的算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。正如名字一样，算法分为<strong>2个阶段</strong>：</p>
<p>（1）<strong>标记：</strong> 使用<code>可达性分析算法</code>，标记出可达对象。</p>
<p>（2）<strong>清除：</strong> 对堆内存从头到尾进行线性便遍历，如果发现某个对象没有被标记为可达对象，则将其回收。</p>
<p><img src="/./../img/2knl9vfp81_hoQSSZ5fLP.gif" srcset="/img/loading.gif" lazyload></p>
<p><strong>缺点：</strong></p>
<ul>
<li><p>效率问题（两次遍历）</p>
</li>
<li><p>空间问题（标记清除后会产生大量不连续的<strong>碎片</strong>。JVM就不得不维持一个<code>内存的空闲列表</code>，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。）</p>
</li>
</ul>
<h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><p><strong>核心思想：</strong></p>
<p>将活着的内存空间平均分成<strong>两块</strong>，每次只使用其中<strong>一块</strong>，垃圾收集时，将正在使用的内存中的存活对象复制到未被使用的内存块中，然后将之前的<strong>内存块清空</strong>，交换两个内存的角色，循环下去。</p>
<p><img src="/./../img/-n83l7j40p_9u1Vtn0PUf.gif" srcset="/img/loading.gif" lazyload></p>
<p><strong>优点：</strong></p>
<ul>
<li><p><strong>实现简单</strong></p>
</li>
<li><p><strong>不产生内存碎片</strong></p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>将<strong>内存缩小为原来的一半</strong>，浪费了一半的内存空间，代价太高，所以在老年代一般不能直接选用这种算法。</p>
</li>
<li><p>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</p>
</li>
</ul>
<p><strong>年轻代中使用的是Minor GC，这种GC算法采用的就是复制算法：</strong></p>
<p>HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区。因为年轻代中的对象基本都是<code>朝生夕死的(90%以上)</code>，所以在年轻代的垃圾回收算法使用的是复制算法。</p>
<h3 id="标记压缩（Mark-Compact）"><a href="#标记压缩（Mark-Compact）" class="headerlink" title="标记压缩（Mark-Compact）"></a>标记压缩（Mark-Compact）</h3><p><strong>也叫标记整理算法。</strong></p>
<p>标记整理算法<code>是标记-清除法的一个改进版</code>。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是通过<code>所有存活对像都向一端移动，然后直接清除边界以外的内存</code>。</p>
<p><img src="/./../img/gt802yy-r1_V6nc6kONPH.gif" srcset="/img/loading.gif" lazyload></p>
<p><strong>优点：</strong></p>
<p>标记整理算法不仅可以弥补标记清除算法中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。</p>
<p><strong>缺点：</strong></p>
<p>如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低。</p>
<p><strong>老年代一般是由标记清除或者是标记清除与标记整理的混合实现。</strong></p>
<p><img src="/./../img/ei8pop8k1q_GLa6wPJHmS.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>难道就没有一种最优算法吗？</strong></p>
<p>回答：无，没有最好的算法，只有最合适的算法。&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<strong>分代收集算法</strong></p>
<h3 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational-Collection）"></a>分代收集算法（Generational-Collection）</h3><p><strong>执行速度：</strong></p>
<p>复制算法 &gt; 标记清除算法 &gt; 标记整理算法（此处的效率只是简单的对比<strong>时间复杂度</strong>，实际情况不一定如此）。</p>
<p><strong>内存利用率：</strong></p>
<p>标记整理算法&#x3D;标记清除算法&gt;复制算法。</p>
<blockquote>
<p>分代收集算法：</p>
<ul>
<li>将JVM管理的运行时数据区整片内存划分不同区域，垃圾回收工作在堆区</li>
<li>堆进行分代管理<ul>
<li><strong>新生代</strong>：复制（第一优先） + 标记清除 算法； <strong>新生代GC频率高</strong>，所以必须选择<strong>执行速度快</strong>的算法。</li>
<li><strong>老年代</strong>：标记压缩算法； 老年代GC频率低，都是长期存活的对象，我们就一次性摆好位置。 <code>标记压缩算法</code></li>
</ul>
</li>
</ul>
</blockquote>
<p>可以看出，效率上来说，<code>复制算法是当之无愧的老大，但是却浪费了太多内存</code>。</p>
<p>为了尽量兼顾上面所提到的三个指标，标记整理算法相对来说更平滑一些，但效率上依然不尽如人意。</p>
<p>比复制算法多了一个标记的阶段，又比标记清除多了一个整理内存的过程</p>
<p><code>分代回收算法</code>实际上是<code>复制算法和标记整理法的结合</code>，并不是真正一个新的算法。</p>
<p>一般分为<code>老年代（Old Generation）和年轻代（Young Generation）</code></p>
<p>老年代就是很少垃圾需要进行回收的，年轻代就是有很多的内存空间需要回收，所以不同代就采用不同的回收算法，以此来达到高效的回收算法。</p>
<p><strong>年轻代（Young Gen）</strong>（1&#x2F;3，8：1：1）</p>
<p><code>年轻代特点是区域相对老年代较小，对像存活率低。</code></p>
<p>这种情况<code>复制算法</code>的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<p><strong>老年代（Tenure Gen）</strong>（2&#x2F;3）</p>
<p>老年代占据着 2&#x2F;3 的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。（大对象可能会直接进入老年代）</p>
<p><code>老年代的特点是区域较大，对像存活率高。</code></p>
<p>这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是<code>由标记清除或者是标记清除与标记整理的混合实现</code>。</p>
<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><p>平时只会用到强引用和软引用。</p>
<p><strong>强引用：</strong><code>不回收</code></p>
<p>只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();  <span class="hljs-comment">//User obj = 0x7788;     [0x7788] = new Object();</span><br></code></pre></td></tr></table></figure>

<p><strong>软引用：</strong><code>内存不足即回收</code></p>
<p><code>SoftReference</code> 类实现软引用。在系统要发生内存溢出<code>（OOM）</code>之前，才会将这些对象列进回收范围之中<code>进行二次回收</code>。如果这次回收还没有足够的内存，才会抛出内存溢出异常。<code>软引用可用来实现内存敏感的高速缓存</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SoftReference&lt;User&gt; userSoftRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>));<br></code></pre></td></tr></table></figure>

<p><strong>弱引用：</strong><code>发现即回收</code></p>
<p><code>WeakReference</code> 类实现弱引用。对象只能生存到下一次垃圾收集<code>（GC）</code>之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">WeakReference&lt;User&gt; userWeakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;tom&quot;</span>));<br></code></pre></td></tr></table></figure>

<p><strong>虚引用（幽灵引用、幻影引用）：</strong><code>对象回收跟踪</code></p>
<p><code>PhantomReference</code> 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">phantomQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br>PhantomReference&lt;User&gt; obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;tom&quot;</span>), phantomQueue);<br></code></pre></td></tr></table></figure>











<p>end</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/JVM/" class="print-no-link">#JVM</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>11堆</div>
      <div>http://example.com/2025/11/14/11堆/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>無鎏雲</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年11月14日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/11/14/06%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%AD%89/" title="06并发工具等">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">06并发工具等</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/14/10JVM%E5%85%A5%E9%97%A8%E5%92%8C%E6%A0%88/" title="10JVM入门和栈">
                        <span class="hidden-mobile">10JVM入门和栈</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
