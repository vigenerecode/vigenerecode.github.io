<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>螺旋矩阵</title>
    <link href="/2025/06/25/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2025/06/25/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p>哎呦我靠，怎么螺旋矩阵怎么难，感觉接雨水都没这么难，<br>明天开启高三模式了，好累啊</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis安装</title>
    <link href="/2025/06/24/redis%E5%AE%89%E8%A3%85/"/>
    <url>/2025/06/24/redis%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>运行下面的命令下载（后面的链接替换为你复制的版本链接）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://download.redis.io/releases/redis-6.2.9.tar.gz<br></code></pre></td></tr></table></figure><p>解压压缩包：</p><p>tar xzf redis-6.2.9.tar.gz<br>bash</p><p>安装Redis</p><p>将解压后的目录移动到usr&#x2F;local⽬录下：</p><p>sudo mv .&#x2F;redis-6.2.9 &#x2F;usr&#x2F;local&#x2F;redis&#x2F;<br>bash<br> 进⼊redis⽬录编译和构建 redis：</p><p>cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F; &amp;&amp; sudo make<br>bash<br>安装redis：</p><p>sudo make install<br>bash</p><ol start="4"><li>注册服务</li></ol><p>上面的步骤已经将redis安装完成，你可以使用redis-server命令开启Redis服务了，但是为了更便捷地操作，我们需要让redis在后台运行并设置开机自启。</p><p>移动配置文件</p><p>将redis配置⽂件（配置文件目录：&#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf）移动到&#x2F;etc&#x2F;⽬录下，便于管理：</p><p>sudo mkdir -p &#x2F;etc&#x2F;redis&#x2F; &amp;&amp; sudo cp &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf &#x2F;etc&#x2F;redis&#x2F;<br>bash<br>注册redis服务</p><p>输入以下命令创建一个新的启动脚本：</p><p>sudo vi &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;redis.service<br>bash<br>按i进入编辑模式输入以下内容后按:wq保存退出：</p><p>[Unit]<br>Description&#x3D;Redis Server<br>After&#x3D;network.target</p><p>[Service]<br>ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf<br>ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-cli shutdown<br>Restart&#x3D;always</p><p>[Install]<br>WantedBy&#x3D;multi-user.target<br>bash</p><p>设置执行权限</p><p>将启动脚本设置为可执行：</p><p>sudo chmod +x &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;redis.service<br>bash<br>将脚本注册为服务</p><p>使用 systemctl 命令将脚本注册为服务，并启用它以在系统启动时自动启动：</p><p>sudo systemctl daemon-reload &amp;&amp; sudo systemctl enable redis<br>bash<br> 启动服务：</p><p>sudo systemctl start redis<br>bash<br>查看状态</p><p>sudo systemctl status redis<br>bash<br>输出下面的结果，表示Redis服务已经在后台正常运行并启用了开机自启：</p><p>root@ubuntu:&#x2F;etc&#x2F;redis# systemctl status redis<br>● redis.service - Redis Server<br>     Loaded: loaded (&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;redis.service; enabled; vendor preset: enabled)<br>     Active: active (running) since Wed 2024-04-24 17:23:41 CST; 3min 28s ago<br>   Main PID: 28421 (redis-server)<br>      Tasks: 5 (limit: 4568)<br>     Memory: 1.6M<br>        CPU: 854ms<br>     CGroup: &#x2F;system.slice&#x2F;redis.service<br>             └─28421 “&#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-server 127.0.0.1:6379” “” “” “” “” “” “” “”<br>AI写代码</p><ol start="3"><li>可选操作和配置<br>查看Redis安装版本<br>运行下面的命令查看已安装的Redis版本：</li></ol><p>redis-server -v<br>bash<br>输出结果： </p><p>配置密码登录<br>Redis 默认情况下是没有启用密码登录的。要启用密码登录，需要手动编辑 Redis 配置文件并设置密码，运行下面的命令（将命令中MyPassword123go替换为你需要设置的密码，该命令也适用于之前修改过密码重置密码）：</p><p>new_password&#x3D;”MyPassword123go”;sudo sed -i.bak -E “s&#x2F;^(\s*#)?\s<em>requirepass\s+.</em>&#x2F;requirepass $new_password&#x2F;“ &#x2F;etc&#x2F;redis&#x2F;redis.conf<br>bash<br>重启Redis服务：</p><p>systemctl restart redis<br>bash<br>验证密码</p><p>使用 redis-cli 工具连接到 Redis 服务器： </p><p>redis-cli<br>bash<br>输入auth命令进行身份验证（auth后跟上一步你设置的密码）：</p><p>auth MyPassword123go<br>bash<br>如果输出OK表示设置密码成功： </p><p>127.0.0.1:6379&gt; auth MyPassword123go<br>OK<br>bash<br> 启用远程访问<br>在启用远程访问前请确保已经配置了密码访问，最好还在防火墙限制了IP访问，不然如果你的云服务器没做防火墙限制的话，分分钟会被黑。因为将 Redis 服务器暴露在公网上会大大增加受到攻击的风险。攻击者可以轻松扫描公网 IP 地址，发现开启了 Redis 服务的服务器，并尝试利用漏洞进行攻击。</p><p>运行下面的命令：</p><p>sudo sed -i ‘s&#x2F;^bind .*&#x2F;bind 0.0.0.0&#x2F;‘ &#x2F;etc&#x2F;redis&#x2F;redis.conf<br>bash<br>重启Redis服务： </p><p>systemctl restart redis<br>bash<br>测试连接：</p><p>redis-cli -h 192.168.31.223 -p 6379 -a MyPassword123go<br>bash<br>redis-cli：是 Redis 提供的一个命令行工具，用于与 Redis 服务器进行交互。</p><p>-h 192.168.31.223：指定要连接的 Redis 服务器的 IP 地址。在这里，192.168.31.223 请替换为你要连接的远程 Redis 服务器的 IP 地址。</p><p>-p 6379：指定 Redis 服务器的端口号。默认情况下，Redis 服务器的端口号是 6379。如果你的 Redis 服务器使用了不同的端口，需要修改为相应的端口号。</p><p>-a MyPassword123go：指定连接到 Redis 服务器所需的密码。在这里，MyPassword123go 替换为你设置的密码。如果远程 Redis 服务器未设置密码，则可以省略该参数。</p><p>卸载Redis<br>请确保你在执行卸载之前备份了重要的数据</p><p>卸载软件：</p><p>sudo apt-get remove –purge redis-server -y<br>bash<br>删除 Redis 配置文件和数据文件：</p><p>sudo rm -rf &#x2F;etc&#x2F;redis &#x2F;var&#x2F;lib&#x2F;redis<br>bash<br>如果你是通过make方式安装的指定版本的Redis，请输入下列命令（可全部复制粘贴运行）：</p><p>sudo systemctl stop redis<br>sudo rm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis*<br>sudo rm -rf &#x2F;usr&#x2F;local&#x2F;redis*<br>sudo rm -rf &#x2F;etc&#x2F;redis<br>sudo rm -rf &#x2F;var&#x2F;lib&#x2F;redis<br>sudo rm &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;redis.service<br>sudo systemctl disable redis</p>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode238</title>
    <link href="/2025/06/24/Leetcode238/"/>
    <url>/2025/06/24/Leetcode238/</url>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请 **不要使用除法，**且在 <code>O(n)</code> 时间复杂度内完成此题。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: nums = [<span class="hljs-number">1,2,3,4</span>]<br>输出: [<span class="hljs-number">24,12,8,6</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[-1,1,0,-3,3]</span><br>输出: <span class="hljs-comment">[0,0,9,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li>输入 <strong>保证</strong> 数组 <code>answer[i]</code> 在 <strong>32 位</strong> 整数范围内</li></ul><p>**进阶：**你可以在 <code>O(1)</code> 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 <strong>不被视为</strong> 额外空间。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> suf[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [len];<br>        suf[len-<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            suf[i]=suf[i+<span class="hljs-number">1</span>]*nums[i+<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            suf[i] *= pre;<br>            pre *= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> suf;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>answer[i] 等于 nums 中除了 nums[i] 之外其余各元素的乘积。换句话说，如果知道了 i 左边所有数的乘积，以及 i 右边所有数的乘积，就可以算出 answer[i]。</p><p>于是：</p><p>定义 pre[i] 表示从 nums[0] 到 nums[i−1] 的乘积。<br>定义 suf[i] 表示从 nums[i+1] 到 nums[n−1] 的乘积。</p><p>我们可以先计算出从 nums[0] 到 nums[i−2] 的乘积 pre[i−1]，再乘上 nums[i−1]，就得到了 pre[i]，即</p><p>pre[i]&#x3D;pre[i−1]⋅nums[i−1]<br>同理有</p><p>suf[i]&#x3D;suf[i+1]⋅nums[i+1]</p><p>以上为基础做法</p><p>给出对的空间复杂度为O1，如何实现？</p><p>答案是将suf顺序直接乘进去，前缀和不断乘即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PDF-test</title>
    <link href="/2025/06/23/PDF-test/"/>
    <url>/2025/06/23/PDF-test/</url>
    
    <content type="html"><![CDATA[<p>部署pdf，有点难度</p><div class="pdf-container">  <iframe src="https://noflowcloud.netlify.app//pdfjs/web/viewer.html?file=/PDF/7小时速通SpringCloud.pdf" width="100%" height="500px"></iframe> </div>]]></content>
    
    
    
    <tags>
      
      <tag>PDF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode189：轮转数组</title>
    <link href="/2025/06/23/Leetcode189%EF%BC%9A%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <url>/2025/06/23/Leetcode189%EF%BC%9A%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>方法三：数组翻转<br>该方法基于如下的事实：当我们将数组的元素向右移动 k 次后，尾部 kmodn 个元素会移动至数组头部，其余元素向后移动 kmodn 个位置。</p><p>该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 kmodn 个元素就被移至数组头部，然后我们再翻转 [0,kmodn−1] 区间的元素和 [kmodn,n−1] 区间的元素即能得到最后的答案。</p><p>我们以 n&#x3D;7，k&#x3D;3 为例进行如下展示：</p><pre><code class="hljs">class Solution &#123;    public void rotate(int[] nums, int k) &#123;    k %= nums.length;    reverse(nums, 0, nums.length - 1);    reverse(nums, 0, k - 1);    reverse(nums, k, nums.length - 1);    &#125;public void reverse(int[] nums, int start, int end) &#123;    while (start &lt; end) &#123;        int temp = nums[start];        nums[start] = nums[end];        nums[end] = temp;        start += 1;        end -= 1;    &#125;&#125;&#125;</code></pre><p>复杂度分析</p><p>时间复杂度：O(n)，其中 n 为数组的长度。每个元素被翻转两次，一共 n 个元素，因此总时间复杂度为 O(2n)&#x3D;O(n)。</p><p>空间复杂度：O(1)。</p><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/rotate-array/solutions/551039/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/">https://leetcode.cn/problems/rotate-array/solutions/551039/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/</a><br>来源：力扣（LeetCode）</p><p>引用了美服翻转做法下面的评论(第一条) 希望能帮到大家<br>原地址</p><p>nums &#x3D; “—–&gt;–&gt;”; k &#x3D;3<br>result &#x3D; “–&gt;—–&gt;”;</p><p>reverse “—–&gt;–&gt;” we can get “&lt;–&lt;—–”<br>reverse “&lt;–” we can get “–&gt;&lt;—–”<br>reverse “&lt;—–” we can get “–&gt;—–&gt;”<br>this visualization help me figure it out :)</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chmod读文件之755</title>
    <link href="/2025/06/22/chmod%E8%AF%BB%E6%96%87%E4%BB%B6%E4%B9%8B755/"/>
    <url>/2025/06/22/chmod%E8%AF%BB%E6%96%87%E4%BB%B6%E4%B9%8B755/</url>
    
    <content type="html"><![CDATA[<p>755读文件最经典，r的权限只能看一眼有什么文件，还需要执行权限才能进去看文件内容或者里面的文件夹内容</p><p>注意，要将（比如MySQL这个大类）文件夹设为755，其余人员才能进去，然后将文件夹里面的设置为754，就能实现不能运行了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux的三个问题</title>
    <link href="/2025/06/22/Linux%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <url>/2025/06/22/Linux%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h1><h1 id="1三个问题"><a href="#1三个问题" class="headerlink" title="1三个问题"></a>1三个问题</h1><p>1.Linux怎么样部署测试环境，部署完了之后怎么样知道是否启动成功了这个项目</p><p>2.部署出现问题，用什么命令去查找相关的logo日志</p><p>3.当某个可执行文件的权限不足时候，怎么做</p><p>基本回答如下</p><p>测试环境用容器来部署。这样可以保证所有开发人员环境统一。可以选择docker或者podman，选择对应compose编写部署文件。使用dockerfile编译与打包程序，可以减少自动化测试时环境造成的编译打包问题。</p><p>出现错误可以有多种选择。一，当应用有使用统一的日志管理中间件时可以直接后台查看日志；二，当使用容器部署测试时，可使用exec命令参数进入shell，查看日志目录与日志文件；三，当dockerfile导出日志数据卷时，可直接查看对应的导出目录；四，在shell中可以使用vim，cat，等命令查看日志文件。</p><p>当可执行文件权限不足时，可使用“ls -la 文件名”查看文件是否有执行权限以及文件属于的用户与用户组。若文件属于当前环境使用的用户，则使用chmod命令添加执行权限；若文件不属于当前用户，且当前用户不存在与文件所有者组中时，应人为判断是否可以修改文件所有者或组，亦或是将当前环境使用的用户加入所有者组中，使用chown进行修改。</p><h1 id="2-进阶"><a href="#2-进阶" class="headerlink" title="2 进阶"></a>2 进阶</h1><p>1、如果项目不用docker容器等部署方式你又怎么查？直接ps -ef grep java 或者ps -ef | grep jdk<br>2、vim本质是编辑本文，需要一下加载文本所有数据的，你这样只会卡死， 监听用tail 粗略看用more 详细看用less ，more和less都可以跳行和搜索，cat一下全部加载也不好<br>3、文件权限不足就改文件权限，你真不怕改出事？ 正确方法就是ls -lrt 看文件的权限，看他属于那个用户，再su切换有权限的用户去操作才是正确的</p><h1 id="3综合可得最佳答案为"><a href="#3综合可得最佳答案为" class="headerlink" title="3综合可得最佳答案为"></a>3综合可得最佳答案为</h1><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>部署测试环境</strong>：优先使用容器化（Docker&#x2F;Podman），通过进程、日志、网络检测确认启动。</li><li><strong>查找日志</strong>：容器化使用 <code>docker logs</code>，非容器化使用 <code>tail</code>&#x2F;<code>grep</code>&#x2F;<code>journalctl</code>。</li><li><strong>权限不足</strong>：优先 <code>chmod +x</code>，必要时修改所有者或用户组，避免过度开放权限。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-21</title>
    <link href="/2025/06/21/6-21/"/>
    <url>/2025/06/21/6-21/</url>
    
    <content type="html"><![CDATA[<h2 id="1终于学完ssm了"><a href="#1终于学完ssm了" class="headerlink" title="1终于学完ssm了"></a>1终于学完ssm了</h2><p>真感觉SSM跟SPringboot没有什么重点啊，除了可能要看源码之外，其他直接跟着项目搞就行了</p><h2 id="2终于弄完计组的一堆作业了"><a href="#2终于弄完计组的一堆作业了" class="headerlink" title="2终于弄完计组的一堆作业了"></a>2终于弄完计组的一堆作业了</h2><p>疑似浪费了一天</p><h2 id="3打算把leetcode重新捡起来"><a href="#3打算把leetcode重新捡起来" class="headerlink" title="3打算把leetcode重新捡起来"></a>3打算把leetcode重新捡起来</h2><p>应该关注个人然后偷看ta的进度</p><h1 id="TODOLIST："><a href="#TODOLIST：" class="headerlink" title="TODOLIST："></a>TODOLIST：</h1><p>1.博客的run netlify命令仍然有问题</p><p>2.天选又开始黑屏休眠了，得关</p><p>3.复习（复健）leetcode</p><p>4.LSTM的PPT之类的</p><p>5.争取考试之前学完Linux跟git</p><p>6.眼睛好不舒服啊啊啊啊啊啊</p><p>休息了，睡了晚安</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode03：无重复字符的最长子串</title>
    <link href="/2025/06/21/Leetcode03%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2025/06/21/Leetcode03%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><p>提示</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 记录字符上一次出现的位置</span><br>        <span class="hljs-type">int</span>[] last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++) &#123;<br>            last[i] = -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 窗口开始位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            start = Math.max(start, last[index] + <span class="hljs-number">1</span>);<br>            res   = Math.max(res, i - start + <span class="hljs-number">1</span>);<br>            last[index] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试着解释了一下，希望对大家有所帮助~</p><p>以这个字符串为例：abcabcbb，</p><p>当i等于3时，也就是指向了第二个a, 此时我就需要查之前有没有出现过a, 如果出现了是在哪一个位置出现的。</p><p>然后通过last[index] 查到等于1, 也就是说，如果start 依然等于0的话，那么当前窗口就有两个a了，也就是字符串重复了，所以我们需要移动当前窗口的start指针，移动到什么地方呢？</p><p>移动到什么地方，窗口内就没有重复元素了呢？<br>对了，就是a上一次出现的位置的下一个位置，就是1 + 1 &#x3D; 2。</p><p>当start &#x3D;&#x3D; 2, 当前窗口就没有了重复元素，那么以当前字符为结尾的最长无重复子串就是bca,然后再和之前的res取最大值。</p><p>然后i指向后面的位置，按照同样思路计算。</p><p>start用于标记重复的</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.20记录</title>
    <link href="/2025/06/20/6-20/"/>
    <url>/2025/06/20/6-20/</url>
    
    <content type="html"><![CDATA[<p>必胜客真好吃吧，感觉是最好吃的西餐了，虽然也没吃过更贵的就是了，生活中的小幸福啊</p><p><img src="F:\MyBlog_hexo\source\img\必胜客.jpg" alt="必胜客"></p>]]></content>
    
    
    
    <tags>
      
      <tag>日常生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo部署之netlify</title>
    <link href="/2025/06/20/netlify%E6%9B%B4%E6%96%B0/"/>
    <url>/2025/06/20/netlify%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="部署后Netlify上未显示最新更改"><a href="#部署后Netlify上未显示最新更改" class="headerlink" title="部署后Netlify上未显示最新更改"></a>部署后Netlify上未显示最新更改</h1><p>关联问题</p><p>[ 为什么Netlify上没有显示最新的更改？](<a href="https://copilot.tencent.com/chat?s=">https://copilot.tencent.com/chat?s=</a> 为什么Netlify上没有显示最新的更改？&amp;fromSource&#x3D;gwzcw.9271037.9271037.9271037&amp;utm_medium&#x3D;cpc&amp;utm_id&#x3D;gwzcw.9271037.9271037.9271037)</p><p>[ Netlify部署后内容未更新怎么办？](<a href="https://copilot.tencent.com/chat?s=">https://copilot.tencent.com/chat?s=</a> Netlify部署后内容未更新怎么办？&amp;fromSource&#x3D;gwzcw.9271037.9271037.9271037&amp;utm_medium&#x3D;cpc&amp;utm_id&#x3D;gwzcw.9271037.9271037.9271037)</p><p>[ 如何确保Netlify显示最新的部署内容？](<a href="https://copilot.tencent.com/chat?s=">https://copilot.tencent.com/chat?s=</a> 如何确保Netlify显示最新的部署内容？&amp;fromSource&#x3D;gwzcw.9271037.9271037.9271037&amp;utm_medium&#x3D;cpc&amp;utm_id&#x3D;gwzcw.9271037.9271037.9271037)</p><p>是因为缓存或者静态文件未正确刷新导致的。下面是解决该问题的一些步骤和技巧：</p><ol><li>清除浏览器缓存：浏览器会缓存静态文件，以提高网页加载速度。但是有时候这会导致最新更改无法及时显示。你可以尝试按下Ctrl + F5（Windows）或者Command + Shift + R（Mac）来强制刷新页面。</li><li>清除Netlify缓存：Netlify也会缓存文件以提高访问速度。你可以进入Netlify的项目设置页面，找到“Build &amp; Deploy”选项，然后点击“Clear cache and deploy site”来清除缓存并重新部署站点。</li><li>检查版本控制：确保你将最新的更改提交到了版本控制系统（如Git）并推送到了Netlify。如果你只是本地修改了文件而没有将其推送到版本控制系统，Netlify将无法检测到更改并进行部署。</li><li>查看部署日志：在Netlify的项目设置页面中，你可以找到“Deploys”选项，并查看最近的部署日志。检查日志中是否有错误或警告信息，以帮助你找出问题所在。</li><li>检查构建设置：如果你使用了构建工具（如Webpack或Gulp），请确保你的构建设置正确。检查构建配置文件，例如webpack.config.js或gulpfile.js，以确保正确设置了文件路径和构建规则。</li><li>强制重新部署：在Netlify的项目设置页面中，你可以手动触发重新部署。这将强制Netlify重新构建和部署站点，以确保最新更改被正确显示。</li></ol><p>总结起来，当部署后Netlify上未显示最新更改时，可以考虑清除浏览器缓存、清除Netlify缓存、检查版本控制、查看部署日志、检查构建设置以及强制重新部署等操作来解决问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/06/20/hello-world/"/>
    <url>/2025/06/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>helloworld</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2025/06/20/test/"/>
    <url>/2025/06/20/test/</url>
    
    <content type="html"><![CDATA[<p>printf(“helloworld”)</p>]]></content>
    
    
    
    <tags>
      
      <tag>helloworld</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
