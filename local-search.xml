<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/12/01/43JavaIO/"/>
    <url>/2025/12/01/43JavaIO/</url>
    
    <content type="html"><![CDATA[<p>23.BIO、NIO、AIO三者区别以及适用场景？<br>BIO（Blocking I&#x2F;O）：<br>阻塞模型： BIO是基于阻塞模型的I&#x2F;O操作，意味着当一个线程执行I&#x2F;O操作时，它将一直阻塞，直到操作完成。<br>同步性： 在BIO中，所有I&#x2F;O操作都是同步的，一个线程对一个连接进行读或写，直到完成。<br>适用性： 适用于连接数量较少且每个连接的数据交互频繁的情况，但在高并发环境下性能不佳。</p><p>NIO（Non-blocking I&#x2F;O）：<br>非阻塞模型： NIO采用了非阻塞模型，允许一个线程管理多个通道（连接）。<br>选择器（Selector）： NIO引入了选择器（Selector）的概念，通过选择器一个线程可以监听多个通道上的事件，如读就绪、写就绪等。<br>缓冲区（Buffer）： NIO使用缓冲区来存储数据，可以提高I&#x2F;O效率。<br>适用性： 适用于需要处理大量连接且连接数较多，但每个连接的数据交互相对较少的情况，如Web服务器。</p><p>AIO（Asynchronous I&#x2F;O）：<br>异步模型： AIO采用异步模型，允许一个线程在进行I&#x2F;O操作时不被阻塞，当操作完成后会通知应用程序。<br>回调机制： AIO使用回调机制来处理I&#x2F;O操作完成的通知。<br>适用性： 适用于需要处理大量连接且每个连接的数据交互较少，且希望充分利用CPU的多核性能的情况。</p><p>总结各种I&#x2F;O模型的适用场景：<br>BIO适用于连接数较少，且每个连接的数据交互频繁的情况，但不适用于高并发环境。<br>NIO适用于需要处理大量连接，但每个连接的数据交互相对较少的情况，具有更好的性能和资源利用率。<br>AIO适用于需要处理大量连接，且每个连接的数据交互较少，同时希望充分利用CPU多核性能的情况。<br>选择适当的I&#x2F;O模型取决于应用程序的特性和需求，不同的模型提供了不同的性能和可伸缩性。<br>————————————————<br>版权声明：本文为CSDN博主「是江迪呀」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_42785250/article/details/132973244">https://blog.csdn.net/qq_42785250/article/details/132973244</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>104深度分页</title>
    <link href="/2025/11/29/104%E6%B7%B1%E5%88%86%E9%A1%B5/"/>
    <url>/2025/11/29/104%E6%B7%B1%E5%88%86%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近遇到接口慢查询问题，仔细排查发现涉及mysql深度分页问题，于是便查阅各种资料寻求解决方案。这里总结一下可能会用到的解决方案。</p><p>我们日常做分页需求时，一般会用limit实现，但是当偏移量特别大的时候，查询效率就变得低下。本文将分4个方案，讨论如何优化MySQL大量数据的深分页问题。</p><h2 id="limit深度分页为什么会变慢？"><a href="#limit深度分页为什么会变慢？" class="headerlink" title="limit深度分页为什么会变慢？"></a>limit深度分页为什么会变慢？</h2><p>先看下表结构：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> account (<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;主键Id&#x27;</span>,<br>  <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;账户名&#x27;</span>,<br>  balance <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;余额&#x27;</span>,<br>  create_time datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  update_time datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (id),<br>  KEY idx_name (<span class="hljs-type">name</span>),<br>  KEY idx_update_time (update_time) //索引<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">1570068</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8 ROW_FORMAT=REDUNDANT <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">&#x27;账户表&#x27;</span>;<br></code></pre></td></tr></table></figure><p>假设深分页的执行SQL如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> id,<span class="hljs-type">name</span>,balance <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> update_time&gt; <span class="hljs-string">&#x27;2020-09-19&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">100000</span>,<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这个SQL的执行时间如下：</p><p><a href="http://refain.top/img/c0f021c1799e4759a3615b813c44581b~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg"><img src="/./../img/c0f021c1799e4759a3615b813c44581btplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg" alt="c0f021c1799e4759a3615b813c44581b~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"></a></p><p>执行完需要<strong>0.742</strong>秒，深分页为什么会<strong>变慢</strong>呢？如果换成 <code>limit 0,10</code>，只需要<strong>0.006</strong>秒哦</p><p><a href="http://refain.top/img/05a3016b7ba64aa3a73dd3105b986666~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg"><img src="/./../img/05a3016b7ba64aa3a73dd3105b986666tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg" alt="05a3016b7ba64aa3a73dd3105b986666~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"></a></p><p>我们先来看下这个SQL的执行流程：</p><ol><li>通过<strong>普通二级索引树</strong>idx_update_time，过滤update_time条件，找到满足条件的记录ID。</li><li>通过ID，回到<strong>主键索引树</strong>，找到满足记录的行，然后取出展示的列（<strong>回表</strong>）</li><li>扫描满足条件的100010行，然后扔掉前100000行，返回。</li></ol><p><a href="http://refain.top/img/7cb901db283140bd8cc0fe607f9e190a~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg"><img src="/./../img/7cb901db283140bd8cc0fe607f9e190atplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg" alt="7cb901db283140bd8cc0fe607f9e190a~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"></a></p><p>SQL的执行流程</p><p><strong>执行计划</strong>如下：</p><p><a href="http://refain.top/img/ac07320c5d314de9a212a800f8dd2178~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg"><img src="/./../img/ac07320c5d314de9a212a800f8dd2178tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg" alt="ac07320c5d314de9a212a800f8dd2178~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"></a></p><p><strong>SQL变慢原因有两个</strong>：</p><ol><li>limit语句会先扫描offset+n行，然后再丢弃掉前offset行，返回后n行数据。也就是说<code>limit 100000,10</code>，就会扫描100010行，而<code>limit 0,10</code>，只扫描10行。</li><li><code>limit 100000,10</code> 扫描更多的行数，也意味着<strong>回表</strong>更多的次数。</li></ol><h2 id="通过子查询优化"><a href="#通过子查询优化" class="headerlink" title="通过子查询优化"></a>通过子查询优化</h2><p>因为以上的SQL，回表了100010次，实际上，我们只需要10条数据，也就是我们只需要10次回表其实就够了。因此，我们可以通过<strong>减少回表次数</strong>来优化。</p><h3 id="回顾B-树结构"><a href="#回顾B-树结构" class="headerlink" title="回顾B+ 树结构"></a>回顾B+ 树结构</h3><p>那么，如何减少回表次数呢？我们先来复习下B+树索引结构哈~</p><p>InnoDB中，索引分主键索引（聚簇索引）和二级索引</p><ul><li>主键索引，叶子节点存放的是整行数据</li><li>二级索引，叶子节点存放的是<strong>主键的值</strong>。</li></ul><p><a href="http://refain.top/img/bf21b9cc399f428b9b9a68b9b8332f5a~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg"><img src="/./../img/bf21b9cc399f428b9b9a68b9b8332f5atplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg" alt="bf21b9cc399f428b9b9a68b9b8332f5a~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"></a></p><h3 id="把条件转移到主键索引树"><a href="#把条件转移到主键索引树" class="headerlink" title="把条件转移到主键索引树"></a>把条件转移到主键索引树</h3><p>如果我们把查询条件，转移回到主键索引树，那就不就可以减少回表次数啦。转移到主键索引树查询的话，查询条件得改为<code>主键id</code>了，之前SQL的<code>update_time</code>这些条件咋办呢？抽到<strong>子查询</strong>那里嘛~</p><p>子查询那里怎么抽的呢？因为二级索引叶子节点是有主键ID的，所以我们直接根据<code>update_time</code>来查主键ID即可，同时我们把 <code>limit 100000</code>的条件，也转移到子查询，完整SQL如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> id,<span class="hljs-type">name</span>,balance <span class="hljs-keyword">FROM</span> account <span class="hljs-keyword">where</span> id &gt;= (<span class="hljs-keyword">select</span> a.id <span class="hljs-keyword">from</span> account a <span class="hljs-keyword">where</span> a.update_time &gt;= <span class="hljs-string">&#x27;2020-09-19&#x27;</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">100000</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;（可以加下时间条件到外面的主查询）<br></code></pre></td></tr></table></figure><p>查询效果一样的，执行时间只需要0.038秒！</p><p><a href="http://refain.top/img/e912334f229647afb1428cf70c1e42a5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg"><img src="/./../img/e912334f229647afb1428cf70c1e42a5tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg" alt="e912334f229647afb1428cf70c1e42a5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"></a></p><p>我们来看下执行计划</p><p><a href="http://refain.top/img/d2fdba12596e4c82a6c22a433d89966c~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg"><img src="/./../img/d2fdba12596e4c82a6c22a433d89966ctplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg" alt="d2fdba12596e4c82a6c22a433d89966c~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"></a></p><p>由执行计划得知，子查询 table a查询是用到了<code>idx_update_time</code>索引。首先在索引上拿到了聚集索引的主键ID,省去了回表操作，然后第二查询直接根据第一个查询的 ID往后再去查10个就可以了!</p><p><a href="http://refain.top/img/a9fba5ff58fc4ebcbb944d19bb254c47~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg"><img src="/./../img/a9fba5ff58fc4ebcbb944d19bb254c47tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg" alt="a9fba5ff58fc4ebcbb944d19bb254c47~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"></a></p><p>因此，这个方案是可以的~</p><h2 id="INNER-JOIN-延迟关联"><a href="#INNER-JOIN-延迟关联" class="headerlink" title="INNER JOIN 延迟关联"></a>INNER JOIN 延迟关联</h2><p>延迟关联的优化思路，<strong>跟子查询的优化思路其实是一样的</strong>：都是把条件转移到主键索引树，然后减少回表。不同点是，延迟关联使用了inner join代替子查询。</p><p>优化后的SQL如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span>  acct1.id,acct1.name,acct1.balance <span class="hljs-keyword">FROM</span> account acct1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> a.id <span class="hljs-keyword">FROM</span> account a <span class="hljs-keyword">WHERE</span> a.update_time &gt;= <span class="hljs-string">&#x27;2020-09-19&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.update_time <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">100000</span>, <span class="hljs-number">10</span>) <span class="hljs-keyword">AS</span>  acct2 <span class="hljs-keyword">on</span> acct1.id= acct2.id;<br></code></pre></td></tr></table></figure><p>查询效果也是杠杆的，只需要0.034秒</p><p><a href="http://refain.top/img/1c07a09527654b51a68e6df21eb65f84~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg"><img src="/./../img/1c07a09527654b51a68e6df21eb65f84tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg" alt="1c07a09527654b51a68e6df21eb65f84~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"></a></p><p>执行计划如下：</p><p><a href="http://refain.top/img/a522f71a595347348fcf23a2d6da93ab~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg"><img src="/./../img/a522f71a595347348fcf23a2d6da93abtplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.jpg" alt="a522f71a595347348fcf23a2d6da93ab~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"></a></p><p>查询思路就是，先通过<code>idx_update_time</code>二级索引树查询到满足条件的主键ID，再与原表通过主键ID内连接，这样后面直接走了主键索引了，同时也减少了回表。</p><h2 id="标签记录法-游标"><a href="#标签记录法-游标" class="headerlink" title="标签记录法(游标)"></a>标签记录法(游标)</h2><p>limit 深分页问题的本质原因就是：<strong>偏移量（offset）越大，mysql就会扫描越多的行，然后再抛弃掉。这样就导致查询性能的下降</strong>。</p><p>其实我们可以采用<strong>标签记录</strong>法，就是标记一下上次查询到哪一条了，下次再来查的时候，从该条开始往下扫描。<strong>就好像看书一样，上次看到哪里了，你就折叠一下或者夹个书签，下次来看的时候，直接就翻到啦</strong>。</p><p>假设上一次记录到100000，则SQL可以修改为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span>  id,<span class="hljs-type">name</span>,balance <span class="hljs-keyword">FROM</span> account <span class="hljs-keyword">where</span> id &gt; <span class="hljs-number">100000</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">limit</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这样的话，后面无论翻多少页，性能都会不错的，因为命中了<code>id</code>索引。但是你，这种方式<strong>有局限性</strong>：需要一种类似连续自增的字段。</p><h2 id="使用between…and…"><a href="#使用between…and…" class="headerlink" title="使用between…and…"></a>使用between…and…</h2><p>很多时候，可以将<code>limit</code>查询转换为已知位置的查询，这样MySQL通过范围扫描<code>between...and</code>，就能获得到对应的结果。</p><p>如果知道边界值为100000，100010后，就可以这样优化：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span>  id,<span class="hljs-type">name</span>,balance <span class="hljs-keyword">FROM</span> account <span class="hljs-keyword">where</span> id <span class="hljs-keyword">between</span> <span class="hljs-number">100000</span> <span class="hljs-keyword">and</span> <span class="hljs-number">100010</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><h1 id="3层b-树"><a href="#3层b-树" class="headerlink" title="3层b+树"></a>3层b+树</h1><p>接下来，通过以下计算步骤，就可以统计出两层的B+数大概可以存储多少条记录数据——</p><p>一、先计算一个节点的字节大小：16kb * 1024 &#x3D; 16384 字节。</p><p>二、16384 字节 &#x2F; 14 字节 &#x3D; 1170 ，意味着，根节点有1170个页地址指针，然后，每个页地址指针指向的叶子节点可以存放16条数据。</p><p>三、那么，根据“根节点页地址指针数量 * 单个叶子节点记录行数”，计算1170 * 16 &#x3D; 18720 条记录，可见，两层B+数可以存放18720条记录，当然，这个数字是存在出入的，只是作为参考。</p><p>既然已经知道两层B+数可以存放18720条数据，那么，三层不就可以进一步算出了吗？</p><p>简单画一个三层B+数的存放数据计算逻辑——</p><p><img src="/./../img/991e1afc21d4c4cd233a5c913d79cfc2.png" alt="img"></p><p>一、根节点最多有1170个指针数；</p><p>二、说明第二层最多会有1170个子节点，同时，每个子节点里最多有1170个指针数；</p><p>三、那么，第三层叶节点数量，可以通过 “第二层最多有1170个节点数量 * 每个节点里最多有1170个指针数量”，也就是1170 * 1170</p><p>四、最后，计算第三层所有叶子数量 * 各个叶子节点存放的16条数据；</p><p>最后，1170 * 1170 * 16 &#x3D; 21902400，得出两千万左右条数据。</p><p>综上所述，若面试当中遇到这样问题，可以按照这个流程计算回答。</p>]]></content>
    
    
    
    <tags>
      
      <tag>kcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>105消息队列kafka</title>
    <link href="/2025/11/29/50%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97Kafka/"/>
    <url>/2025/11/29/50%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97Kafka/</url>
    
    <content type="html"><![CDATA[<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ol><li><h3 id="代理（Brokers）"><a href="#代理（Brokers）" class="headerlink" title="代理（Brokers）"></a>代理（Brokers）</h3></li></ol><p>存储消息、收发消息的<strong>服务器</strong>，我们称为消息代理；</p><ol><li><h3 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）"></a><strong>消息（Message）</strong></h3></li></ol><p>Kafka 中的数据单元被称为<code>消息</code>，也被称为<strong>记录</strong>，可以把它看作数据库表中某一行的记录。</p><ol><li><h3 id="批次（Batch）"><a href="#批次（Batch）" class="headerlink" title="批次（Batch）"></a>批次（Batch）</h3></li></ol><p>为了提高效率， 消息会<code>分批次</code>写入 Kafka，批次就代指的是一组消息。</p><ol><li><h3 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）"></a>主题（Topic）</h3></li></ol><p>消息的种类称为 <code>主题</code>（Topic）,可以说一个<strong>主题</strong>代表了<strong>一类消息</strong>。相当于是对消息进行分类。<strong>主题</strong>就像是数据库中的表。</p><ol><li><h3 id="分区（Partition）"><a href="#分区（Partition）" class="headerlink" title="分区（Partition）"></a>分区（Partition）</h3></li></ol><p><strong>一个<strong><strong>主题</strong></strong>可以被分为若干个分区（partition）</strong>，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的<code>伸缩性</code>，单一主题中的分区有序，但是无法保证主题中所有的分区有序</p><p><img src="/./../img/1765888016095-3.png" alt="img"></p><p>一直追加的<strong>顺序写操作</strong>；</p><ol><li><h3 id="同步副本（In-Sync-Replicas）"><a href="#同步副本（In-Sync-Replicas）" class="headerlink" title="同步副本（In Sync Replicas）"></a>同步副本（In Sync Replicas）</h3></li></ol><blockquote><p><strong>副本</strong>：每个分区可以有多个副本，也就是数据的备份。这样即使分区数据错误，副本也可以恢复过来</p><p>**同步：**所有的消息必须发给主分区所在机器，副本分区同步主分区的数据</p></blockquote><p><img src="/./../img/1765888016091-1.png" alt="img"></p><ol><li><h3 id="消费者-消费者组（Consumer-Consumer-Group）"><a href="#消费者-消费者组（Consumer-Consumer-Group）" class="headerlink" title="消费者&amp;消费者组（Consumer &amp; Consumer Group）"></a>消费者&amp;消费者组（Consumer &amp; Consumer Group）</h3></li></ol><p>注意：<strong>消费者可以分组</strong>，一般一种微服务的所有消费者就是一组。</p><ol><li><strong>同组的消费者</strong>属于<strong>竞争关系</strong>，<strong>消息只能被一个消费者拿到</strong>；</li><li><strong>不同组的消费者</strong>属于<strong>发布订阅关系</strong>。同一个主题的消息，<strong>广播给不同组的消费者</strong>。</li><li><strong>消费者</strong>可以<strong>订阅多种主题的消息</strong>；</li></ol><p><img src="/./../img/1765888016092-2.png" alt="img"></p><ol><li><h3 id="偏移量（Offset）"><a href="#偏移量（Offset）" class="headerlink" title="偏移量（Offset）"></a>偏移量（Offset）</h3></li></ol><p>偏移量：<code>偏移量</code>（Consumer Offset）是一种元数据，它是一个不断递增的整数值，用来记录消费者发生重平衡时的位置，以便用来恢复数据。</p><h1 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h1><ol><li><h3 id="成功创建"><a href="#成功创建" class="headerlink" title="成功创建"></a>成功创建</h3></li></ol><blockquote><ol><li><strong>副本数量必须小于Broker数量</strong>。</li><li><strong>分区数量无所谓</strong>，根据你自己对数据的预估，分成N个区，如果Broker只有一个，所有分区的数据都在这一个机器，如果Broker有多个，分区可以被分散到其他机器。从而形成一个压力分担的效果；</li></ol><p><strong>计算方式</strong>：  <strong>N Broker 最多允许 N 副本</strong>；</p></blockquote><h2 id="Kafka-高可用机制详解"><a href="#Kafka-高可用机制详解" class="headerlink" title="Kafka 高可用机制详解"></a><a href="https://blog.csdn.net/Aaaaaaatwl/article/details/139859673">Kafka 高可用机制详解</a></h2><p><a href="https://blog.csdn.net/Aaaaaaatwl/article/details/139859673">1</a><a href="https://developer.aliyun.com/article/848162">2</a><a href="https://juejin.cn/post/7494562378153263143">3</a></p><p>Kafka 的高可用性通过多种设计实现，确保在节点故障或网络分区时仍能持续提供服务，同时保证数据的一致性和可靠性。</p><p>Kafka 的 <strong>副本机制</strong> 是高可用的核心。每个分区（Partition）都有多个副本（Replica），其中一个是 <strong>Leader 副本</strong>，负责处理所有读写请求，其余为 <strong>Follower 副本</strong>，负责从 Leader 同步数据。当 Leader 副本发生故障时，会从同步副本（ISR）中选举新的 Leader，确保服务不中断。</p><p>Kafka 的 <strong>分区机制</strong> 提高了系统的扩展性和容错能力。一个主题（Topic）可以分为多个分区，分布在不同的 Broker 上，即使某个 Broker 宕机，也不会影响其他分区的正常运行。</p><p>Kafka 使用 <strong>ISR（In-Sync Replicas）机制</strong> 来保证数据一致性。ISR 是与 Leader 保持同步的副本集合，只有在 ISR 中的副本才有资格被选为新的 Leader。未同步的副本会被移出 ISR，避免数据不一致。</p><p><strong>Leader 选举</strong> 是 Kafka 高可用的关键。当 Leader 副本失效时，Kafka 会从 ISR 中选举新的 Leader。选举过程由 Controller 节点负责，Controller 是通过 ZooKeeper 或 KRaft 选举出来的，确保整个集群的协调和管理。</p><p>Kafka 的 <strong>消费者组（Consumer Group）</strong> 提供了高可用的消费机制。消费者组中的消费者共同消费一个主题的分区数据，当某个消费者失效时，其分区会被重新分配给其他消费者，保证消费不中断。</p><p>Kafka 的 <strong>重平衡机制</strong> 在消费者组发生变更时重新分配分区，确保高可用性和伸缩性。然而，重平衡期间消费者无法读取消息，可能导致短暂的不可用。</p><p>通过以上机制，Kafka 实现了高可用性和高可靠性，能够在节点故障、网络分区等情况下保持服务稳定，同时确保数据的一致性和安全性。</p><h1 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h1><h3 id="5个消费者，4个分区"><a href="#5个消费者，4个分区" class="headerlink" title="5个消费者，4个分区"></a>5个消费者，4个分区</h3><p>每个分区所产生的消息能够被每个消费者群组中的消费者消费，如果向消费者群组中增加更多的消费者，那么多余的消费者将会闲置，</p><p><img src="/./../img/1765889801564-59.png" alt="img"></p><p>向群组中增加消费者是横向伸缩消费能力的主要方式。总而言之，我们可以通过增加消费组的消费者来进行<code>水平扩展提升消费能力</code>。<strong>这也是为什么建议创建主题时使用比较多的分区数</strong>，这样可以在消费负载高的情况下增加消费者来提升性能。另外，消费者的数量不应该比分区数多，因为多出来的消费者是空闲的，没有任何帮助。</p><ol><li><h3 id="多个消费者组"><a href="#多个消费者组" class="headerlink" title="多个消费者组"></a>多个消费者组</h3></li></ol><p>Kafka 一个很重要的特性就是，<strong>只需写入一次消息，可以支持任意多的应用读取这个消息</strong>。换句话说，**每个应用都可以读到全量的消息。**为了使得每个应用都能读到全量消息，应用需要有不同的消费组。对于上面的例子，假如我们新增了一个新的消费组 G2，而这个消费组有两个消费者，那么就演变为下图这样</p><p><img src="/./../img/1765889801564-60.png" alt="img"></p><p>在这个场景中，消费组 G1 和消费组 G2 都能收到 T1 主题的全量消息，在逻辑意义上来说它们属于不同的应用。</p><p><strong>总结起来就是如果应用需要读取全量消息，那么请为该应用设置一个消费组；如果该应用消费能力不足，那么可以考虑在这个消费组里增加消费者</strong>。</p><ol><li><h2 id="分区重平衡"><a href="#分区重平衡" class="headerlink" title="分区重平衡"></a><strong>分区重平衡</strong></h2></li></ol><p>从上面的<code>消费者演变图</code>中可以知道这么一个过程：最初是一个消费者订阅一个主题并消费其全部分区的消息，后来有一个消费者加入群组，随后又有更多的消费者加入群组，而新加入的消费者实例<code>分摊</code>了最初消费者的部分消息，这种把分区的所有权通过一个消费者转到其他消费者的行为称为<code>重平衡</code>，英文名也叫做 <code>Rebalance</code> 。如下图所示</p><p><img src="/./../img/1765889801564-61.png" alt="img-999"></p><ol><li><p><strong>重平衡是Kafka消费者组在成员发生变化时（消费者加入、离开或崩溃），重新分配分区给消费者的过程。</strong></p></li><li><p><strong>在重平衡期间，消费者组中的消费者实例都会停止消费，等待重平衡的完成。而且重平衡这个过程很慢。</strong></p></li><li><h3 id="触发重平衡的条件"><a href="#触发重平衡的条件" class="headerlink" title="触发重平衡的条件"></a>触发重平衡的条件</h3></li><li><p><strong>消费者加入</strong>：新消费者加入消费者组</p></li><li><p><strong>消费者离开</strong>：消费者主动离开或崩溃</p></li><li><p><strong>订阅主题变化</strong>：订阅的主题分区数发生变化</p></li><li><p><strong>心跳超时</strong>：<strong>消费者</strong>未能按时发送心跳（默认五分钟）</p></li></ol><p>消费者数量变化、主题变化</p><ol><li><h3 id="重平衡的具体过程"><a href="#重平衡的具体过程" class="headerlink" title="重平衡的具体过程"></a>重平衡的具体过程</h3></li></ol><p>当Kafka 集群要触发重平衡机制时，大致的步骤如下: <strong>1.暂停消费:</strong> 在重平衡开始之前，Kafka 会暂停所有消费者的拉取操作，以确保不会出现重平衡期间的消息丢失或重复消费。 <strong>2.计算分区分配方案:</strong> Kafka 集群会根据当前消费者组的消费者数量和主题分区数量，计算出每个消费者应该分配的分区列表，以实现分区的负载均衡。 <strong>3.通知消费者:</strong> 一旦分区分配方案确定，Kafka 集群会将分配方案发送给每个消费者，告诉它们需要消费的分区列表，并请求它们重新加入消费者组。 <strong>4.重新分配分区:</strong> 在消费者重新加入消费者组后，Kafka 集群会将分区分配方案应用到实际的分区分配中，重新分配主题分区给各个消费者。 <strong>5.恢复消费:</strong> 最后，Kafka 会恢复所有消费者的拉取操作，允许它们消费分配给自己的分区。</p><p>消费者连接上以后，从这个分区之前偏移量以后的消息继续消费</p><ol><li><h3 id="重平衡的影响"><a href="#重平衡的影响" class="headerlink" title="重平衡的影响"></a>重平衡的影响</h3></li><li><p><strong>消费暂停</strong>：在重平衡期间，整个消费者组会停止消费</p></li><li><p><strong>性能影响</strong>：频繁重平衡会导致消费延迟和吞吐量下降</p></li><li><p><strong>重复消费</strong>：可能因为offset提交时机导致消息重复消费</p></li><li><h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3></li><li><p>合理设置会话超时：</p></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Properties"><span class="hljs-attr">session.timeout.ms</span>=<span class="hljs-string">30000  # 默认30秒</span><br><span class="hljs-attr">heartbeat.interval.ms</span>=<span class="hljs-string">3000  # 心跳间隔</span><br></code></pre></td></tr></table></figure><ol><li>使用静态组成员（Kafka 2.3+）</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Properties"><span class="hljs-attr">group.instance.id</span>=<span class="hljs-string">consumer-1  # 静态成员ID</span><br></code></pre></td></tr></table></figure><ol><li>增量重平衡（Kafka 2.4+）<ol><li>只重新分配受影响的分区</li><li><strong>减少整个组的停顿时间</strong></li></ol></li><li><strong>避免频繁重启</strong>：使用优雅关闭</li></ol><h1 id="Kafka为何如此快"><a href="#Kafka为何如此快" class="headerlink" title="Kafka为何如此快"></a>Kafka为何如此快</h1><p><strong>Kafka 实现了</strong>**<code>零拷贝</code>**<strong>原理来快速移动数据</strong>，避免了内核之间的切换。Kafka 可以将数据记录分批发送，从生产者到文件系统（Kafka 主题日志）到消费者，可以端到端的查看这些批次的数据。</p><p>批处理能够进行更有效的数据压缩并减少 I&#x2F;O 延迟，Kafka 采取<strong>顺序写入磁盘</strong>的方式，避免了随机磁盘寻址的浪费；</p><p>总结一下其实就是四个要点</p><ul><li><strong>顺序写</strong></li><li><strong>零拷贝</strong></li><li><strong>消息压缩</strong></li><li><strong>批处理</strong></li></ul><ol><li><h3 id="顺序写"><a href="#顺序写" class="headerlink" title="顺序写"></a>顺序写</h3></li></ol><p><img src="/./../img/1765889363060-10.png" alt="img"></p><p><strong>append only 日志****末尾添加的机制</strong>,也就是每次有数据写入kafka,它是将数据message 添加到消息文件的末尾，从而实现磁盘顺序写的机制，</p><p><img src="/./../img/1765889363061-11.png" alt="img"></p><ol><li><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3></li></ol><blockquote><p><strong>DMA(Direct Memory Access，直接存储器访问)</strong> 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 <strong>CPU 的大量中断负载</strong> 。通俗来讲，就是DMA 传输将数据从一个地址空间复制到另外一个地址空间，当CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器来实行和完成，也就是两个硬件之间完成的，而没有CPU的参与，那么CPU就可以释放出来做别的事情，这样极大地提高了效率。</p></blockquote><p><img src="/./../img/1765889363061-12.png" alt="img"></p><p><strong>传统拷贝</strong>：</p><ol><li>我们可以清楚的看到共产生了4次copy，从磁盘文件到Kernal的相互读写是支持DMA copy的，但即使是这样，从Kernal到User没有硬件的支持所以不支持DMA，还有两次CPU copy。</li><li>Kafka只是把文件存放到磁盘之后通过网络发出去，中间并不需要修改什么数据，那read和write的两次CPU copy的操作完全是多余的。</li></ol><p><strong>零拷贝：</strong></p><blockquote><p><strong>Linux2.1</strong>内核开始引入了 <strong><code>sendfile</code></strong> 函数 (mmap)，用于将文件通过socket传送。</p><p><strong>Linux2.4内核开始引入了 sendfile 函数; 零拷贝</strong></p></blockquote><p><img src="/./../img/1765889363061-13.png" alt="img"></p><p><strong>操作系统</strong> &#x3D;&#x3D;&gt; JVM 提供零拷贝函数 &#x3D;&#x3D;&gt; Kafka调用函数;</p><p>JVM 提供<strong>零拷贝函数</strong> : <code>NIO（New IO）</code>（Buffer、Selector、Channel）</p><p>file.transferTo(file2)：底层直接零拷贝</p><p><code>IO</code>：Input Output；</p><ol><li><h3 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h3></li></ol><blockquote><p>压缩消息可以<strong>节省网络带宽</strong>。从而提高吞吐量</p></blockquote><p><img src="/./../img/1765889363061-14.png" alt="img"></p><ol><li><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3></li></ol><blockquote><p>导致丢消息</p></blockquote><p><img src="/./../img/1765889363061-15.png" alt="img"></p><p><img src="/./../img/1765889363061-16.png" alt="img"></p><p><strong>消息达到最大数量、或者最大内存、或者最长时间，都会被全部发出去</strong></p><h1 id="kafka如何保证消息不丢失"><a href="#kafka如何保证消息不丢失" class="headerlink" title="kafka如何保证消息不丢失"></a><strong>kafka如何保证消息不丢失</strong></h1><ol><li><h3 id="Producer端"><a href="#Producer端" class="headerlink" title="Producer端"></a><strong>Producer端</strong></h3></li></ol><p>要保证消息不丢失，第一点要做的就是要保证消息从producer端发送到了kafka的broker中，并且broker把消息保存了下来。 由于在发送消息的过程中有可能会发生<strong>网络故障，broker故障</strong>等原因导致消息发送失败，因此在producer端有两种方式来避免消息丢失。</p><ol><li><h4 id="接收发送消息回执"><a href="#接收发送消息回执" class="headerlink" title="接收发送消息回执"></a><strong>接收发送消息回执</strong></h4></li></ol><p>我们在使用kafka发送消息的时候，通常是使用<code>producer.send(msg)</code>方法，但是这个方法其实是一种异步发送，调用此方法发送消息的时候，虽然会立即返回，但是并不代表消息真的发送成功了。 1、*<em>所以可以使用同步发送消息，</em><em>**<code>producer.send(msg).get()</code><strong><strong>此方法会执行同步发生消息，并等待结果返回</strong>。 2、<strong>也可以使用带回调函数的异步方法，</strong></strong><code>producer.send(msg,callback)</code>**</em><em>，用回调函数来监听消息的发送结果，如果发送失败了，可以在回调函数里面进行重试。</em>*</p><ol><li><h4 id="producer参数配置"><a href="#producer参数配置" class="headerlink" title="producer参数配置"></a><strong>producer参数配置</strong></h4></li></ol><p>producer也提供了一些配置参数来避免消息丢失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 此配置表示，Leader和Follower全部成功接收消息后才确认收到消息，</span><br><span class="hljs-comment">// 可以最大限度保证消息不丢失，但是吞吐量会下降</span><br>acks = -<span class="hljs-number">1</span> <br><span class="hljs-comment">// producer 发送消息失败后，自动重试次数</span><br>retries = <span class="hljs-number">3</span><br><span class="hljs-comment">// 发送消息失败后的重试时间间隔</span><br>retry.backoff.ms = <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><ol><li><h3 id="Broker端"><a href="#Broker端" class="headerlink" title="Broker端"></a><strong>Broker端</strong></h3></li></ol><p>当消息发送到broker后，broker需要保证此消息不会丢失，我们都知道，kafka是会将消息持久化到磁盘中的。 但是kafka为了保持性能采用了，<strong><code>页缓存+异步刷盘</code></strong> 的形式将消息持久化到磁盘的。也就是批量定时将消息持久化到磁盘。 <strong>但是页缓存如果还没来的及将消息刷到磁盘，broker就挂了，还是会有消息丢失的风险，因此kafka又提供了partition的</strong><strong><code>ISR（同步副本机制）</code></strong>，即每一个patrtition都会有一个唯一的Leader和一到多个Follower，Leader专门处理一些事务类型的请求，Follower负责同步Leader的数据。当leader挂了后，会重新从Follower中选举出新的Leader，保证消息能够最终持久化。</p><p>另外，在producer中的配置参数<code>acks</code>,配置不同的值，broker也是会做不同的处理的。</p><blockquote><p><strong><code>acks=0</code></strong>:表示Producer请求立即返回，不需要等待Leader的任何确认。这种方案有最高的吞吐率，但是不保证消息是否真的发送成功。 <strong><code>acks =-1</code></strong>: 表示分区Leader必须等待消息被成功写入到所有的ISR副本(同步副本)中才认为Producer请求成功。这种方案提供最高的消息持久性保证，但是理论上吞吐率也是最差的。 <strong><code>acks=1</code></strong>: 表示Leader副本必须应答此Producer请求并写入消息到本地日志，之后Producer请求被认为成功。如果此时Leader副本应答请求之后挂掉了，消息会丢失。这个方案，提供了不错的持久性保证和吞吐。</p></blockquote><ol><li><h3 id="Consumer端"><a href="#Consumer端" class="headerlink" title="Consumer端"></a><strong>Consumer端</strong></h3></li></ol><p><strong>Consumer端，只要保证消息接收到不胡乱的提交offset就行</strong>，kafka本身也是会记录每个pratition的偏移量，但是为了业务的可靠性，最好在确认消费消息后，提交偏移量；默认是拿到消息，就自动提交偏移量</p><p>为了避免消息丢失，建议使用**手动提交偏移量的方式，**防止消息的业务逻辑未处理完，提交偏移量后消费者挂了的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">enable.auto.commit=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h1 id="kafka如何保证消息顺序消费"><a href="#kafka如何保证消息顺序消费" class="headerlink" title="kafka如何保证消息顺序消费"></a><strong>kafka如何保证消息顺序消费</strong></h1><p><strong><code>顺序发送</code></strong> <strong>+</strong> <strong><code>顺序存储</code></strong> <strong>+</strong> <strong><code>顺序消费</code></strong></p><ol><li><h3 id="顺序发送"><a href="#顺序发送" class="headerlink" title="顺序发送"></a>顺序发送</h3></li></ol><p>具体实现顺序发送消息有两种方式： <strong>1、在使用kafka时，对需要保证顺序消费的topic，只创建一个partition，这样消息就都会顺序的存储到这*一个partition中，也就能保证顺序消费了。</strong> <strong>2、当一个topic有多个partition时，对需要保证顺序的消息，都**<strong>发到指定的partition即可</strong></strong>，这样也能保证顺序消费。</p><ol><li><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a><strong><code>顺序存储</code></strong></h3></li></ol><p>Kafka 会按照<strong>消息发送顺序进行顺序存储</strong>；但是一定是单发送者。</p><p>多发送者不能保证消息抵达Kafka的顺序</p><ol><li><h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3></li></ol><p>在消费端，要保证顺序消费，单线程处理消息即可</p><h1 id="kafka如何保证消息不重复消费【幂等性】"><a href="#kafka如何保证消息不重复消费【幂等性】" class="headerlink" title="kafka如何保证消息不重复消费【幂等性】"></a><strong>kafka如何保证消息不重复消费【<strong><strong>幂等性</strong></strong>】</strong></h1><ol><li><h3 id="什么情况下会导致消息被重复消费呢？"><a href="#什么情况下会导致消息被重复消费呢？" class="headerlink" title="什么情况下会导致消息被重复消费呢？"></a><strong>什么情况下会导致消息被重复消费呢？</strong></h3></li><li><p><strong>生产者</strong>，生产者可能重复推送了一条消息到kafka，例如：某接口未做幂等处理，接口中会发送kafka消息</p></li><li><p>**kafka：**在消费者消费完消息后，提交offset时，kafka突然挂了，导致kafka认为此消息还未消费，又重新推送了该条消息，导致了重复消费消息。</p></li><li><p><strong>消费者</strong>，在消费者消费完消息后，提交offset时，Consumer突然宕机挂掉，这个时候，kafka未接收到已处理的offset值，当Consumer恢复后，<strong>会重新消费此部分消息</strong>。</p></li></ol><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  <strong>所有的都是消费端保证幂等性(消息执行的历史记录表)即可</strong> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><ol><li>还有一种情况，Kafka 存在 <strong>Partition ReBalance</strong> 机制，会将多个 Partition 均衡分配给多个消费者。若 <strong>Consumer 在默认 5 分钟内未处理完一批消息</strong>，会触发 Rebalance 机制，导致 offset 自动提交失败，重新 Rebalance 后，消费者会从之前未提交的 offset 位置开始消费，从而造成消息重复消费。（消费者数量变化等也会导致重平衡）</li></ol><p>重平衡（有可能是<strong>消费者慢</strong>（假掉线），导致<strong>重平衡，offset没来及提交，kafka会重复投递消息给别的消费者</strong>）</p><ol><li><h3 id="如何避免重复消费"><a href="#如何避免重复消费" class="headerlink" title="如何避免重复消费"></a>如何避免重复消费</h3></li></ol><p>其实上面的<code>1、2、3、4</code>这些情况都可以用<strong>幂等机制</strong>来防止消息被重复消费。</p><p><strong>为消息生成 一个唯一标识，并保存到 mysql 或 redis 中，处理消息前先到 mysql 或 redis 中判断该消息是否已被消费过</strong>。</p><p>但是<strong>第4种</strong>情况，前提是要先优化<strong>消费端处理性能，<strong><strong><code>避免触发 Rebalance</code></strong></strong>。额外的方案</strong></p><p>例如：</p><ol><li><code>采用异步方式处理消息</code></li><li><code>缩短单个消息消费时长</code></li><li><code>调整消息处理超时时间</code>(5min、10min)</li><li><code>减少一次性从 Broker 拉取的数据条数等。</code>  10000条</li></ol><blockquote><p>从0开始做；</p></blockquote><h1 id="服务降级熔断"><a href="#服务降级熔断" class="headerlink" title="服务降级熔断"></a>服务降级熔断</h1><h2 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h2><p>OK，我们从服务雪崩开始讲起！假设存在如下调用链</p><p>而此时，<code>Service A</code>的流量波动很大，流量经常会突然性增加！那么在这种情况下，就算<code>Service A</code>能扛得住请求，<code>Service B</code>和<code>Service C</code>未必能扛得住这突发的请求。<br>此时，如果<code>Service C</code>因为抗不住请求，变得不可用。那么<code>Service B</code>的请求也会阻塞，慢慢耗尽<code>Service B</code>的线程资源，<code>Service B</code>就会变得不可用。紧接着，<code>Service A</code>也会不可用，这一过程如下图所示</p><p>如上图所示，一个服务失败，导致整条链路的服务都失败的情形，我们称之为服务雪崩。</p><p><code>ps：</code>谁发明的这个词，真是面试装13必备！</p><p>那么，<strong>服务熔断</strong>和<strong>服务降级</strong>就可以视为解决服务雪崩的手段之一。</p><h1 id="1-服务降级"><a href="#1-服务降级" class="headerlink" title="1. 服务降级"></a>1. 服务降级</h1><p>1.1 定义</p><p>服务降级是指在系统部分功能出现异常或负载过高时，主动降低某些非核心功能的质量或直接停止这些功能，以保证核心功能的正常运行。其核心思想是“优先保障核心服务”。</p><p>1.2目的</p><ol><li><strong>保障核心功能</strong>：在系统资源有限的情况下，优先保障对用户和业务最重要的功能。</li><li><strong>提高系统可用性</strong>：通过降低非核心功能的质量，释放资源给核心功能，防止系统全面崩溃。</li><li><strong>改善用户体验</strong>：即使在系统压力较大的情况下，也能为用户提供基本可用的服务。</li></ol><p>1.3 实现策略</p><ol><li><strong>功能降级</strong>：直接关闭一些不重要的功能或特性。例如，电商网站在大促期间可能会关闭一些复杂的推荐算法。</li><li><strong>质量降级</strong>：降低服务的质量或精度。例如，降低图片的分辨率或减少数据的刷新频率。</li><li><strong>异步处理</strong>：将一些实时性要求不高的功能改为异步处理，例如，将订单确认邮件的发送改为异步任务。</li></ol><p>1.4 实施步骤</p><ol><li><strong>识别核心与非核心功能</strong>：明确系统中的核心功能和非核心功能。</li><li><strong>设定降级策略</strong>：为不同的非核心功能设定相应的降级策略。</li><li><strong>监控与触发</strong>：通过监控系统的运行状态，自动或手动触发降级策略。</li><li><strong>恢复机制</strong>：在条件允许的情况下，自动或手动恢复被降级的服务。</li></ol><h1 id="2-服务熔断"><a href="#2-服务熔断" class="headerlink" title="2. 服务熔断"></a>2. 服务熔断</h1><p>2.1 定义</p><p>服务熔断是一种保护机制，用于防止系统在某些服务出现问题时，影响到整个系统的稳定性。其灵感来源于电力系统中的熔断器，当电路出现过载时，熔断器会自动切断电路以保护整个系统。</p><p>2.2 目的</p><ol><li><strong>防止故障蔓延</strong>：当某个服务出现故障时，防止其影响扩大到其他服务。</li><li><strong>快速失败和恢复</strong>：通过快速失败，减少资源消耗，并在服务恢复后快速恢复正常状态。</li><li><strong>提高系统稳定性</strong>：通过隔离故障，保证其他服务的正常运行。</li></ol><p>2.3 实现策略</p><ol><li><strong>熔断器模式</strong>：实现熔断器的三种状态：关闭、打开和半开。<ul><li><strong>关闭状态</strong>：正常请求通过。</li><li><strong>打开状态</strong>：请求快速失败，直接返回错误。</li><li><strong>半开状态</strong>：允许部分请求通过，以检测服务是否恢复。</li></ul></li><li><strong>熔断条件</strong>：设定触发熔断的条件，例如请求失败率超过一定阈值。</li><li><strong>恢复策略</strong>：设定从打开状态到半开状态的条件，例如经过一段时间后自动进入半开状态。</li></ol><p>2.4 实施步骤</p><ol><li><strong>设定熔断条件</strong>：根据业务需求设定触发熔断的条件。</li><li><strong>实现熔断器逻辑</strong>：在服务调用链中实现熔断器的逻辑。</li><li><strong>监控与调整</strong>：持续监控熔断器的状态，并根据实际情况调整熔断条件。</li></ol><h1 id="3-服务限流"><a href="#3-服务限流" class="headerlink" title="3. 服务限流"></a>3. 服务限流</h1><p>3.1 定义</p><p>服务限流是指通过限制系统处理请求的速率，来保护系统资源，防止系统过载。限流策略通常用于防止突发流量对系统的冲击。</p><p>3.2 目的</p><ol><li><strong>防止系统过载</strong>：通过限制请求速率，防止系统资源被耗尽。</li><li><strong>保障服务稳定性</strong>：在高并发情况下，保证服务的稳定性和响应速度。</li><li><strong>提高用户体验</strong>：通过平滑处理请求，避免因系统过载导致的服务不可用。</li></ol><p>3.3 实现策略</p><ol><li><strong>令牌桶算法</strong>：通过令牌的生成和消费来控制请求的速率。</li><li><strong>漏桶算法</strong>：通过固定速率的请求处理，平滑突发流量。</li><li><strong>计数器算法</strong>：在固定时间窗口内限制请求数量。</li></ol><p>3.4 实施步骤</p><ol><li><strong>确定限流目标</strong>：识别需要限流的服务或接口。</li><li><strong>选择限流算法</strong>：根据业务需求选择合适的限流算法。</li><li><strong>配置限流参数</strong>：设定限流的阈值和策略。</li><li><strong>监控与优化</strong>：监控限流效果，并根据需要进行优化和调整。</li></ol><h1 id="4-综合应用"><a href="#4-综合应用" class="headerlink" title="4. 综合应用"></a>4. 综合应用</h1><p>在实际应用中，服务降级、服务熔断和服务限流常常结合使用，以应对复杂的系统问题和不确定性。通过合理的策略组合，可以有效提高系统的鲁棒性和可用性。</p><ol><li><strong>降级与限流结合</strong>：在流量高峰期，通过限流保护系统，并通过降级保证核心功能的可用性。</li><li><strong>熔断与降级结合</strong>：当某个服务触发熔断后，通过降级策略保证其他服务的正常运行。</li><li><strong>熔断与限流结合</strong>：在熔断器恢复过程中，通过限流控制请求速率，防止服务再次过载。</li></ol><p>为什么有了服务降级还需要服务熔断？</p><p>这里我们总结了4个核心理由：</p><ol><li>避免资源浪费：当一个服务出现故障时，如果没有熔断机制，系统可能会持续不断地尝试调用这个失败的服务，导致请求积压和资源耗尽。服务熔断通过快速失败，避免了不必要的调用，节省了宝贵的系统资源。</li><li>防止级联故障：在微服务架构中，服务之间通常相互依赖。如果一个服务出现问题，持续的失败调用可能会影响到依赖它的其他服务，导致级联故障。服务熔断器可以在问题初期及时切断受影响的服务调用，防止故障扩散到整个系统。</li><li>加速系统恢复：通过熔断机制，系统能够更快地检测到服务的故障状态，并在熔断器打开后，等待一段时间再尝试恢复调用。这有助于目标服务有足够的时间进行自我修复，从而加速整个系统的恢复过程。</li><li>提供更好的用户体验： 服务降级虽然能够保证核心功能的可用性，但在高负载或持续失败的情况下，用户可能会频繁遇到降级后的功能或默认响应，影响使用体验。服务熔断器通过控制调用频率和恢复策略，能够在保证必要降级的同时，减少对用户的负面影响。</li></ol><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>45Springboot</title>
    <link href="/2025/11/25/46SpringBoot/"/>
    <url>/2025/11/25/46SpringBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="z自动配置"><a href="#z自动配置" class="headerlink" title="z自动配置"></a>z自动配置</h1><p><strong>Spring Boot</strong> 的自动装配是一个核心功能，它允许开发者快速集成和使用各种启动器（starter）和库，而无需进行繁琐的配置。自动装配的原理基于 <strong>Spring Framework</strong> 的条件注解和 <strong>Spring Boot</strong> 的启动器。</p><p>自动装配的工作流程</p><p>自动装配的过程从 <strong>Spring Boot</strong> 的主程序类开始，这个类通常使用 <em>@SpringBootApplication</em> 注解。这个注解是一个组合注解，它包括 <em>@SpringBootConfiguration</em>、<em>@EnableAutoConfiguration</em> 和 <em>@ComponentScan</em>。这些注解共同工作，实现了自动装配的基础功能。</p><ul><li><em>@SpringBootConfiguration</em>：标识这是一个 <strong>Spring Boot</strong> 的配置类。</li><li><em>@ComponentScan</em>：扫描并加载使用注解定义的 <strong>bean</strong>。</li><li><em>@EnableAutoConfiguration</em>：告诉 <strong>Spring Boot</strong> 开始根据类路径下的 <strong>jar</strong> 包依赖以及各种配置类来自动配置项目。</li></ul><p><em>@EnableAutoConfiguration</em> 是自动装配的关键，它通过 <em>@Import(AutoConfigurationImportSelector.class)</em> 导入了 <em>AutoConfigurationImportSelector</em> 类。这个类负责读取 <em>META-INF&#x2F;spring.factories</em> 文件中的配置，并根据条件注解（如 <em>@ConditionalOnClass</em>、<em>@ConditionalOnBean</em> 等）决定哪些配置类应该被加载到 <strong>Spring</strong> 容器中。</p><p>条件注解的作用</p><p>条件注解是自动装配过程中的重要组成部分，它们决定了在什么条件下某个配置类或 <strong>bean</strong> 应该被创建和加载。例如，<em>@ConditionalOnClass</em> 注解确保只有当类路径下存在特定的类时，相关的自动配置类才会被激活。</p><p>自动装配的优势</p><p>自动装配的优势在于它极大地简化了项目的配置和依赖管理。开发者只需要添加相应的 <strong>starter</strong> 依赖，如 <em>spring-boot-starter-web</em>，就可以快速开始开发 <strong>Web</strong> 应用，无需手动配置 <strong>DispatcherServlet</strong> 或 <strong>Tomcat</strong>。</p><p>自定义 Starter 的开发</p><p>开发者还可以创建自己的 <strong>starter</strong>，以便在多个项目中重用配置和功能。自定义 <strong>starter</strong> 通常包括一个自动配置类，它使用 <em>@Configuration</em> 和条件注解来定义需要自动配置的 <strong>bean</strong>。此外，还需要在 <em>META-INF&#x2F;spring.factories</em> 文件中声明这个自动配置类，以便 <strong>Spring Boot</strong> 能够在启动时加载它。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="怎么理解SpringBoot中的约定大于配置"><a href="#怎么理解SpringBoot中的约定大于配置" class="headerlink" title="怎么理解SpringBoot中的约定大于配置"></a>怎么理解SpringBoot中的约定大于配置</h2><p>它通过预设标准化的默认行为与项目规范,大幅减少开发者的手动配置,从而提升开发效率</p><p>(1)自动配化配置SpringBoot的自动化配置会基于项目依赖和运行环境,自动完成组件的初始化与集成.例如:引入spirng-boot-starter-web后,框架会自动检测Web开发依赖,进而配置内嵌Tomcat、Spring MVC的DispatcherServlet等组件</p><p>(2)默认配置SpringBoot为数据库连接、Web服务、日志、安全等场景提供最佳实践级的默认配置</p><p>Web应用默认内嵌Tomcat(8080);数据库连接默认采用性能优异的HikariCP连接池;日志默认通过logback输出Spring Data JPA默认开启事务管理,Spring Security提供基础HTTP安全防护</p><p>(3)项目结构约定SpringBoot提倡分层化的项目结构约定,Controller,Service,Mapper等</p><h2 id="说几个启动器-starter"><a href="#说几个启动器-starter" class="headerlink" title="说几个启动器(starter)"></a>说几个启动器(starter)</h2><p>spring-boot-starter-web: 这是最常见的起步依赖之一.它包含了Spring MVC和Tomcat嵌入式服务器,用于快速构建Web应用程序</p><p>spring-boot-starter_security: 提供了Spring Security的基本配置,帮助开发者快速实现应用的安全性,包括认证和授权功能</p><p>mybatis-spring-boot-starter: 这个Starter是由MyBatis团队提供的,用于简化在SpringBoot应用中集成MyBatis的过程,它自动配置了MyBatis的相关组件</p><p>spring-boot-starter-jdbc: 提供了基本的JDBC支持,可以通过在配置文件中配置MySQL的连接信息完成与数据库的交互</p><p>spring-boot-starter-data-redis: 用于集成Redis缓存和数据存储服务.</p><p>spring-boot-starter-test: 包含了单元测试和集成测试所需的库.</p><h1 id="ljjgkq"><a href="#ljjgkq" class="headerlink" title="ljjgkq"></a>ljjgkq</h1><p><img src="/./../img/1763817899877-f26d1175-73a1-4228-aba9-6023d139ee35.webp" alt="image.png"></p><p><img src="/./../img/image-20251127134709987.png" alt="image-20251127134709987"></p><h3 id="现自己的SpringBoot-Starter"><a href="#现自己的SpringBoot-Starter" class="headerlink" title="现自己的SpringBoot Starter"></a>现自己的SpringBoot Starter</h3><p><img src="/./../img/image-20251127173204721.png" alt="image-20251127173204721"></p><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>命名规范&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h4><p>如果你快有孩子了，出生前你比较急的一定是起个名字。孩子的姓名标识着你和你爱人的血统，一定不会起隔壁老王的姓氏，肯定会招来异样的眼光。在<code>maven</code>中，<code>groupId</code>代表着姓氏，<code>artifactId</code>代表着名字。<code>Spring Boot</code>也是有一个命名的建议的。所以名字是不能够随随便便取得，可以按照官方的建议来取。</p><blockquote><p>What’s in a name<br>All official starters follow a similar naming pattern; spring-boot-starter- <em>, where</em> is a particular type of application. This naming structure is intended to help when you need to find a starter. The Maven integration in many IDEs lets you search dependencies by name. For example, with the appropriate Eclipse or STS plugin installed, you can press ctrl-space in the POM editor and type “spring-boot-starter” for a complete list.<br>As explained in the “Creating Your Own Starter” section, third party starters should not start with spring-boot, as it is reserved for official Spring Boot artifacts. Rather, a third-party starter typically starts with the name of the project. For example, a third-party starter project called thirdpartyproject would typically be named thirdpartyproject-spring-boot-starter.</p></blockquote><p>大概意思是<br>官方的 <code>starter</code> 的命名格式为 <code>spring-boot-starter-&#123;xxxx&#125;</code> 比如<code>spring-boot-starter-activemq</code><br>第三方我们自己的命名格式为 <code>&#123;xxxx&#125;-spring-boot-starter</code>。比如<code>mybatis-spring-boot-starter</code>。<br>如果我们忽略这种约定，是不是会显得我们写的东西不够“专业“。</p><h4 id="自定义一个Starter"><a href="#自定义一个Starter" class="headerlink" title="自定义一个Starter"></a>自定义一个Starter</h4><p>下面我们就来实现一个自定义的发送短信的starter，命名为<code>sms-spring-boot-starter</code>。</p><ol><li>引入<code>pom</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><p>编写配置文件</p><p>发短信我们需要配置一些账号信息，不同的短信供应商，账户信息是不一样的，所以我们需要定义一个XXXXProperties 来自动装配这些账户信息。下面我们就以腾讯云和阿里云两家供应商为例；</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;sms&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsProperties</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SmsMessage</span> <span class="hljs-variable">aliyun</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmsMessage</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SmsMessage</span> <span class="hljs-variable">tencent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmsMessage</span>();<br><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsMessage</span>&#123;<br><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 用户名</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> String userName;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 密码</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> String passWord;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 秘钥</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> String sign;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> String url;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SmsMessage&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;userName=&#x27;&quot;</span> + userName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&quot;, passWord=&#x27;&quot;</span> + passWord + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&quot;, sign=&#x27;&quot;</span> + sign + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&quot;, url=&#x27;&quot;</span> + url + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要在其他项目中使用发送短信功能的话，我们只需要在配置文件(application.ym）中配置SmsProperties 的属性信息就可以了。 比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">sms:<br>  aliyun:<br>    pass-word: <span class="hljs-number">12345</span><br>    user-name: java金融<br>    sign: 阿里云<br>    url: http:<span class="hljs-comment">//aliyun.com/send</span><br>  tencent:<br>    pass-word: <span class="hljs-number">6666</span><br>    user-name: java金融<br>    sign: 腾讯云<br>    url: http:<span class="hljs-comment">//tencent.com/send</span><br></code></pre></td></tr></table></figure><p>还记的<code>@ConfigurationProperties</code>注解里面是不是有个<code>prefix</code> 属性，我们配置的这个属性是<code>sms</code>，配置这个的主要一个作用的话是主要用来区别各个组件的参数。这里有个小知识点需要注意下当我们在配置文件输入sms我们的<code>idea</code>会提示这个<code>sms</code>有哪些属性可以配置，以及每个属性的注释都有标记，建议的话注释还是写英文，这样会显得你比较专业。<br><img src="/./../img/format,webp.webp" alt="在这里插入图片描述"><br>这个提示的话，是需要引入下面这个jar的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引入这个jar之后，我们编译之后就会在META-INF文件夹下面生成一个spring-configuration-metadata.json的文件。<br><img src="/./../img/format,webp-1764168677254-9.webp" alt="在这里插入图片描述"><br>我们可以看到这个文件其实 是根据SmsProperties类的成员属性来生成的。</p><ol><li>然后在编写短信自动配置类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableConfigurationProperties(value = SmsProperties.class)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsAutoConfiguration</span>  &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  阿里云发送短信的实现类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> smsProperties</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> AliyunSmsSenderImpl <span class="hljs-title function_">aliYunSmsSender</span><span class="hljs-params">(SmsProperties smsProperties)</span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AliyunSmsSenderImpl</span>(smsProperties.getAliyun());<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 腾讯云发送短信的实现类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> smsProperties</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TencentSmsSenderImpl <span class="hljs-title function_">tencentSmsSender</span><span class="hljs-params">(SmsProperties smsProperties)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TencentSmsSenderImpl</span>(smsProperties.getTencent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="./../img/image-20251127173252045.png" alt="image-20251127173252045" style="zoom:50%;" /><p>编写我们的发送短信实现类：（功能类）</p><img src="./../img/image-20251127173146276.png" alt="image-20251127173146276" style="zoom: 25%;" /><img src="./../img/image-20251127173738008.png" alt="image-20251127173738008" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliyunSmsSenderImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmsSender</span> &#123;<br><br>    <span class="hljs-keyword">private</span> SmsMessage smsMessage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AliyunSmsSenderImpl</span><span class="hljs-params">(SmsMessage smsProperties)</span> &#123;<br>        <span class="hljs-built_in">this</span>.smsMessage = smsProperties;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(smsMessage.toString()+<span class="hljs-string">&quot;开始发送短信==》短信内容：&quot;</span>+message);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>让starter生效</li></ol><p>starter集成应用有两种方式：</p><ul><li>被动生效</li></ul><p>我们首先来看下我们熟悉的方式，通过SpringBoot的SPI的机制来去加载我们的starter。我们需要在META-INF下新建一个spring.factories文件key为org.springframework.boot.autoconfigure.EnableAutoConfiguration， value是我们的SmsAutoConfiguration 全限定名（记得去除前后的空格，否则会不生效）。</p><p><img src="/./../img/image-20251127173319395.png" alt="image-20251127173319395"></p><p><img src="/./../img/format,webp-1764168677254-10.webp" alt="在这里插入图片描述"></p><ul><li>主动生效</li></ul><p>在starter组件集成到我们的Spring Boot应用时需要主动声明启用该starter才生效，通过自定义一个@Enable注解然后在把自动配置类通过Import注解引入进来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(&#123;SmsAutoConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableSms &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的时候需要在启动类上面开启这个注解。<br><img src="/./../img/format,webp-1764168677254-11.webp" alt="在这里插入图片描述"></p><ol><li><p>打包，部署到仓库<br>如果是本地的话，直接通过mvn install命令就可以了。<br>如果需要部署到公司的仓库话，这个就不说了。</p></li><li><p>新建一个新的SpringBoot项目引入我们刚写的starter</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>           &lt;groupId&gt;com.workit.sms&lt;/groupId&gt;<br>           &lt;artifactId&gt;sms-spring-boot-starter&lt;/artifactId&gt;<br>           &lt;version&gt;<span class="hljs-number">0.0</span><span class="hljs-number">.1</span>-SNAPSHOT&lt;/version&gt;<br>     &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>在项目配置文件配上短信账号信息<br><img src="/./../img/format,webp-1764168677254-12.webp" alt="在这里插入图片描述"><br>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableSms</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoconfigApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> SpringApplication.run(AutoconfigApplication.class, args);<br>        <span class="hljs-type">AliyunSmsSenderImpl</span> <span class="hljs-variable">aliyunSmsSender</span> <span class="hljs-operator">=</span> applicationContext.getBean(AliyunSmsSenderImpl.class);<br>        aliyunSmsSender.send(<span class="hljs-string">&quot;用阿里云发送短信&quot;</span>);<br>        <span class="hljs-type">TencentSmsSenderImpl</span> <span class="hljs-variable">tencentSmsSender</span> <span class="hljs-operator">=</span> applicationContext.getBean(TencentSmsSenderImpl.class);<br>        tencentSmsSender.send(<span class="hljs-string">&quot;用腾讯云发送短信&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">SmsMessage&#123;userName=<span class="hljs-string">&#x27;java金融&#x27;</span>, passWord=<span class="hljs-string">&#x27;12345&#x27;</span>, sign=<span class="hljs-string">&#x27;阿里云&#x27;</span>, url=<span class="hljs-string">&#x27;http://aliyun.com/send&#x27;</span>&#125;开始发送短信==》短信内容：用阿里云发送短信<br>SmsMessage&#123;userName=<span class="hljs-string">&#x27;java金融&#x27;</span>, passWord=<span class="hljs-string">&#x27;6666&#x27;</span>, sign=<span class="hljs-string">&#x27;腾讯云&#x27;</span>, url=<span class="hljs-string">&#x27;http://tencent.com/send&#x27;</span>&#125;开始发送短信==》短信内容：用腾讯云发送短信<br></code></pre></td></tr></table></figure><p>至此的话我们自定义的一个starter就已经完成了，这个starter只是一个演示的demo，代码有点粗糙。重点看下这个实现原理就好。<br><a href="https://www.cnblogs.com/tjudzj/p/8758391.html">https://www.cnblogs.com/tjudzj/p/8758391.html</a></p><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>102各种问题</title>
    <link href="/2025/11/24/102%E9%97%AE%E9%A2%98/"/>
    <url>/2025/11/24/102%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-你们本地部署大模型具体的配置-参数是怎样的"><a href="#1-你们本地部署大模型具体的配置-参数是怎样的" class="headerlink" title="1.你们本地部署大模型具体的配置 参数是怎样的"></a>1.你们本地部署大模型具体的配置 参数是怎样的</h1><p>​我们本地部署的是 Ollama + DeepSeek-R1 7B 的组合，主要作为审核和情感分析模型使用。<br>​部署环境是：<br>​8 核 CPU + 32G 内<br>​一块 3090 24G 显存的 GPU                   —–显卡的型号<br>​Ollama 启动参数中配置：<br>​num_gpu: 1<br>​num_ctx（上下文长度）: 4096（保证标题、简介字段能完整输入）<br>​num_thread: 自动（由 Ollama 自动根据 CPU 核数分配）<br>​我们通过 Spring AI 统一封装模型调用，使 Camunda 的 JavaDelegate 能够直接调用审核接口</p><h1 id="2-ai审核只能审核短剧标题和简介吗，不能审核短剧内容吗"><a href="#2-ai审核只能审核短剧标题和简介吗，不能审核短剧内容吗" class="headerlink" title="2.ai审核只能审核短剧标题和简介吗，不能审核短剧内容吗"></a>2.ai审核只能审核短剧标题和简介吗，不能审核短剧内容吗</h1><p>​视频内容审核属于多模态识别，需要视频帧抽取、ASR、行为识别，这部分我们没有在本地做，因为算力成本太高。<br>​我们的 AI 审核分两层：<br>​1,文本审核（本地模型）<br>​标题、简介、标签<br>​情感分析、涉政涉黄、违规用语<br>​2,视频内容审核（外部平台）<br>​通过腾讯云 VOD 的内容审核能力，它会：<br>​自动抽帧<br>​识别黄暴、暴力、广告等内容<br>​审核回调直接进入 Camunda 流程<br>​因此我们的审核对标题&#x2F;简介&#x2F;图片&#x2F;视频内容都是覆盖的，只是负责的模块不一样。</p><h1 id="3-你说你们是多租户，是怎么实现数据隔离的，a公司不能看到公司的数据吧"><a href="#3-你说你们是多租户，是怎么实现数据隔离的，a公司不能看到公司的数据吧" class="headerlink" title="3.你说你们是多租户，是怎么实现数据隔离的，a公司不能看到公司的数据吧"></a>3.你说你们是多租户，是怎么实现数据隔离的，a公司不能看到公司的数据吧</h1><p>​你的项目使用 Spring Cloud + 多租户平台，这里你这样回答：<br>​我们的多租户采用的是数据库级隔离+应用级租户上下文的组合方案。<br>​数据库层： 每张核心业务表都带 tenant_id 字段，MyBatis-Plus 通过自定义 TenantLineHandler 自动拼接<br>​WHERE tenant_id &#x3D; xxx<br>​实现物理隔离数据。<br>​应用层：<br>​用户登录后，Sa-Token 中写入 tenantId<br>​网关从 Token 解析后塞入请求头<br>​下游服务通过 ThreadLocal 的 TenantContext 保存租户信息<br>​MyBatis-Plus 自动替换租户 ID，不允许跨租户查询<br>​我们还做了 缓存隔离：<br>​Redis Key 前缀使用：<br>​video:{tenantId}:{videoId}<br>​保证缓存不串租户。</p><h1 id="4-短信接口你们有做防刷吗"><a href="#4-短信接口你们有做防刷吗" class="headerlink" title="4 短信接口你们有做防刷吗"></a>4 短信接口你们有做防刷吗</h1><p>​我们对短信验证码做了三层防刷策略：<br>​频控：<br>​同手机号 60 秒只能发 1 次<br>​同 IP 1 小时最多发 15 次<br>​Redis 用 INCR + EXPIRE 实现<br>​行为校验：<br>​前端接入滑块验证码<br>​黑名单池：<br>​自动记录异常频繁请求的 IP&#x2F;设备指纹<br>​Redis + TTL 自动衰减</p><h1 id="5-多次点击发布按钮，这一块有没有做什么安全措施"><a href="#5-多次点击发布按钮，这一块有没有做什么安全措施" class="headerlink" title="5.多次点击发布按钮，这一块有没有做什么安全措施"></a>5.多次点击发布按钮，这一块有没有做什么安全措施</h1><p>​在短剧发布这种关键操作上做了两种幂等保护：<br>​前端防重复点击：按钮 loading 状态锁定<br>​后端防重复提交（核心）：<br>​使用 Redis 分布式锁<br>​Key &#x3D; publish:{tenantId}:{videoId}<br>​TTL 设置 3 秒<br>​这样同一用户连续点击多次发布，只会执行一次流程。<br>​另外发布流程走 Camunda 工作流，本身也具备幂等校验，避免重复创建任务</p><h1 id="6-miniio有没有做集群部署-是怎么实现上传的，有没有断点续传之类的"><a href="#6-miniio有没有做集群部署-是怎么实现上传的，有没有断点续传之类的" class="headerlink" title="6.miniio有没有做集群部署 是怎么实现上传的，有没有断点续传之类的"></a>6.miniio有没有做集群部署 是怎么实现上传的，有没有断点续传之类的</h1><p>​MinIO 我们做了两种部署策略：<br>​开发环境：单节点 MinIO<br>​生产环境：MinIO 4 节点分布式集群<br>​EC（纠删码）为 4&#x2F;2<br>​&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;使用 Nginx 负载均衡访问<br>​上传流程使用的是 MinIO 官方的 Multipart Upload（分片上传） 接口：<br>​大文件自动分片<br>​支持断点续传<br>​上传完成后自动合并块<br>​我们这块会自动重试失败的 Part，因此对网络波动比较友好</p><h1 id="为什么要模拟-robot-账号登录-XXL-Job？不能直接调任务吗？"><a href="#为什么要模拟-robot-账号登录-XXL-Job？不能直接调任务吗？" class="headerlink" title="为什么要模拟 robot 账号登录 XXL-Job？不能直接调任务吗？"></a>为什么要模拟 robot 账号登录 XXL-Job？不能直接调任务吗？</h1><p>​为什么不直接调用 XXL-Job 的 openAPI？<br>​为什么要登录一个模拟账号？<br>​XXL-Job 的任务你们是怎么触发的？<br>参考话术<br>​我们不是从 XXL-JOB 控制台页面触发，而是通过它的 OpenAPI 接口触发任务执行。<br>​robot 账号只是为了权限隔离，便于区分是系统自动触发还是人工上传等操作触发。<br>​我们不会模拟点按钮，而是直接发 trigger&#x2F;run API 调任务。</p><h1 id="单机-Map-保存审核结果，会不会有线程安全-多实例问题？"><a href="#单机-Map-保存审核结果，会不会有线程安全-多实例问题？" class="headerlink" title="单机 Map 保存审核结果，会不会有线程安全&#x2F;多实例问题？"></a>单机 Map 保存审核结果，会不会有线程安全&#x2F;多实例问题？</h1><p>参考话术<br>Map 只在流程内部暂存，用于在同一Camunda 流程中传递，不用于跨节点通信。<br>需要跨任务传递的，我们会放到 Camunda 流程变量 或 Redis。<br>所以不会出现安全数据的问题。</p><h1 id="本地大模型审核-腾讯云视频审核，如果其中一个失败怎么办？"><a href="#本地大模型审核-腾讯云视频审核，如果其中一个失败怎么办？" class="headerlink" title="本地大模型审核 + 腾讯云视频审核，如果其中一个失败怎么办？"></a>本地大模型审核 + 腾讯云视频审核，如果其中一个失败怎么办？</h1><p>​如果大模型审核失败了呢？<br>​如果腾讯云审核回调延迟怎么办？<br>​两个审核不一致怎么处理？<br>参考话术：<br>​我们的审核采用 容错 + 兜底策略：<br>​本地大模型异常–&gt;走默认人工审核<br>​腾讯云视频审核异常–&gt;XXL-Job 会自动重试<br>​两者冲突–&gt;统一流入人工审核节点<br>​不会出现审核中断的情况。</p><h1 id="审核流程为何使用-Camunda？可不可以不用？"><a href="#审核流程为何使用-Camunda？可不可以不用？" class="headerlink" title="审核流程为何使用 Camunda？可不可以不用？"></a>审核流程为何使用 Camunda？可不可以不用？</h1><p>参考话术：<br>视频审核是一个多阶段的流程：<br>AI审核–&gt;视频内容审核–&gt;人工审核–&gt;审核结果汇总<br>使用 Camunda 的目的是：<br>把复杂流程可视化<br>状态和节点可追溯<br>人工审核可以暂停&#x2F;回退<br>多个审核结果汇总更清晰<br>如果不用工作流，自己维护状态机会非常混乱。</p><h1 id="XXL-Job-触发腾讯云上传任务，这里有没有幂等问题？"><a href="#XXL-Job-触发腾讯云上传任务，这里有没有幂等问题？" class="headerlink" title="XXL-Job 触发腾讯云上传任务，这里有没有幂等问题？"></a>XXL-Job 触发腾讯云上传任务，这里有没有幂等问题？</h1><p>最常问：<br>如果重复触发，视频会不会被上传两次？<br>话术：<br>我们做了两层幂等：<br>XXL-Job 任务使用业务 Id 作为参数，任务重复触发不会重复执行<br>腾讯云 VOD 上传使用唯一的 fileId，同一个源文件上传两次也不会重复转码<br>所以整体流程是天然幂等的。</p><h1 id="腾讯云回调是怎么和工作流衔接的？"><a href="#腾讯云回调是怎么和工作流衔接的？" class="headerlink" title="腾讯云回调是怎么和工作流衔接的？"></a>腾讯云回调是怎么和工作流衔接的？</h1><p>​回调怎么通知 Camunda？<br>​有没有延迟？<br>​如何保证一致性？<br>参考：<br>​腾讯云审核是异步的，我们在回调接口里更新审核状态，并通过 Camunda 的 RuntimeService 唤醒对应流程实例。<br>​如果回调超时，则自动进入人工审核节点。</p><h1 id="消息幂等性保证"><a href="#消息幂等性保证" class="headerlink" title="消息幂等性保证"></a>消息幂等性保证</h1><p><strong>方案1</strong>: Redis Set记录已处理消息ID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">doneKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;done:like:msg&quot;</span>;<br><span class="hljs-keyword">if</span> (redisTemplate.opsForSet().isMember(doneKey, msgId)) &#123;<br>    <span class="hljs-comment">// 消息已处理，直接ACK</span><br>    ack.acknowledge();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 处理业务逻辑</span><br>processBusiness(event);<br><br><span class="hljs-comment">// 记录消息ID</span><br>redisTemplate.opsForSet().add(doneKey, msgId);<br><br><span class="hljs-comment">// 手动ACK</span><br>ack.acknowledge();<br></code></pre></td></tr></table></figure><p><strong>方案2</strong>: 数据库唯一索引 + 幂等更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- user_likes表设计</span><br><span class="hljs-keyword">UNIQUE</span> KEY uk_user_target (user_id, target_id, target_type)<br><br><span class="hljs-comment">-- 幂等更新SQL</span><br><span class="hljs-keyword">UPDATE</span> user_likes <span class="hljs-keyword">SET</span> status <span class="hljs-operator">=</span> ? <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> ? <span class="hljs-keyword">AND</span> target_id <span class="hljs-operator">=</span> ? <span class="hljs-keyword">AND</span> target_type <span class="hljs-operator">=</span> ?<br></code></pre></td></tr></table></figure><hr><h2 id="最终一致性保证"><a href="#最终一致性保证" class="headerlink" title="最终一致性保证"></a>最终一致性保证</h2><p><strong>流程</strong>:</p><ol><li>用户点击点赞 → 发送Kafka消息 → 立即返回成功</li><li>Kafka消费者1（user-service）→ 更新Redis缓存</li><li>Kafka消费者2（interaction-service）→ 更新数据库</li><li>消息持久化 + 手动ACK → 保证消息不丢失</li><li>幂等性处理 → 重复消费结果一致</li></ol><p><strong>优势</strong>:</p><ul><li>降低接口响应时间（异步处理） </li><li>削峰填谷（高并发缓冲）</li><li>最终一致性（数据库与缓存同步）</li></ul><h1 id="双写一致性"><a href="#双写一致性" class="headerlink" title="双写一致性"></a>双写一致性</h1><p>用mq的手动ack机制确认，一个失败就不会ack</p><h2 id="C-常见问题FAQ"><a href="#C-常见问题FAQ" class="headerlink" title="C. 常见问题FAQ"></a>C. 常见问题FAQ</h2><p><strong>Q1: Kafka消息积压怎么办？</strong><br>A: 增加消费者实例数、优化消费逻辑、增加分区数</p><p><strong>Q2: Redis内存不足怎么办？</strong><br>A: 设置合理的过期时间、使用LRU淘汰策略、扩容Redis节点</p><p><strong>Q3: Camunda流程实例查询慢？</strong><br>A: 定期归档历史数据、优化数据库索引、使用缓存</p><p><strong>Q5: 布隆过滤器误判怎么办？</strong><br>A: 降低误判率（增大内存）、配合缓存空对象使用</p><h3 id="7-3-Kafka事件驱动架构"><a href="#7-3-Kafka事件驱动架构" class="headerlink" title="7.3 Kafka事件驱动架构"></a>7.3 Kafka事件驱动架构</h3><h4 id="7-3-1-生产者拦截器（自动填充公共字段）"><a href="#7-3-1-生产者拦截器（自动填充公共字段）" class="headerlink" title="7.3.1 生产者拦截器（自动填充公共字段）"></a>7.3.1 生产者拦截器（自动填充公共字段）</h4><p><strong>KafkaEventProducerInterceptor</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ProducerRecord&lt;String, Object&gt; <span class="hljs-title function_">onSend</span><span class="hljs-params">(ProducerRecord&lt;String, Object&gt; record)</span> &#123;<br>    <span class="hljs-type">BaseEvent</span> <span class="hljs-variable">baseEvent</span> <span class="hljs-operator">=</span> (BaseEvent) record.value();<br><br>    <span class="hljs-comment">// 自动填充msgId（雪花ID）</span><br>    baseEvent.setMsgId(IdUtil.getSnowflakeNextId());<br><br>    <span class="hljs-comment">// 自动填充userId（从Sa-Token获取）</span><br>    baseEvent.setUserId(StpUtil.getLoginIdAsLong());<br><br>    <span class="hljs-comment">// 自动填充timestamp</span><br>    baseEvent.setTimestamp(System.currentTimeMillis());<br><br>    <span class="hljs-keyword">return</span> record;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>效果</strong>: 业务代码只需构造核心业务字段，公共字段自动填充</p><hr><h4 id="7-3-2-消息幂等性保证"><a href="#7-3-2-消息幂等性保证" class="headerlink" title="7.3.2 消息幂等性保证"></a>7.3.2 消息幂等性保证</h4><p><strong>方案1</strong>: Redis Set记录已处理消息ID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">doneKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;done:like:msg&quot;</span>;<br><span class="hljs-keyword">if</span> (redisTemplate.opsForSet().isMember(doneKey, msgId)) &#123;<br>    <span class="hljs-comment">// 消息已处理，直接ACK</span><br>    ack.acknowledge();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 处理业务逻辑</span><br>processBusiness(event);<br><br><span class="hljs-comment">// 记录消息ID</span><br>redisTemplate.opsForSet().add(doneKey, msgId);<br><br><span class="hljs-comment">// 手动ACK</span><br>ack.acknowledge();<br></code></pre></td></tr></table></figure><p><strong>方案2</strong>: 数据库唯一索引 + 幂等更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- user_likes表设计</span><br><span class="hljs-keyword">UNIQUE</span> KEY uk_user_target (user_id, target_id, target_type)<br><br><span class="hljs-comment">-- 幂等更新SQL</span><br><span class="hljs-keyword">UPDATE</span> user_likes <span class="hljs-keyword">SET</span> status <span class="hljs-operator">=</span> ? <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> ? <span class="hljs-keyword">AND</span> target_id <span class="hljs-operator">=</span> ? <span class="hljs-keyword">AND</span> target_type <span class="hljs-operator">=</span> ?<br></code></pre></td></tr></table></figure><hr><h4 id="7-3-3-最终一致性保证"><a href="#7-3-3-最终一致性保证" class="headerlink" title="7.3.3 最终一致性保证"></a>7.3.3 最终一致性保证</h4><p><strong>流程</strong>:</p><ol><li>用户点击点赞 → 发送Kafka消息 → 立即返回成功</li><li>Kafka消费者1（user-service）→ 更新Redis缓存</li><li>Kafka消费者2（interaction-service）→ 更新数据库</li><li>消息持久化 + 手动ACK → 保证消息不丢失</li><li>幂等性处理 → 重复消费结果一致</li></ol><p><strong>优势</strong>:</p><ul><li>降低接口响应时间（异步处理） </li><li>削峰填谷（高并发缓冲）</li><li>最终一致性（数据库与缓存同步）</li></ul><p>\</p><h1 id="技术痛点"><a href="#技术痛点" class="headerlink" title="技术痛点"></a>技术痛点</h1><p><strong>流程引擎负责推进流程的执行</strong>。流程引擎记录流程的执行历史；写代码可以永远只查询当前要做什么即可。</p><ol><li><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1></li><li><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2></li></ol><ul><li><strong>流程（PROCESS）</strong> : 通过工具建模最终生成的BPMN文件，里面有整个<strong>流程的定义</strong></li><li><strong>流程实例（Instance）</strong> ：流程启动后的实例</li><li><strong>流程变量（Variables）</strong> ：<strong>流程任务之间传递的参数</strong></li><li><strong>任务（TASK）</strong> ：流程中定义的每一个节点<ul><li>用户任务：人工审核</li><li>系统任务：代码任务</li></ul></li><li><strong>流程部署</strong> ：将之前流程定义的 <code>.bpmn文件</code> 部署到<strong>工作流平台</strong></li></ul><p><strong>流程定义文件</strong> &#x3D;&#x3D;&#x3D;&gt; 部署工作流平台 &#x3D;&#x3D;&#x3D;&gt; 请假v-emp版本<strong>部署</strong> &#x3D;&#x3D;&#x3D;&gt; v1部署一个<strong>流程实例</strong></p><p>​                                                    &#x3D;&#x3D;&#x3D;&gt; 请假v-leader版本<strong>部署</strong> &#x3D;&#x3D;&#x3D;&gt; v2部署一个<strong>流程实例</strong></p><p>​                                                    &#x3D;&#x3D;&#x3D;&gt; 请假v-hr版本<strong>部署</strong> &#x3D;&#x3D;&#x3D;&gt; v3部署一个<strong>流程实例</strong></p><ol><li><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a><strong>核心组件</strong></h2></li></ol><ul><li><p><strong>Process Engine</strong> -流程引擎</p></li><li><p><strong>Web Applicatons</strong> - 基于web的管理页面</p></li><li><p><strong>调用****流程引擎服务</strong>有三种方式**：</p><ul><li>通过 Camunda Web 控制台界面</li><li>通过官方 rest 接口操作 camunda 流程引擎，Camunda Platform REST API 官方说明文档：<a href="https://docs.camunda.org/rest/camunda-bpm-platform/7.19/">Camunda Platform REST API</a></li><li><strong><code>Java 代码调用 Camunda 提供的 Service 接口</code></strong>（如：org.camunda.bpm.engine.RuntimeService、org.camunda.bpm.engine.TaskService 等等）</li></ul><p><img src="/./../img/image-20251213213200145.png" alt="image-20251213213200145"></p></li></ul><ol><li><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2></li></ol><p><a href="https://docs.camunda.org/manual/latest/">https://docs.camunda.org/manual/latest/</a></p><p><img src="/./../img/1765632538441-1.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//1、获取默认的流程引擎</span><br><span class="hljs-type">ProcessEngine</span> <span class="hljs-variable">processEngine</span> <span class="hljs-operator">=</span> ProcessEngines.getDefaultProcessEngine();<br><br><span class="hljs-type">RepositoryService</span> <span class="hljs-variable">repositoryService</span> <span class="hljs-operator">=</span> processEngine.getRepositoryService();<br><span class="hljs-type">RuntimeService</span> <span class="hljs-variable">runtimeService</span> <span class="hljs-operator">=</span> processEngine.getRuntimeService();<br><span class="hljs-type">TaskService</span> <span class="hljs-variable">taskService</span> <span class="hljs-operator">=</span> processEngine.getTaskService();<br><span class="hljs-type">IdentityService</span> <span class="hljs-variable">identityService</span> <span class="hljs-operator">=</span> processEngine.getIdentityService();<br><span class="hljs-type">FormService</span> <span class="hljs-variable">formService</span> <span class="hljs-operator">=</span> processEngine.getFormService();<br><span class="hljs-type">HistoryService</span> <span class="hljs-variable">historyService</span> <span class="hljs-operator">=</span> processEngine.getHistoryService();<br><span class="hljs-type">ManagementService</span> <span class="hljs-variable">managementService</span> <span class="hljs-operator">=</span> processEngine.getManagementService();<br><span class="hljs-type">FilterService</span> <span class="hljs-variable">filterService</span> <span class="hljs-operator">=</span> processEngine.getFilterService();<br><span class="hljs-type">ExternalTaskService</span> <span class="hljs-variable">externalTaskService</span> <span class="hljs-operator">=</span> processEngine.getExternalTaskService();<br><span class="hljs-type">CaseService</span> <span class="hljs-variable">caseService</span> <span class="hljs-operator">=</span> processEngine.getCaseService();<br><span class="hljs-type">DecisionService</span> <span class="hljs-variable">decisionService</span> <span class="hljs-operator">=</span> processEngine.getDecisionService();<br></code></pre></td></tr></table></figure><h2 id="1RepositoryService"><a href="#1RepositoryService" class="headerlink" title="1RepositoryService"></a>1RepositoryService</h2><ul><li>管理流程定义（BPMN）、部署、模板等静态资源（Definition 层）</li><li>主要负责<strong>部署流程、查询流程定义、读取模型文件</strong>等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 部署一个 BPMN 文件</span><br><span class="hljs-type">Deployment</span> <span class="hljs-variable">deployment</span> <span class="hljs-operator">=</span> repositoryService.createDeployment()<br>    .addClasspathResource(<span class="hljs-string">&quot;my-process.bpmn&quot;</span>)<br>    .name(<span class="hljs-string">&quot;My Deployment&quot;</span>)<br>    .deploy();<br><br><span class="hljs-comment">// 查询流程定义</span><br><span class="hljs-type">ProcessDefinition</span> <span class="hljs-variable">procDef</span> <span class="hljs-operator">=</span> repositoryService.createProcessDefinitionQuery()<br>    .processDefinitionKey(<span class="hljs-string">&quot;my_process_key&quot;</span>)<br>    .latestVersion()<br>    .singleResult();<br></code></pre></td></tr></table></figure><p><img src="/./../img/image-20251129012055576.png" alt="image-20251129012055576"></p><p><img src="/./../img/image-20251129014202187.png" alt="image-20251129014202187"></p><h2 id="2保存远程调用"><a href="#2保存远程调用" class="headerlink" title="2保存远程调用"></a>2保存远程调用</h2><p>保存剧集信息，演员信息，基本信息，关联信息之后再</p><img src="./../img/image-20251129012502349.png" alt="image-20251129012502349" style="zoom: 50%;" /><h3 id="远程调用启动"><a href="#远程调用启动" class="headerlink" title="远程调用启动"></a>远程调用启动</h3><p><img src="/./../img/image-20251129012708756.png" alt="image-20251129012708756"></p><h2 id="3ai初审"><a href="#3ai初审" class="headerlink" title="3ai初审"></a>3ai初审</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OllamaModerationServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OllamaModerationService</span> &#123;<br><br><br>    <span class="hljs-meta">@Autowired</span>  <span class="hljs-comment">// xxxChatModel</span><br>    OllamaChatModel ollamaChatModel;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检测文本的情感类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> text</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">moderation</span><span class="hljs-params">(String text)</span>&#123;<br>        <span class="hljs-comment">//1、用户消息；</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">userMessage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserMessage</span>(text);<br>        <span class="hljs-comment">//2、系统提示词</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">systemText</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            接下来我会给你发一段文本，需要你分析一下这个文本是正向还是负面的文本。1代表正向，</span><br><span class="hljs-string">            0代表负面，直接给我返回0或者1，不要返回其他废话。</span><br><span class="hljs-string">            &quot;&quot;&quot;</span>;<br>        <span class="hljs-type">SystemPromptTemplate</span> <span class="hljs-variable">systemPromptTemplate</span> <span class="hljs-operator">=</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemPromptTemplate</span>(systemText);<br>        <span class="hljs-comment">//3、构造系统消息</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">systemMessage</span> <span class="hljs-operator">=</span> systemPromptTemplate.createMessage();<br>        <span class="hljs-comment">//4、所有提示词 = 系统 + 用户提示词</span><br>        <span class="hljs-type">Prompt</span> <span class="hljs-variable">prompt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Prompt</span>(List.of(systemMessage,userMessage));<br>        <span class="hljs-comment">//5、调用模型</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> ollamaChatModel.call(prompt)<br>            .getResult().getOutput().getText();<br>        <span class="hljs-keyword">return</span> json;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><h3 id="Runtime-Service"><a href="#Runtime-Service" class="headerlink" title="Runtime****Service"></a><strong>Runtime****Service</strong></h3></li></ol><ul><li><strong>运行</strong>时管理<strong>流程实例</strong>（Instance 层）</li><li><strong>启动流程</strong>、<strong>管理运行中的流程实例</strong>和执行对象（Execution）</li><li><strong>设置与获取流程变量</strong>（Process Variables）</li><li>触发消息、信号、定时事件等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 启动流程实例</span><br><span class="hljs-type">ProcessInstance</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> runtimeService.startProcessInstanceByKey(<span class="hljs-string">&quot;my_process_key&quot;</span>, variables);<br><br><span class="hljs-comment">// 根据条件查询运行中的实例</span><br>runtimeService.createProcessInstanceQuery()<br>    .processInstanceId(pi.getId())<br>    .singleResult();<br><br><span class="hljs-comment">// 设置变量</span><br>runtimeService.setVariable(pi.getId(), <span class="hljs-string">&quot;amount&quot;</span>, <span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure><h2 id="4人工初审"><a href="#4人工初审" class="headerlink" title="4人工初审"></a>4人工初审</h2><img src="./../img/image-20251129013324613.png" alt="image-20251129013324613" style="zoom:67%;" /><p>任务API</p><blockquote><p>基于service的查询类，都可先构建一个 query，然后在附上查询条件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;ProcessDefinition&gt; list = repositoryService.createProcessDefinitionQuery().list();<br>List&lt;Task&gt; list = taskService.createTaskQuery().taskAssignee(<span class="hljs-string">&quot;zhangsan&quot;</span>).list();<br>List&lt;ProcessInstance&gt; instances = runtimeService.createProcessInstanceQuery().listPage(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><ol><li><h4 id="查询历史任务"><a href="#查询历史任务" class="headerlink" title="查询历史任务"></a>查询历史任务</h4></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;HistoricProcessInstance&gt; list = historyService.createHistoricProcessInstanceQuery().list();<br></code></pre></td></tr></table></figure><ol><li><h4 id="查询当前任务-分页"><a href="#查询当前任务-分页" class="headerlink" title="查询当前任务&#x2F;分页"></a><strong>查询当前任务&#x2F;分页</strong></h4></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;Task&gt; list = taskService.createTaskQuery().orderByTaskCreateTime().desc().list();<br></code></pre></td></tr></table></figure><h2 id="5流程变量"><a href="#5流程变量" class="headerlink" title="5流程变量"></a>5流程变量</h2><p>包括流程中产生的变量信息，包括控制流程流转的变量，网关、业务表单中填写的流程需要用到的变量等。很多地方都要用到</p><ol><li><h4 id="流程变量变量传递"><a href="#流程变量变量传递" class="headerlink" title="流程变量变量传递"></a><strong>流程变量变量传递</strong></h4></li></ol><p>变量最终会存在 <code>act_ru_variable</code> 这个表里面</p><p>在绘制流程图的时候，如果是用户任务（userService） 可以设置变量，比如执行人，</p><p><img src="/./../img/1765635670923-4.png" alt="img"></p><ol><li><h4 id="几种写法"><a href="#几种写法" class="headerlink" title="几种写法"></a><strong>几种写法</strong></h4></li></ol><ul><li>写死，就比如 zhangsan</li><li>表达式，比如上面写的 <code>$&#123;user&#125;</code>，这种需要传入参数，其实就是启动参数的时候传入，传入参数，可选值为一个<code>Map&lt;String, Object&gt;</code>，之后的流程可查看次参数，上面写的是 user， 所以map里面的key需要带着user，不然会报错。</li></ul><blockquote><p>关于扩展变量，可在流程图绘制这么设定，传递方式还是一样，流程图里面在下面写：</p></blockquote><p><img src="/./../img/1765635670924-5.png" alt="img"></p><blockquote><p>启动流程：传入变量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">ProcessInstance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> runtimeService.startProcessInstanceByKey(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;());<br></code></pre></td></tr></table></figure><blockquote><p>变量设置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">runtimeService.setVariable(instance.getId(), Constants.PATIENT_ID, relatedId);<br></code></pre></td></tr></table></figure><blockquote><p>变量查询</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Object</span> <span class="hljs-variable">variable</span> <span class="hljs-operator">=</span> runtimeService.getVariable(instance.getId(), Constants.GENERAL_ID);<br></code></pre></td></tr></table></figure><blockquote><p>历史变量查询</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">HistoricVariableInstance</span> <span class="hljs-variable">variableInstance</span> <span class="hljs-operator">=</span> historyService.createHistoricVariableInstanceQuery().processInstanceId(bo.getId().toString()).<br>            variableName(Constants.PATIENT_ID).singleResult();<br><span class="hljs-comment">//变量值</span><br>variableInstance.getValue();<br><span class="hljs-comment">//变量名称</span><br>variableInstance.getName();<br></code></pre></td></tr></table></figure><ol><li><h3 id="两种任务"><a href="#两种任务" class="headerlink" title="两种任务"></a>两种任务</h3></li></ol><blockquote><p>针对后端来说任务类型主要有两种。</p></blockquote><blockquote><p><strong>用户任务-userTask</strong></p><p>即需要用户参与的任务，因为工作流执行过程中需要涉及到审批、过审之类的需要用户参与的任务，这个时候需要用户参与，然后调用接口完成任务。</p><p><strong>服务任务-serviceTask</strong></p><p>即自动执行的任务，比如用户提交后，系统自动存储、修改状态等自动完成的任务。</p></blockquote><ol><li><h4 id="Type"><a href="#Type" class="headerlink" title="Type"></a><strong>Type</strong></h4></li></ol><p>任务类型是关键，可根据配型配置实现调用 java的方法，spring 的bean方法等等。有这么几种类型</p><p><img src="/./../img/1765635670924-6.png" alt="img"></p><ol><li><h4 id="推荐使用-–-Delegate-Expression"><a href="#推荐使用-–-Delegate-Expression" class="headerlink" title="推荐使用 – Delegate Expression !!!"></a><strong>推荐使用 – Delegate Expression !!!</strong></h4></li></ol><p>在系统任务中，因为是自动执行，所以实际应用中需要嵌入各种业务逻辑，可以在流程图设计中，按照下面方式调用java代码执行，在spring中配置同名的bean</p><p><img src="/./../img/1765635670924-7.png" alt="img"></p><blockquote><p>@Bean</p></blockquote><p>@Bean注解用于标记一个方法作为Spring的bean工厂方法。当一个方法被@Bean注解标记时，Spring会将该方法的返回值作为一个bean，并将其添加到Spring容器中，如果自定义配置，经常用到这个注解。</p><p>配置表达式，可以实现JavaDelegate接口使用类名配置</p><ol><li><strong>快捷写法如下</strong>，比较推荐下面这种，此种可灵活配置bean和spring结合使用，注入service等业务方法</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Bean</span>(<span class="hljs-string">&quot;t17&quot;</span>)<br><span class="hljs-title class_">JavaDelegate</span> <span class="hljs-title function_">t17</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> execution -&gt; &#123;<br>        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; variables = execution.<span class="hljs-title function_">getVariables</span>();<br>        <span class="hljs-title class_">Task</span> task = taskService.<span class="hljs-title function_">createTaskQuery</span>().<span class="hljs-title function_">processInstanceId</span>(execution.<span class="hljs-title function_">getProcessInstanceId</span>()).<span class="hljs-title function_">singleResult</span>();<br>        <span class="hljs-comment">//业务逻辑</span><br>        task.<span class="hljs-title function_">setOwner</span>(<span class="hljs-title class_">String</span>.<span class="hljs-title function_">valueOf</span>(dentistId));<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>**Java Class ：**配置java类名，需要实现JavaDelegate接口，注意是全路径名，不可以使用Spring的bean配置！！！</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T17Delegate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">JavaDelegate</span> &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">execute</span>(<span class="hljs-title class_">DelegateExecution</span> execution) throws <span class="hljs-title class_">Exception</span> &#123;<br>            <span class="hljs-title class_">String</span> taskId = execution.<span class="hljs-title function_">getId</span>();<br>            <span class="hljs-title class_">String</span> instanceId = execution.<span class="hljs-title function_">getProcessInstanceId</span>();<br>            <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; variables = execution.<span class="hljs-title function_">getVariables</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩展：-BPMN"><a href="#扩展：-BPMN" class="headerlink" title="扩展： BPMN"></a>扩展： BPMN</h2><blockquote><p>BPMN：<strong>BPMN</strong>是由BPMI(The Business Process Management Initiative)开发的一套标准叫<strong>业务流程建模符号</strong>，于2004年5月对外发布了<strong>BPMN</strong> 1.0 规范。后BPMI并入到<strong>OMG组织</strong>，OMG于2011年推出BPMN 2.0标准，对BPMN进行了重新定义(Business Process Model and Notation)</p></blockquote><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><p>ollama 暴露的 API 接口地址。SPring AI直接可以调用。上线了。云GPU服务器。</p><p>各种模型调用、RAG、向量检索</p><p>模型幻觉（微调模型会有幻觉） ok，没问题</p><p>相似度算法、</p><p>温度高，输出不稳定。 </p><p>了解 过 vllm 框架 能加速推理。不了解</p><p>每晚3点。短剧会全量缓存，预热。防止漏更新。 5000多短剧。为未来准备的</p><p>短剧每天都会增。</p><p>增量数据是靠kafka 消息，进行redis和数据库同步</p><p>并发多线程查询的，会提交线程池 submit 提交任务</p><p>CompletableFuture.runAsync()</p><p>allof() 返回所有结果</p><p>主键就是局促；叶子节点完整数据</p><p>其他就是非局促；叶子节点只有主键id</p><p>只查索引列数据即可。不写select * </p><p>从机 start slave 命令就可以。</p><ol><li>主机开启 binlog 日志</li><li>从机连接主机。 </li><li>从机开始同步获取binlog，并记录relay_log（中继日志）</li><li>从机重放 relay_log 内容</li></ol><p>binlog同步到哪里有 记录position位置。</p><p>技术复杂度高，得搞一堆 注册中心、配置中心、远程调用、链路追踪等</p><p>基本不用，嫌不好维护</p><p>require_new</p><p>required</p><p>等 Synchronized  (对象头锁标志位) </p><p>无锁 –&gt; 偏向锁(一个线程在用所)  –&gt; 轻量(两个线程在用所【自旋获取锁】) –&gt; 重量(更多线程在用所【等待唤醒机制获取锁】)</p><p>或者  Lock(  AQS中的 state 属性， CLH队列（双向链表的队列）维护锁公平性 )</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><img src="/./../img/WHCBJSZDADACW.png" alt="img"></p><p>****基础的搜索：****直接走向量库搜索（Redis）、不走大模型</p><p>不断的新发短剧。新短剧进向量库。所有的搜索走向量库相似度搜索；</p><p>开发了首页的****信息流短剧推荐功能****。信息流主要特点就是 <em><strong>*低码率*</strong></em>（通过降低视频画质、降低视频采样率（60帧变为 25帧）等最终降低视频每秒传输的字节数）；</p><ol><li>因为考虑到 播放进度需要前端每秒汇报一次，请求速率很高。并且记录用户的播放进度。引入kafka 进行，并设计用户事件（UserEvent extends BaseEvent [唯一id，发送事件，用户]）。 用户的所有行为请求进来，直接封装为事件。发送给kafka；（基本信息的封装由kafkaTemplate的拦截器进行统一设置。）</li><li>其他系统全部监听****kafka消息****，从而实现同步；<ol><li><em><strong>*Redis数据缓存系统*</strong></em>：<em>***<em>*缓存优先模式**</em>*</em>*（短剧信息、短剧点赞数量、短剧播放进度都直接查Redis，Redis没有再走回源逻辑即可）， 所有和用户对接的高频的增删改查，查redis即可； </li><li>这些数据没有过期时间，考虑到 一旦数据过期要回源。MySQL由于自己同步速度慢，没有同步到数据，导致回源无数据，从而产生数据不一致问题。</li><li>MySQL持久化系统：监听到消息以后。慢慢的进行数据保存；（Redis万一哪天没有数据，就回源MySQL查询）</li></ol></li><li>R：<em><strong>*用户高频操作的缓存命中率：几乎100%；基本不回源*</strong></em>。MySQL目前和Redis数据差异基本在秒级（由于目前量还没有太大）；Redis 的线上故障时间（目前除了手动停机，Redis自己没停机过）。Redis 是 8核 32G 机器。 主从复制。无哨兵</li><li>为了实****现稳定转码，和人工兜底处理****。引入了 xxl-job，将转码任务交给 xxl-job 调度给某个机器，并且设置失败重试规则。 这样的好处是，即使多次失败后，任务还在xxl-job中有保存。手动修复相关问题后还可以继续手工启动任务；（主要核心思路，xxl-job原生只支持在控制台提交定时任务。现在需要AI审核通过以后，自动提交转码任务。所以默认robot机器人账号登录xxl-job，触发一个一次性任务启动）</li></ol><p>链表   字典  跳跃表</p><p><img src="/./../img/XOYRZSZDAAQCK.png" alt="img"></p><p>AOF指令集  每秒一次</p><p>appendfsync everysec  # 每秒同步1次（默认，推荐）</p><p>appendfsync always  # 每次写命令都同步（最安全，性能损耗最大）</p><p>appendfsync no</p><p>宕机</p><p>缓冲区不足</p><p>高吞吐量、低延迟、<em><strong>*高可用（多副本机制）*</strong></em></p><p>多消费者模型</p><p>消息可靠</p><p>kafka最终一致性</p><p><img src="/./../img/WQBCJSZDADQAI.png" alt="img"></p><hr><hr><hr><hr><p>注册中心 配置中心</p><p>服务发现 </p><p>服务上线自动注册到注册中心，客户端去注册中心获取对方微服务地址</p><p>@EnableXxxx 系列   @EnableCache  @EnableTransationManagement </p><p>接口可以有多实现，。  抽象类单继承</p><p>Set 无需不重复  List 有序重复</p><p>select count(*) from user group by age in  having (12,30) 差不多就这些</p><p>主键一定唯一，唯一不一定主键</p><p>explain  </p><p>手动 commit ； 异常调用 rollback；</p><p>ACID、可能存在；具体过期策略；</p><p>底层就是 setnx ex  命令</p><p>加锁 删锁 原子性  锁续期  锁粒度不能太粗</p><p>kafka 就是  mq</p><p>消息幂等性   业务保证。 识别消息唯一id，做防重复处理</p><p>发送一个重试队列中 重试 </p><p>tail -f grep|“关键字”</p><p>ping</p><p>线程池 通过创建合适索引优化为行锁</p><p>短信api   系统会根据是否有回调  进行代码层面的重试</p><p>try-with-resource  避免内存泄露 </p><p>其他就是阿里开发手册嵩山版</p><p>你就说了解就行 </p><p><img src="/./../img/IOH3NVJDADQB2.png" alt="img"></p><p><img src="/./../img/QJE3PVJDADQEA.png" alt="img"></p><p>定位</p><ul><li>用 <code>ps -ef | grep 服务进程名</code> 或 <code>jps</code>（Java 服务）确认进程是否存在，是否有异常重启（结合操作系统日志 <code>/var/log/messages</code> 或 <code>dmesg</code> 查看是否被 OOM 杀死）。</li></ul><p><em><strong>*JVM——jstack*</strong></em></p><ul><li>用 <code>jstack &lt;进程ID&gt;</code> 生成线程栈快照，搜索服务的业务线程（如 Tomcat 的<code>http-nio-xxx</code>线程、自定义线程池线程）。</li><li>重点关注状态为 <code>BLOCKED</code>（阻塞等待锁）、<code>WAITING</code>（无限期等待，如<code>Object.wait()</code>）、<code>TIMED_WAITING</code>（超时等待，如<code>Thread.sleep()</code>）的线程：<ul><li>若大量线程<code>BLOCKED</code>，查看是否在竞争同一把锁（如静态方法锁、单例对象锁），定位到具体代码行（栈信息会显示类和方法）。</li><li>若线程<code>WAITING</code>在<a href="https://java.net/"><code>java.net</code></a><code>.SocketInputStream.read</code>，说明在等待外部服务（如数据库、第三方 API）响应，可能是依赖超时或未返回。</li><li>若线程卡在<code>java.io.FileOutputStream.write</code>，可能是日志文件写入阻塞（如磁盘满、权限不足）。</li></ul></li></ul><p>skywalking也可以</p><p><em><strong>*垃圾回收*</strong></em></p><ul><li>用 <code>jstat -gc &lt;进程ID&gt; 1000</code> 监控 GC 情况：若<code>FGC</code>频繁（每秒多次）且<code>FGCT</code>时间长（如每次几百毫秒），说明内存不足导致 GC 停顿，服务无法处理请求。</li><li>用 <code>jmap -heap &lt;进程ID&gt;</code> 查看堆内存配置（如新生代、老年代大小），确认是否因堆配置过小导致频繁 GC。</li><li>用 <code>jconsole</code> 或 <code>jvisualvm</code> 连接服务，实时查看线程状态、内存使用、GC 活动，定位阻塞点。</li></ul><p>并行一起做，并发一个人做多个任务</p><p><img src="/./../img/2DDKXXRDABACI.png" alt="img"></p><hr><hr><p><img src="/./../img/CD5A3YBDABQHU.png" alt="img"></p><p><img src="/./../img/XMSQ5YBDACQEA.png" alt="img"></p><p><img src="/./../img/RSFA5YBDAAAGQ.png" alt="img"></p><p>反序列化的核心是：<em>***<em>*读取序列化格式的数据（JSON&#x2F;XML&#x2F; 二进制），并根据特定规则将其转换为编程语言中的对象**</em>*</em>*。具体步骤通常是：</p><ol><li>读取序列化数据（从文件、网络流、请求体等）。</li><li>根据数据格式（如 JSON）选择对应的解析器（如 Jackson、Gson）。</li><li>指定目标对象类型，解析器将数据映射为该类型的实例。</li></ol><h3 id="在-Spring-Boot-中通过-RequestBody-实现反序列化"><a href="#在-Spring-Boot-中通过-RequestBody-实现反序列化" class="headerlink" title="****在 Spring Boot 中通过******\*@RequestBody\******实现反序列化***"></a><em>***<em>*在 Spring Boot 中通过**</em>*</em><em><code>***\*@RequestBody\****</code></em><strong>*<em>*实现反序列化**</em>*</strong></h3><p>在 Spring Boot 的 RESTful 接口中，客户端发送的 JSON 数据会通过 HTTP 请求体传递，服务端通过<code>@RequestBody</code>注解自动完成****<em>*JSON→Java 对象**</em>***的反序列化，底层由 Jackson 库实现。</p><h4 id="1-准备实体类（目标对象）"><a href="#1-准备实体类（目标对象）" class="headerlink" title="****1. 准备实体类（目标对象）****"></a><em>***<em>*1. 准备实体类（目标对象）**</em>*</em>*</h4><p>首先定义与 JSON 数据结构匹配的 Java 类：</p><p><em><strong>*泛型允许我们定义类、接口或方法时，指定一个类型参数，在具体使用时再确定实际类型。*</strong></em></p><ul><li>java.nio.file 包及其相关包 java.nio.file.attribute 为文件 I&#x2F;O 和访问默认文件系统提供了全面支持。虽然该 API 包含许多类，但只需关注少数几个入口点即可。因此 API 非常直观且易于使用。</li><li>如何学习？<ol><li>Path 类：路径、路径操作、相对&#x2F;绝对路径</li><li>Files 类：文件操作共有的基本概念、文件检查、删除、复制和移动</li></ol></li></ul><p><em><strong>*1. 通过*</strong></em><code>***\*Executors\****</code><em><strong>*工具类快速创建（常用）*</strong></em></p><h4 id="固定大小线程池-newFixedThreadPool"><a href="#固定大小线程池-newFixedThreadPool" class="headerlink" title="****固定大小线程池**** ***\*newFixedThreadPool\****"></a><em>***<em>*固定大小线程池**</em>*</em>* <code>***\*newFixedThreadPool\****</code></h4><h4 id="2-缓存线程池-newCachedThreadPool"><a href="#2-缓存线程池-newCachedThreadPool" class="headerlink" title="****(2) 缓存线程池**** ***\*newCachedThreadPool\****"></a><em>***<em>*(2) 缓存线程池**</em>*</em>* <code>***\*newCachedThreadPool\****</code></h4><h4 id="3-单线程池-newSingleThreadExecutor"><a href="#3-单线程池-newSingleThreadExecutor" class="headerlink" title="****(3) 单线程池**** ***\*newSingleThreadExecutor\****"></a><em>***<em>*(3) 单线程池**</em>*</em>* <code>***\*newSingleThreadExecutor\****</code></h4><h4 id="4-定时任务线程池-newScheduledThreadPool"><a href="#4-定时任务线程池-newScheduledThreadPool" class="headerlink" title="****(4) 定时任务线程池**** ***\*newScheduledThreadPool\****"></a><em>***<em>*(4) 定时任务线程池**</em>*</em>* <code>***\*newScheduledThreadPool\****</code></h4><h3 id="2-直接使用-ThreadPoolExecutor-手动创建（推荐，更灵活）"><a href="#2-直接使用-ThreadPoolExecutor-手动创建（推荐，更灵活）" class="headerlink" title="****2. 直接使用******\*ThreadPoolExecutor\******手动创建（推荐，更灵活）***"></a><em>***<em>*2. 直接使用**</em>*</em><em><code>***\*ThreadPoolExecutor\****</code></em><strong>*<em>*手动创建（推荐，更灵活）**</em>*</strong></h3><h4 id="1-CPU-密集型任务"><a href="#1-CPU-密集型任务" class="headerlink" title="****1. CPU 密集型任务****"></a><em>***<em>*1. CPU 密集型任务**</em>*</em>*</h4><ul><li><em>***<em>*特点**</em>*</em>*：任务主要消耗 CPU 资源（如计算、排序、加密），几乎无等待时间。</li><li><em>***<em>*线程数设置**</em>*</em>*：≈CPU 核心数（或 CPU 核心数 + 1）。</li><li><em>***<em>*原因**</em>*</em>*：CPU 核心数是同时能执行的最大线程数，过多线程会导致上下文切换，反而降低效率。</li></ul><h4 id="2-IO-密集型任务"><a href="#2-IO-密集型任务" class="headerlink" title="****2. IO 密集型任务****"></a><em>***<em>*2. IO 密集型任务**</em>*</em>*</h4><ul><li><p><em>***<em>*特点**</em>*</em>*：任务包含大量 IO 等待（如数据库查询、网络请求、文件读写），CPU 大部分时间处于空闲状态。</p></li><li><p><em>***<em>*线程数设置**</em>*</em>*：≈CPU 核心数 ×2（或 CPU 核心数 &#x2F;(1 - 阻塞系数)）。</p></li><li><p><em>***<em>*原因**</em>*</em>*：当一个线程等待 IO 时，CPU 可调度其他线程执行，充分利用 CPU 资源。“×2” 是经验值，本质是让 CPU 在 IO 等待期间不空闲。</p></li><li><p>****<em>*Spring**</em>***是整个生态的核心框架，提供基础功能；</p></li><li><p>****<em>*Spring MVC**</em>***是 Spring 框架的一个模块，专注于 Web 开发；</p></li><li><p>****<em>*Spring Boot**</em>***是基于 Spring 框架的快速开发工具，简化配置。</p></li></ul><h4 id="1-Spring（Spring-Framework）"><a href="#1-Spring（Spring-Framework）" class="headerlink" title="****1. Spring（Spring Framework）****"></a><em>***<em>*1. Spring（Spring Framework）**</em>*</em>*</h4><ul><li><em>***<em>*定位**</em>*</em><em>：Java 开发的</em><strong>*<em>*核心基础框架**</em>*</strong>，提供依赖注入（DI）、面向切面编程（AOP）等核心特性。</li><li><em>***<em>*核心功能**</em>*</em>*：<ul><li><em>***<em>*IoC 容器**</em>*</em>*：管理对象的创建和依赖（BeanFactory、ApplicationContext）；</li><li><em>***<em>*AOP**</em>*</em>*：实现日志、事务、权限等横切逻辑；</li><li><em>***<em>*事务管理**</em>*</em>*：统一的事务控制（声明式 &#x2F; 编程式）；</li><li><em>***<em>*数据访问**</em>*</em>*：整合 JDBC、ORM 框架（MyBatis、Hibernate）。</li></ul></li><li><em>***<em>*特点**</em>*</em>*：功能全面但配置繁琐（需 XML 或注解配置），需手动整合各模块。</li></ul><h4 id="2-Spring-MVC"><a href="#2-Spring-MVC" class="headerlink" title="****2. Spring MVC****"></a><em>***<em>*2. Spring MVC**</em>*</em>*</h4><ul><li><em>***<em>*定位**</em>*</em><em>：Spring 框架的</em><strong>*<em>*Web 模块**</em>*</strong>，基于 MVC 设计模式的请求驱动型框架。</li><li><em>***<em>*核心功能**</em>*</em>*：<ul><li>处理 HTTP 请求（Controller、RequestMapping）；</li><li>请求参数绑定、视图解析（JSP&#x2F;Thymeleaf）；</li><li>拦截器、异常处理；</li><li>与 Spring 核心无缝集成（依赖注入、AOP）。</li></ul></li><li><em>***<em>*应用场景**</em>*</em>*：开发传统 Web 应用或 RESTful API。</li><li><em>***<em>*特点**</em>*</em>*：需手动配置 DispatcherServlet、视图解析器等组件。</li></ul><h4 id="3-Spring-Boot"><a href="#3-Spring-Boot" class="headerlink" title="****3. Spring Boot****"></a><em>***<em>*3. Spring Boot**</em>*</em>*</h4><ul><li><em>***<em>*定位**</em>*</em><em>：</em><strong>*<em>*Spring 的快速开发脚手架**</em>*</strong>，简化 Spring 应用的搭建和配置。</li><li><em>***<em>*核心功能**</em>*</em>*：<ul><li><em>***<em>*自动配置**</em>*</em>*：根据依赖自动配置组件（如引入 spring-boot-starter-web 则自动配置 Spring MVC）；</li><li><em>***<em>*起步依赖**</em>*</em>*：整合常用依赖（如 spring-boot-starter-web 包含 Spring MVC、Tomcat 等）；</li><li><em>***<em>*嵌入式容器**</em>*</em>*：内置 Tomcat&#x2F;Jetty，无需部署 WAR 包；</li><li><em>***<em>*Actuator**</em>*</em>*：监控应用健康状态、指标。</li></ul></li><li><em>***<em>*特点**</em>*</em>*：“约定优于配置”，减少 XML &#x2F; 注解配置，快速开发独立运行的 Spring 应用。</li></ul><p><em><strong>*一段时间*</strong></em></p><p><em><strong>*SELECT COUNT(*) AS total_likes*</strong></em></p><p><em><strong>*FROM likes*</strong></em></p><p><em><strong>*WHERE created_at &gt;&#x3D; ‘2023-10-01 00:00:00’*</strong></em></p><p>  <em><strong>*AND created_at &lt; ‘2023-11-01 00:00:00’;*</strong></em></p><p>spring AI Alibaba</p><p><em><strong>*业务*</strong></em></p><p>生产者异步发送</p><p>队列多分区</p><p>手动提交消费的偏移量</p><p>唯一标识 有的 </p><p>内只取交集   用null 表示</p><p>range 范围ref 非主eqref  index system ccollection  map </p><p>hashmap hashmap concurrenthashmap</p><p>高级 for   这种也说下</p><p>获取 key 的 set 集合通过迭代器遍历 set 获取</p><p>直接 get</p><p>hash 碰撞 的时候</p><p>nacos openfeign sentinel gateway </p><p>配置中心和注册中心</p><p>检查服务名 @feignclient 上的注解是否与控制器保持一致  可以了</p><p>版本回退 git reset </p><p>让你说流程呢 直接说流程就行了下面我给你写好了</p><p>核心线程数 不够的话放阻塞队列 队列满了继续创建线程执行任务  </p><p>五个 默认的拒绝跑出异常 拒绝不跑出异常 拒绝等待时间最长的任务  调用主程序的   自定义拒绝策略</p><p>20251121面试记录</p><p><img src="/./../img/FXH532JDABQCQ.png" alt="img"></p><p>先去开放平台申请–获取对应的key配置在项目中—本地项目那个公钥访问第三方的API</p><p>先说explain 再说说字段 type key key_len rows extra[using filesort]</p><p>MVCC  redolog undolog binlog 实现事务的控制</p><p>基于kafka的最终一致性   解耦 A–执行完–发消息    B消费消息 并修改状态</p><p>基于seata的分布式事务解决方案</p><p>JVM: 就是虚拟机 分了三个子系统 类加载子系统 运行时数据区子系统  执行</p><p><img src="/./../img/M2E6Z2JDABQB2.png" alt="img"></p><p>用arthas 看  阿尔萨斯   配合 jstack 导出 堆的dump日志 查看 GC信息</p><p>高并发: 缓存 异步 队列 </p><p>高可用: 熔断 降级 限流</p><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>kcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>44Spring</title>
    <link href="/2025/11/24/44Spring/"/>
    <url>/2025/11/24/44Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="对Spring核心思想的理解"><a href="#对Spring核心思想的理解" class="headerlink" title="对Spring核心思想的理解"></a>对Spring核心思想的理解</h1><p>Spring通过IoC,DI,AOP三大核心思想,实现了轻量级,高内聚低耦合的企业级应用开发架构,成为Java生态中不可或缺的基石</p><p><img src="/./../img/1759067833992-9936ea71-c0a7-4e29-b579-940a084aa935.webp" alt="image.png"></p><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="谈谈自己对Spring-IoC的了解"><a href="#谈谈自己对Spring-IoC的了解" class="headerlink" title="谈谈自己对Spring IoC的了解"></a>谈谈自己对Spring IoC的了解</h2><p>(1)IoC基础定义与思想本质Ioc是设计思想,并未Spring特有,核心是将程序中手动创建、管理对象的控制权,从业务代码转移到外部环境控制反转拆解控制:指对象生命周期的管理权(包含实例化、依赖组装、销毁等)反转:指该控制权从”开发者手动编码”转移到”外部IoC容器”</p><h2 id="什么是SpringBean"><a href="#什么是SpringBean" class="headerlink" title="什么是SpringBean"></a>什么是SpringBean</h2><p>Bean就是被IoC容器所管理的对象我们需要告诉IoC容器帮助我们管理哪些对象,这个是通过配置元数据来定义的,可以通过XML文件、注解或Java配置类</p><h1 id="Bean是线程安全吗"><a href="#Bean是线程安全吗" class="headerlink" title="Bean是线程安全吗"></a>Bean是线程安全吗</h1><p>Bean是否线程安全,核心取决于Bean的作用域和Bean是否包含可变状态</p><p>(1)核心概念</p><p>Bean作用域</p><p>Bean的实例数量,生命周期,可见性</p><p>Bean状态</p><p>无状态Bean:不包含可变成员变量</p><p>有状态Bean:包含可变成员变量,不同线程调用时可能修改同一实例的变量,引发数据冲突</p><p>(2)不同作用域的Bean线程安全</p><p>prototype</p><p>由于每次通过容器获取Bean都会创建新的实例,因此不同线程，不同请求获取的Bean都是独立的对象,因此不存在线程安全问题</p><p>singleton</p><p>无状态单例Bean:线程安全,成员变量不共享,不可变</p><p>有状态单例Bean:线程不安全,成员变量共享,可变(多线程调用共享变量可能导致数据错乱)</p><p>(3)解决方案</p><p>设计为无状态Bean</p><p>移除Bean中的可变成员变,将状态数据通方法参数传递,或存储到外部容器,避免实例变量共享</p><p>使用ThreadLocal实现线程隔离</p><p>将可变成员变量存储到ThreadLocal中,每个线程拥有独立的变量副本,ThreadLocal本质是线程私有存储,</p><p>ThreadLocal需在线程结束时调用remove,避免发生内存泄漏</p><p>适用于状态仅在当前线程内有效的场景(如HTTP请求内的临时数据)</p><p>使用同步机制(兜底)</p><p>判定Spring Bean是否线程安全1)先看作用域:prototype必定安全,singleton需进一步判定状态2)再看状态:无状态singleton安全,有状态singleton不安全3)解决方案优先级:无状态设计 &gt; ThreadLocal线程隔离 &gt; 同步机制</p><h2 id="Bean的作用域有哪些"><a href="#Bean的作用域有哪些" class="headerlink" title="Bean的作用域有哪些"></a>Bean的作用域有哪些</h2><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><a href="https://jishuzhan.net/article/1949730988061405185">Java 设计模式之单例模式（详细解析） - 技术栈</a></p><p>(1)作用域的概念</p><p>Bean作用域本质定义了Spring容器管理Bean实例的规则</p><p>容器会创建一个还是多个Bean</p><p>Bean实例的生命周期何时开始、何时销毁</p><p>Bean实例在哪些场景下可见</p><p>(2)Spring内置Bean作用域</p><p>通用作用域(非Web环境也可用)</p><p>singleton</p><p>核心规则:IoC容器中仅存在一个Bean实例,所有对该Bean的请求都会返回同一个实例</p><p>生命周期:Bean实例在容器启动时创建,随容器关闭而销毁,生命周期与容器一致</p><p>注意事项:单例Bean是线程共享的,若存在成员遍历且被修改,会引发线程安全问题,可通过@Lasy设置懒加载:容器启动时不创建实例,在第一次请求时才创建</p><p>prototype</p><p>核心规则:每次请求Bean时,容器都会创建一个新的实例</p><p>生命周期:Bean实例在请求时创建,容器仅负责实例化,不负责销毁,销毁由JVM垃圾回收机制处理</p><p>注意事项:频繁创建prototype Bean会增加内存消耗,需避免在高并发场景下滥用</p><p>Web专属作用域</p><p>request</p><p>核心规则:每一个HTTP请求对应一个Bean实例,仅在当前请求内有效,不同请求的实例独立,Bean内存储当前请求的临时数据</p><p>生命周期:随HTTP请求创建,请求结束后销毁</p><p>session</p><p>核心规则:每一个用户会话对应一个Bean实例, 同一用户会话内共享,不同会话独立,存储用户的登录状态或偏好设置等</p><p>生命周期:随用户第一次请求创建,会话过期&#x2F;关闭后销毁</p><p>application</p><p>核心规则:整个Web应用对应一个Bean实例,所有用户共享,存储全局配置数据(如应用版本、全局计数器等)</p><p>生命周期:随Web应用启动创建,应用关闭后销毁</p><p>websocket</p><p>核心规则:每一个WebSocket会话对应一个Bean实例,仅在当前WebSocket连接内有效,WebSocket通信的实时聊天数据</p><p>生命周期:随WebSocket连接创建,连接关闭后销毁</p><p>(3)自定义作用域</p><p>Spring允许开发者自定义作用域,满足特殊业务需求</p><p>步骤</p><p>实现Scope接口</p><p>重写get(获取实例),remove(移除实例),registerDestructionCallbac(注册销毁回调)</p><p>注册自定义作用域</p><p>通过ConfigurableBeanFactory的registerScope方法,将自定义作用域注册到Spring容器</p><p>使用自定义作用域</p><p>通过@Scope标注Bean,容器按自定义规则管理实例</p><h1 id="什么是Spring-AOP"><a href="#什么是Spring-AOP" class="headerlink" title="什么是Spring AOP"></a>什么是Spring AOP</h1><p>AOP:能够将哪些与业务无关,却被各种业务模块所共同调用的通用逻辑或责任(日志记录,事务处理,权限控制)封装起来,便于减少系统的重复代码,降低模块间的耦合度,有利于代码的维护与拓展Spring AOP是基于动态代理的,如果要代理的对象实现了某个接口,那么Spring AOP会使用JDK Proxy(java.lang.reflect.Proxy),区创建代理对象使用JDK Proxy实现动态代理的前提是业务类必须实现某一接口</p><p><img src="/./../img/1759927704153-9f139a3d-7ca1-4253-a83c-b655719f04ba.webp" alt="image.png"></p><h2 id="AOP常见的通知类型有哪些"><a href="#AOP常见的通知类型有哪些" class="headerlink" title="AOP常见的通知类型有哪些"></a>AOP常见的通知类型有哪些</h2><p>(1)Before触发时机在目标对象的方法调用之前触发可获取信息及操作权限只能获取方法的签名信息(方法名,参数等),但无法获取方法的返回值,也不能对方法的执行进行干预.应用场景记录方法调用日志、在用户执行关键操作前进行权限检查(2)After触发时机目标对象方法执行完成之后触发,且无论目标方法执行过程中是否出现异常都会触发.可获取信息及操作权限可以获取到方法的执行结果(无论是否有异常),但无法对结果进行修改应用场景无论业务操作是否成功的一些场景,如关闭文件流、数据库连接等资源(3)AfterReturning触发时机只有当目标对象方法调用完成且没有抛出异常,在返回结果值之后触发可获取信息及操作权限可以获取到目标方法正常执行后的返回值,并且可以对返回值进行修改,然后再返回给调用者应用场景对业务方法返回的数据进行格式转换、脱敏处理;缓存业务方法的返回结果,提高后续查询效率等(4)AfterThrowing触发时机当目标对象的方法运行中抛出异常后触发,它与AfterReturin是互斥的可获取信息及操作权限能够获取到方法执行过程抛出的异常对象,通过对异常类型的判断来进行不同的异常处理应用场景记录异常日志,向用户发送友好的错误提升等(5)Around触发时机可以在目标对象方法调用前后进行编程式控制,它的执行时机是在目标方法调用之前先进入环绕通知,在环绕通知中决定是否调用目标方法,目标方法调用完成后再回到环绕通知继续执行后续代码它是功能最强大的通知类型,比如可以在方法调用前开启事务,方法调用成功后提交事务,方法调用失败时回滚事务可获取信息及操作权限能够获取到目标对象、要执行的方法以及方法的参数信息,并且可以决定目标方法是否执行,还能修改方法的返回值或者捕获异常并处理应用场景实现事务管理;实现性能监控,统计方法的执行时机</p><h1 id="动态代理和静态代理的区别"><a href="#动态代理和静态代理的区别" class="headerlink" title="动态代理和静态代理的区别"></a>动态代理和静态代理的区别</h1><p>(1)什么是代理</p><p>代理是一种经典设计模式,核心目的是为目标对象提供访问控制的中间层,从而解耦调用方与 目标对象的直接解耦在实现上,代理类和目标类需遵循相同的接口规范,确保代理能无缝转发对目标类方法的调用</p><p>(2)区别</p><p>静态代理由程序员手动编写或通过特定工具生成,在编译阶段就确定了代理关系仅代理单个类,代码结构固定动态代理在运行时通过反射机制动态生成代理类,无需提前编写固定代理代码.可同时代理一个接口下的多个实现类,灵活性高.</p><h1 id="Spring进阶"><a href="#Spring进阶" class="headerlink" title="Spring进阶"></a><strong>Spring进阶</strong></h1><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><ul><li>第五步：<code>BeanB</code>属性注入时发现循环依赖。</li></ul><p>当Spring试图填充<code>BeanB</code>的属性时，检测到它需要注入<code>BeanA</code>。此时容器启动依赖查找：</p><ol><li>在一级缓存（存放完整Bean）中未找到<code>BeanA</code>；</li><li>在二级缓存（存放已暴露的早期引用）中同样未命中；</li><li>最终在三级缓存中定位到<code>BeanA</code>的工厂。</li></ol><p>Spring立即调用该工厂的<code>getObject()</code>方法。这个方法会执行关键决策：若<code>BeanA</code>需要AOP代理，则动态生成代理对象（即使<code>BeanA</code>还未初始化）；若无需代理，则直接返回原始对象。得到的这个早期引用（可能是代理）被放入二级缓存（<code>earlySingletonObjects</code>），同时从三级缓存清理工厂条目。最后，Spring将这个早期引用注入到<code>BeanB</code>的属性中。至此，<code>BeanB</code>成功持有<code>BeanA</code>的引用——尽管<code>BeanA</code>此时仍是个半成品。</p><p><img src="/./../img/image-20251218142100417.png" alt="image-20251218142100417"></p><h3 id="Spring为什么用3级缓存解决循环依赖问题？用2级缓存不行吗？"><a href="#Spring为什么用3级缓存解决循环依赖问题？用2级缓存不行吗？" class="headerlink" title="Spring为什么用3级缓存解决循环依赖问题？用2级缓存不行吗？"></a>Spring为什么用3级缓存解决循环依赖问题？用2级缓存不行吗？</h3><p>Spring 必须用三级缓存解决循环依赖，核心是为了<strong>正确处理需要 AOP 代理的 Bean</strong>。如果只用二级缓存，会导致注入的对象形态错误，甚至破坏单例原则。</p><p>举个例子：假设 Bean A 依赖 B，B 又依赖 A，且 A 需要被动态代理（比如加了 <code>@Transactional</code>）。如果只有二级缓存，当 B 创建时去注入 A，拿到的是 A 的原始对象。但 A 在后续初始化完成后才会生成代理对象，结果就是：B 拿着原始对象 A，而 Spring 容器里存的是代理对象 A —— 同一个 Bean 出现了两个不同实例，这直接违反了单例的核心约束。</p><p>三级缓存中的 <code>ObjectFactory</code> 就是解决这个问题的关键。它不是直接缓存对象，而是存了一个能生产对象的工厂。当发生循环依赖时，调用这个工厂的 <code>getObject()</code> 方法，这时 Spring 会智能判断：如果这个 Bean 最终需要代理，就提前生成代理对象并放入二级缓存；如果不需要代理，就返回原始对象。这样一来，B 注入的 A 就是最终形态（可能是代理对象），后续 A 初始化完成后也不会再创建新代理，保证了对象全局唯一。</p><p>简单说，三级缓存的本质是 <strong>“按需延迟生成正确引用”</strong> 。</p><h3 id="Spring容器里存的是什么？"><a href="#Spring容器里存的是什么？" class="headerlink" title="Spring容器里存的是什么？"></a>Spring容器里存的是什么？</h3><p>在Spring容器中，存储的<strong>主要是Bean对象</strong>。</p><p>Bean是Spring框架中的基本组件，用于表示应用程序中的各种对象。当应用程序启动时，Spring容器会根据配置文件或注解的方式创建和管理这些Bean对象。Spring容器会负责创建、初始化、注入依赖以及销毁Bean对象</p><h2 id="Spring为什么用三级缓冲解决循环-一级、二级不行吗"><a href="#Spring为什么用三级缓冲解决循环-一级、二级不行吗" class="headerlink" title="Spring为什么用三级缓冲解决循环,一级、二级不行吗"></a>Spring为什么用三级缓冲解决循环,一级、二级不行吗</h2><p>(1)一级缓存</p><p>一级缓存只能存储完全初始化的成品Bean或半成品Bean,显然上述步骤的某一步是缺失的,不能解决循环依赖问题</p><p>(2)二级缓存</p><p>如果将一级缓存存成品,二级存半成品可以吗问题出在初始化过程中的AOP代理导致对象不一致问题:当A将半成品的A暴露给B时,B将半成品的A属性注入,然后进行A的初始化,生成了A的代理对象,最终导致B中的A与最终的AProxy不一致加入三级缓存,通过工厂实现按需生成代理.</p><h2 id="Lasy能否解决循环依赖"><a href="#Lasy能否解决循环依赖" class="headerlink" title="@Lasy能否解决循环依赖"></a>@Lasy能否解决循环依赖</h2><p>(1)@Lasy注解作用</p><p>加上@Lasy后,Bean仅在第一次被使用(被其它Bean依赖或调用)才创建</p><p>在循环依赖这个特殊场景导致它在容器启动时创建,但仍符合在第一次被使用时创建”的规则</p><p>(2)如何解决循环依赖</p><p><img src="/./../img/1762276352159-26745f46-3657-4b95-9275-bd1645aa4c9d.webp" alt="image.png"></p><h2 id="Spring容器里面存的是什么"><a href="#Spring容器里面存的是什么" class="headerlink" title="Spring容器里面存的是什么"></a>Spring容器里面存的是什么</h2><p>Spring容器中存储的核心是Bean对象,而这些Bean本质上是对应用中各类 组件的封装比如,一个用户服务类是业务组件,一个数据库访问类是数据层组件,它们都会以Bean的形式存在于Spring容器中,实现了对应用中各类组件的集中管控.</p><h2 id="Spring中-Bean加载和销毁前后-如果想要实现某些逻辑-可以怎么做"><a href="#Spring中-Bean加载和销毁前后-如果想要实现某些逻辑-可以怎么做" class="headerlink" title="Spring中,Bean加载和销毁前后,如果想要实现某些逻辑,可以怎么做"></a><strong>Spring中,Bean加载和销毁前后,如果想要实现某些逻辑,可以怎么做</strong></h2><p>可以通过xml、注解、实现接口实现某一具体Bean在初始化完成后和销毁开始前执行自定义逻辑</p><p>实现接口</p><p>初始化回调:实现InitializingBean接口并重写afterPropertiesSet</p><p>销毁回调:实现DisposableBean接口并重写destroy</p><p>import org.springframework.beans.factory.InitializingBean;</p><p>@Component</p><p>public class MyBean implements InitializingBean {</p><p>​    @Override</p><p>​    public void afterPropertiesSet() throws Exception {</p><p>​        &#x2F;&#x2F; Bean初始化完成后执行的逻辑（如资源初始化、参数校验）</p><p>​        System.out.println(“Bean初始化完成，执行自定义逻辑”);</p><p>​    }</p><p>}</p><p>import org.springframework.beans.factory.DisposableBean;</p><p>@Component</p><p>public class MyBean implements DisposableBean {</p><p>​    @Override</p><p>​    public void destroy() throws Exception {</p><p>​        &#x2F;&#x2F; Bean销毁前执行的逻辑（如资源释放、连接关闭）</p><p>​        System.out.println(“Bean销毁前，执行自定义逻辑”);</p><p>​    }</p><p>}</p><p>注解</p><p>@PostConstruct注解:在Bean的方法上标注该注解,该方法会在Bean初始化完成后执行</p><p>@PreDestroy注解:在Bean方法上标注@PreDestroy,该方法会在Bean销毁前执行</p><p>运行代码</p><p>import javax.annotation.PostConstruct;</p><p>@Component</p><p>public class MyBean {</p><p>​    @PostConstruct</p><p>​    public void init() {</p><p>​        &#x2F;&#x2F; Bean初始化完成后执行的逻辑</p><p>​        System.out.println(“通过@PostConstruct执行初始化逻辑”);</p><p>​    }</p><p>}</p><p>import javax.annotation.PreDestroy;</p><p>@Component</p><p>public class MyBean {</p><p>​    @PreDestroy</p><p>​    public void destroy() {</p><p>​        &#x2F;&#x2F; Bean销毁前执行的逻辑</p><p>​        System.out.println(“通过@PreDestroy执行销毁逻辑”);</p><p>​    }</p><p>}</p><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="Spring-MVC的处理流程说一下"><a href="#Spring-MVC的处理流程说一下" class="headerlink" title="Spring MVC的处理流程说一下"></a><strong>Spring MVC的处理流程说一下</strong></h2><p>  <img src="/./../img/image-20251126213013309.png" alt="image-20251126213013309"></p><p>事务传播机制是指在一个事务方法被另一个事务方法调用时，如何管理和协调事务的边界和行为。</p><h3 id="事务传播机制的基本概念"><a href="#事务传播机制的基本概念" class="headerlink" title="事务传播机制的基本概念"></a>事务传播机制的基本概念</h3><p>在编程和数据库管理中，事务是一个逻辑单位，确保一组操作要么全部成功，要么全部失败。事务传播机制主要解决多个事务方法相互调用时，事务如何在这些方法之间传播的问题。Spring框架提供了七种事务传播行为，分别是：</p><ol><li><strong>REQUIRED</strong>：如果当前存在事务，则加入该事务；如果没有事务，则创建一个新事务。这是最常用的传播行为，适用于大多数业务逻辑场景。</li><li><strong>SUPPORTS</strong>：如果当前存在事务，则加入该事务；如果没有事务，则以非事务方式执行。适用于读取数据时，可以不必加事务，但如果有事务则可以加。</li><li><strong>MANDATORY</strong>：必须在现有事务中执行，如果没有事务，则抛出异常。适用于需要依赖现有事务的操作。</li><li><strong>REQUIRES_NEW</strong>：无论是否存在当前事务，都会创建一个新事务。如果有现有事务，则挂起该事务，待新事务完成后再恢复。适用于独立执行的事务，通常用于日志记录等场景。</li><li><strong>NOT_SUPPORTED</strong>：如果当前有事务，则挂起该事务，以非事务方式执行。适用于明确不需要事务控制的操作，如查询操作。</li><li><strong>NEVER</strong>：要求方法不能在事务中执行。如果当前有事务，则抛出异常。适用于一些完全不允许在事务环境中执行的操作。</li><li><strong>NESTED</strong>：如果当前存在事务，则在嵌套事务中执行；如果没有事务，则创建一个新事务。适用于需要在现有事务中执行的操作，但又希望能够单独回滚的场景。</li></ol><h1 id="Lazy注解解决循环依赖的底层原理"><a href="#Lazy注解解决循环依赖的底层原理" class="headerlink" title="@Lazy注解解决循环依赖的底层原理"></a>@Lazy注解解决循环依赖的底层原理</h1><p>@Lazy注解是Spring框架提供的一种解决循环依赖问题的方式。当两个或多个Bean之间存在循环依赖时，可以使用@Lazy注解延迟初始化其中一个Bean，从而打破循环依赖。</p><p>具体原理如下：</p><ol><li>当Spring容器启动时，会解析并创建所有的Bean定义，但不会立即初始化Bean实例。</li><li>当遇到循环依赖时，Spring会创建一个代理对象来代替其中一个Bean的实例。</li><li>通过@Lazy注解，可以指定某个Bean在第一次被使用时才进行初始化，而不是在容器启动时立即初始化。</li><li>当另一个Bean依赖于被@Lazy注解修饰的Bean时，Spring会返回一个代理对象，而不是实际的Bean实例。</li><li>当代理对象被调用时，Spring会检查是否需要初始化被@Lazy注解修饰的Bean。</li><li>如果需要初始化，Spring会解析并创建被@Lazy注解修饰的Bean，并将其注入到代理对象中。</li><li>这样，循环依赖问题得到了解决，每个Bean都能够正确地获取到对方的实例。</li></ol><p>需要注意的是，@Lazy注解只能解决单例Bean之间的循环依赖问题，因为单例Bean在容器启动时就会被创建。对于原型（prototype）作用域的Bean，@Lazy注解不起作用，因为原型Bean每次获取时都会创建一个新的实例。</p><h3 id="SpringAOP的原理了解吗"><a href="#SpringAOP的原理了解吗" class="headerlink" title="SpringAOP的原理了解吗"></a>SpringAOP的原理了解吗</h3><p>Spring AOP的实现依赖于<strong>动态代理技术</strong>。动态代理是在运行时动态生成代理对象，而不是在编译时。它允许开发者在运行时指定要代理的接口和行为，从而实现在不修改源码的情况下增强方法的功能。</p><p>Spring AOP支持两种动态代理：</p><ul><li><strong>基于JDK的动态代理</strong>：使用java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口实现。这种方式需要代理的类实现一个或多个接口。</li><li><strong>基于CGLIB的动态代理</strong>：当被代理的类没有实现接口时，Spring会使用CGLIB库生成一个被代理类的子类作为代理。CGLIB（Code Generation Library）是一个第三方代码生成库，通过继承方式实现代理。</li></ul><h3 id="动态代理和静态代理的区别-1"><a href="#动态代理和静态代理的区别-1" class="headerlink" title="动态代理和静态代理的区别"></a>动态代理和静态代理的区别</h3><p>代理是一种常用的设计模式，目的是：为其他对象提供一个代理以控制对某个对象的访问，将两个类的关系解耦。代理类和委托类都要实现相同的接口，因为代理真正调用的是委托类的方法。</p><p>区别：</p><ul><li>静态代理：由程序员创建或者是由特定工具创建，在代码编译时就确定了被代理的类是一个静态代理。静态代理通常只代理一个类；</li><li>动态代理：在代码运行期间，运用反射机制动态创建生成。动态代理代理的是一个接口下的多个实现类。</li></ul><p>ewnd</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>101快猫短剧架构</title>
    <link href="/2025/11/23/101%E6%9E%B6%E6%9E%84%E5%92%8C%E6%B5%81%E7%A8%8B%E6%96%87%E6%A1%A3/"/>
    <url>/2025/11/23/101%E6%9E%B6%E6%9E%84%E5%92%8C%E6%B5%81%E7%A8%8B%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Kcat短剧平台-系统架构与业务流程完整文档"><a href="#Kcat短剧平台-系统架构与业务流程完整文档" class="headerlink" title="Kcat短剧平台 - 系统架构与业务流程完整文档"></a>Kcat短剧平台 - 系统架构与业务流程完整文档</h1><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#%E4%B8%80%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0">系统概述</a></li><li><a href="#%E4%BA%8C%E6%95%B4%E4%BD%93%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84">整体技术架构</a></li><li><a href="#%E4%B8%89%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3">服务模块详解</a></li><li><a href="#%E5%9B%9B%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B">核心业务流程</a></li><li><a href="#%E4%BA%94%E6%9C%8D%E5%8A%A1%E9%97%B4%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB">服务间交互关系</a></li><li><a href="#%E5%85%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1">数据库设计</a></li><li><a href="#%E4%B8%83%E6%8A%80%E6%9C%AF%E4%BA%AE%E7%82%B9%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">技术亮点与最佳实践</a></li><li><a href="#%E5%85%AB%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84">部署架构</a></li></ol><hr><h2 id="一、系统概述"><a href="#一、系统概述" class="headerlink" title="一、系统概述"></a>一、系统概述</h2><h3 id="1-1-项目背景"><a href="#1-1-项目背景" class="headerlink" title="1.1 项目背景"></a>1.1 项目背景</h3><p><strong>Kcat短剧平台</strong>是一个基于微服务架构的短视频内容分发平台，专注于短剧内容的创作、审核、发布、播放与用户互动。系统采用RuoYi-Cloud脚手架构建，集成了工作流引擎、AI审核、视频处理、消息队列等现代化技术栈。</p><h3 id="1-2-核心功能"><a href="#1-2-核心功能" class="headerlink" title="1.2 核心功能"></a>1.2 核心功能</h3><ul><li><strong>内容管理</strong>: 短剧、剧集、演员、分类、标签的全生命周期管理</li><li><strong>智能审核</strong>: AI自动审核 + 人工复核的混合审核机制</li><li><strong>视频处理</strong>: 腾讯云VOD转码（多清晰度+信息流格式）</li><li><strong>用户系统</strong>: 手机验证码登录、JWT认证、用户画像</li><li><strong>社交互动</strong>: 点赞、评论、弹幕、分享、收藏、关注</li><li><strong>推荐分发</strong>: 首页精选视频流、个性化推荐（待完善）</li></ul><h3 id="1-3-技术特色"><a href="#1-3-技术特色" class="headerlink" title="1.3 技术特色"></a>1.3 技术特色</h3><ol><li><strong>微服务架构</strong>: Spring Cloud + Nacos实现服务治理</li><li><strong>工作流引擎</strong>: Camunda BPM可视化编排复杂业务流程</li><li><strong>AI能力集成</strong>: Ollama本地模型 + DeepSeek云端模型</li><li><strong>事件驱动</strong>: Kafka异步解耦，实现最终一致性</li><li><strong>分布式缓存</strong>: Redis三高防护（穿透&#x2F;击穿&#x2F;雪崩）</li><li><strong>视频云处理</strong>: 腾讯云VOD专业转码服务</li></ol><hr><h2 id="二、整体技术架构"><a href="#二、整体技术架构" class="headerlink" title="二、整体技术架构"></a>二、整体技术架构</h2><h3 id="2-1-架构图"><a href="#2-1-架构图" class="headerlink" title="2.1 架构图"></a>2.1 架构图</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs nix">┌─────────────────────────────────────────────────────────────────────┐<br>│                           移动端 <span class="hljs-symbol">/</span> Web前端                            │<br>│                      (iOS <span class="hljs-symbol">/</span> Android <span class="hljs-symbol">/</span> H5)                            │<br>└──────────────────────────────┬──────────────────────────────────────┘<br>                               │ HTTPS<br>                               ▼<br>┌─────────────────────────────────────────────────────────────────────┐<br>│                        API网关 (Gateway)                             │<br>│                   路由转发 <span class="hljs-symbol">/</span> 鉴权 <span class="hljs-symbol">/</span> 限流 <span class="hljs-symbol">/</span> 日志                        │<br>└──────────┬──────────────────┬──────────────────┬────────────────────┘<br>           │                  │                  │<br>           ▼                  ▼                  ▼<br>┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐<br>│  user-service    │  │ content-service  │  │interaction-service│<br>│  (用户服务)       │  │  (内容服务)      │  │  (互动服务)       │<br>│  端口: <span class="hljs-number">10003</span>     │  │  端口: <span class="hljs-number">10001</span>     │  │  端口: <span class="hljs-number">10004</span>      │<br>│                  │  │                  │  │                   │<br>│ <span class="hljs-operator">-</span> 用户认证登录    │  │ <span class="hljs-operator">-</span> 短剧管理       │  │ <span class="hljs-operator">-</span> 点赞<span class="hljs-operator">/</span>评论       │<br>│ <span class="hljs-operator">-</span> BFF聚合层      │  │ <span class="hljs-operator">-</span> 剧集管理       │  │ <span class="hljs-operator">-</span> 弹幕<span class="hljs-operator">/</span>分享       │<br>│ <span class="hljs-operator">-</span> 首页数据       │  │ <span class="hljs-operator">-</span> 短剧发布       │  │ <span class="hljs-operator">-</span> 举报审核        │<br>│ <span class="hljs-operator">-</span> 点赞事件生产    │  │ <span class="hljs-operator">-</span> 文件上传       │  │ <span class="hljs-operator">-</span> 内容统计        │<br>└────────┬─────────┘  └─────────┬────────┘  └────────┬─────────┘<br>         │                      │                     │<br>         │                      │                     │<br>         ├──────────────────────┴─────────────────────┤<br>         │              Feign远程调用                  │<br>         │                      │                     │<br>         │                      ▼                     │<br>         │            ┌──────────────────┐            │<br>         │            │ camunda-service  │            │<br>         │            │  (工作流服务)     │            │<br>         │            │  端口: <span class="hljs-number">10002</span>     │            │<br>         │            │                  │            │<br>         │            │ <span class="hljs-operator">-</span> 审核流程编排    │            │<br>         │            │ <span class="hljs-operator">-</span> AI内容审核     │            │<br>         │            │ <span class="hljs-operator">-</span> 转码任务触发    │            │<br>         │            └────────┬─────────┘            │<br>         │                     │                      │<br>         └─────────────────────┴──────────────────────┘<br>                               │<br>         ┌─────────────────────┼──────────────────────┐<br>         │                     │                      │<br>         ▼                     ▼                      ▼<br>┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐<br>│  Kafka集群       │  │  Redis集群       │  │  MySQL数据库     │<br>│                  │  │                  │  │                  │<br>│ <span class="hljs-operator">-</span> 点赞事件       │  │ <span class="hljs-operator">-</span> 缓存热点数据   │  │ <span class="hljs-operator">-</span> 用户数据       │<br>│ <span class="hljs-operator">-</span> 评论事件       │  │ <span class="hljs-operator">-</span> 验证码存储     │  │ <span class="hljs-operator">-</span> 内容数据       │<br>│ <span class="hljs-operator">-</span> 消息队列       │  │ <span class="hljs-operator">-</span> 点赞状态       │  │ <span class="hljs-operator">-</span> 互动数据       │<br>│                  │  │ <span class="hljs-operator">-</span> 布隆过滤器     │  │ <span class="hljs-operator">-</span> 审核流程       │<br>└──────────────────┘  └──────────────────┘  └──────────────────┘<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│                          基础设施层                                   │<br>├──────────────────┬──────────────────┬──────────────────┬────────────┤<br>│  Nacos           │  Sentinel        │  XXL-Job         │  ELK       │<br>│  (注册<span class="hljs-operator">+</span>配置中心)  │  (限流<span class="hljs-operator">+</span>熔断)      │  (任务调度)       │  (日志)    │<br>└──────────────────┴──────────────────┴──────────────────┴────────────┘<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│                          外部服务                                     │<br>├──────────────────┬──────────────────┬──────────────────┬────────────┤<br>│  腾讯云VOD       │  MinIO对象存储   │  Ollama AI       │  阿里云短信 │<br>│  (视频转码)      │  (文件存储)      │  (本地AI模型)     │  (验证码)  │<br>└──────────────────┴──────────────────┴──────────────────┴────────────┘<br></code></pre></td></tr></table></figure><h3 id="2-2-技术栈总览"><a href="#2-2-技术栈总览" class="headerlink" title="2.2 技术栈总览"></a>2.2 技术栈总览</h3><table><thead><tr><th>技术分层</th><th>技术选型</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td><strong>基础框架</strong></td><td>Spring Boot</td><td>3.4.x</td><td>核心应用框架</td></tr><tr><td></td><td>Spring Cloud</td><td>2024.0.0</td><td>微服务生态</td></tr><tr><td></td><td>Java</td><td>17</td><td>开发语言</td></tr><tr><td><strong>服务治理</strong></td><td>Nacos</td><td>最新</td><td>服务注册发现+配置中心</td></tr><tr><td></td><td>Sentinel</td><td>最新</td><td>流量控制+熔断降级</td></tr><tr><td></td><td>OpenFeign</td><td>最新</td><td>声明式HTTP客户端</td></tr><tr><td></td><td>LoadBalancer</td><td>最新</td><td>客户端负载均衡</td></tr><tr><td><strong>数据存储</strong></td><td>MySQL</td><td>8.0+</td><td>关系型数据库</td></tr><tr><td></td><td>MyBatis-Plus</td><td>3.5.12</td><td>ORM增强框架</td></tr><tr><td></td><td>Redis</td><td>最新</td><td>缓存+分布式锁</td></tr><tr><td></td><td>Redisson</td><td>3.50.0</td><td>分布式工具包</td></tr><tr><td><strong>消息队列</strong></td><td>Kafka</td><td>最新</td><td>事件驱动消息中间件</td></tr><tr><td><strong>工作流</strong></td><td>Camunda BPM</td><td>7.23.0</td><td>BPMN工作流引擎</td></tr><tr><td><strong>认证授权</strong></td><td>Sa-Token</td><td>1.44.0</td><td>轻量级权限框架</td></tr><tr><td><strong>AI能力</strong></td><td>Spring AI</td><td>1.0.1</td><td>AI统一接口</td></tr><tr><td></td><td>Ollama</td><td>最新</td><td>本地AI模型服务</td></tr><tr><td></td><td>DeepSeek</td><td>最新</td><td>云端AI模型</td></tr><tr><td><strong>文件存储</strong></td><td>MinIO</td><td>8.5.13</td><td>对象存储服务</td></tr><tr><td></td><td>腾讯云VOD</td><td>2.1.5</td><td>视频点播服务</td></tr><tr><td><strong>任务调度</strong></td><td>XXL-Job</td><td>3.2.0</td><td>分布式任务调度</td></tr><tr><td><strong>工具库</strong></td><td>Lombok</td><td>1.18.20</td><td>简化Java代码</td></tr><tr><td></td><td>Hutool</td><td>5.8.39</td><td>Java工具集</td></tr><tr><td><strong>监控日志</strong></td><td>Logback</td><td>最新</td><td>日志框架</td></tr><tr><td></td><td>Knife4j</td><td>最新</td><td>接口文档</td></tr></tbody></table><h3 id="2-3-网络拓扑"><a href="#2-3-网络拓扑" class="headerlink" title="2.3 网络拓扑"></a>2.3 网络拓扑</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss">VPC网络 (<span class="hljs-number">172.16</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">16</span>)<br>│<br>├── 应用子网 (<span class="hljs-number">172.16</span>.<span class="hljs-number">1.0</span>/<span class="hljs-number">24</span>)<br>│   ├── user-service (<span class="hljs-number">10003</span>)<br>│   ├── <span class="hljs-attribute">content</span>-service (<span class="hljs-number">10001</span>)<br>│   ├── interaction-service (<span class="hljs-number">10004</span>)<br>│   └── camunda-service (<span class="hljs-number">10002</span>)<br>│<br>├── 中间件子网 (<span class="hljs-number">172.16</span>.<span class="hljs-number">2.0</span>/<span class="hljs-number">24</span>)<br>│   ├── MySQL (<span class="hljs-number">3306</span>)<br>│   ├── Redis (<span class="hljs-number">6379</span>)<br>│   ├── Kafka (<span class="hljs-number">9092</span>)<br>│   └── Nacos (<span class="hljs-number">8848</span>)<br>│<br>└── 外部服务<br>    ├── 腾讯云VOD API<br>    ├── MinIO (<span class="hljs-number">9000</span>)<br>    ├── Ollama (<span class="hljs-number">11434</span>)<br>    └── 阿里云短信API<br></code></pre></td></tr></table></figure><hr><h2 id="三、服务模块详解"><a href="#三、服务模块详解" class="headerlink" title="三、服务模块详解"></a>三、服务模块详解</h2><h3 id="3-1-user-service（用户服务-BFF层）"><a href="#3-1-user-service（用户服务-BFF层）" class="headerlink" title="3.1 user-service（用户服务&#x2F;BFF层）"></a>3.1 user-service（用户服务&#x2F;BFF层）</h3><h4 id="3-1-1-服务定位"><a href="#3-1-1-服务定位" class="headerlink" title="3.1.1 服务定位"></a>3.1.1 服务定位</h4><p><strong>角色</strong>: Backend For Frontend（前端后端聚合层）</p><p><strong>核心职责</strong>:</p><ol><li>用户认证与授权（短信验证码登录、JWT令牌管理）</li><li>聚合内容服务和互动服务的数据</li><li>提供统一的App端API接口</li><li>分布式缓存代理（三高防护）</li><li>Kafka事件生产（点赞事件）</li></ol><h4 id="3-1-2-技术架构"><a href="#3-1-2-技术架构" class="headerlink" title="3.1.2 技术架构"></a>3.1.2 技术架构</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs scss">Controller层<br>  ├── LoginController (认证相关)<br>  ├── VerifyCodeController (验证码)<br>  ├── AppHomeController (首页数据)<br>  └── AppInteractionController (互动功能)<br>       ↓<br>BizService层（业务编排）<br>  ├── UserAuthServiceImpl (用户认证业务)<br>  ├── DramaBizServiceImpl (短剧业务+缓存)<br>  ├── LikeBizServiceImpl (点赞业务+Kafka生产)<br>  ├── CommentBizServiceImpl (评论业务)<br>  └── VerifyCodeServiceImpl (验证码业务)<br>       ↓<br>Feign客户端（服务调用）<br>  ├── ContentFeignClient → <span class="hljs-attribute">content</span>-service<br>  └── InteractionFeignClient → interaction-service<br>       ↓<br>Service层（数据访问）<br>  ├── UsersService<br>  ├── UserAuthsService<br>  ├── UserFollowsService<br>  └── ... (<span class="hljs-number">9</span>个Service)<br>       ↓<br>Mapper层（MyBatis-Plus）<br>  └── <span class="hljs-number">9</span>个Mapper接口 + XML<br></code></pre></td></tr></table></figure><h4 id="3-1-3-核心功能模块"><a href="#3-1-3-核心功能模块" class="headerlink" title="3.1.3 核心功能模块"></a>3.1.3 核心功能模块</h4><p><strong>1. 用户认证模块</strong></p><ul><li><strong>短信验证码登录</strong>:<ul><li>发送6位数字验证码（Redis存储5分钟）</li><li>验证通过自动注册（生成”游客+随机6位数”昵称）</li><li>Sa-Token登录并生成JWT令牌</li></ul></li><li><strong>用户信息查询</strong>:<ul><li>CompletableFuture并发查询5个维度数据</li><li>自定义线程池优化性能</li></ul></li></ul><p><strong>2. 首页数据聚合模块</strong></p><ul><li><strong>首页精选视频</strong>:<ul><li>远程调用content-service获取短剧列表</li><li>Redis手动缓存（key包含分页参数）</li><li>查询用户点赞状态（Redis Set）</li></ul></li><li><strong>短剧详情</strong>:<ul><li>使用@CacheData注解AOP缓存</li><li>布隆过滤器防止缓存穿透</li><li>Redisson分布式锁防止缓存击穿</li><li>随机过期时间防止缓存雪崩</li></ul></li></ul><p><strong>3. 互动功能模块</strong></p><ul><li><strong>点赞功能</strong>:<ul><li>登录校验</li><li>构造LikeEvent事件</li><li>发送到Kafka（Topic: like-event-topic）</li><li>生产者拦截器自动填充msgId、userId、timestamp</li></ul></li><li><strong>评论查询</strong>:<ul><li>远程调用interaction-service</li></ul></li></ul><h4 id="3-1-4-数据模型（9张表）"><a href="#3-1-4-数据模型（9张表）" class="headerlink" title="3.1.4 数据模型（9张表）"></a>3.1.4 数据模型（9张表）</h4><table><thead><tr><th>表名</th><th>说明</th><th>核心字段</th></tr></thead><tbody><tr><td>users</td><td>用户基本信息</td><td>userId, phone, nickname, avatar, gender, level, experience</td></tr><tr><td>user_auths</td><td>用户认证方式</td><td>authId, userId, authType(password&#x2F;sms&#x2F;wechat&#x2F;qq&#x2F;apple), authKey, authCredential</td></tr><tr><td>user_follows</td><td>用户关注关系</td><td>followId, followerId, followeeId, status</td></tr><tr><td>user_collections</td><td>用户收藏</td><td>collectionId, userId, dramaId, dramaTitle, dramaCover</td></tr><tr><td>user_browse_history</td><td>浏览历史</td><td>historyId, userId, dramaId, title, cover, browseTime, browseDuration</td></tr><tr><td>user_devices</td><td>用户设备</td><td>deviceId, userId, deviceType, deviceToken(推送)</td></tr><tr><td>user_blacklist</td><td>用户黑名单</td><td>blacklistId, userId, blockedUserId</td></tr><tr><td>user_level_config</td><td>用户等级配置</td><td>levelId, levelName, minExperience, maxExperience, benefits</td></tr><tr><td>user_preferences</td><td>用户偏好设置</td><td>preferenceId, userId, autoPlay, pushNotification, privacySettings</td></tr></tbody></table><h4 id="3-1-5-API接口清单"><a href="#3-1-5-API接口清单" class="headerlink" title="3.1.5 API接口清单"></a>3.1.5 API接口清单</h4><table><thead><tr><th>接口路径</th><th>方法</th><th>功能</th><th>权限</th></tr></thead><tbody><tr><td><code>/api/login</code></td><td>POST</td><td>手机验证码登录</td><td>公开</td></tr><tr><td><code>/api/userinfo</code></td><td>GET</td><td>获取当前用户信息</td><td>需登录</td></tr><tr><td><code>/api/send-code</code></td><td>POST</td><td>发送验证码</td><td>公开</td></tr><tr><td><code>/api/episodes/featured</code></td><td>GET</td><td>首页精选视频流</td><td>公开</td></tr><tr><td><code>/api/dramas/&#123;dramaId&#125;</code></td><td>GET</td><td>短剧详情</td><td>公开</td></tr><tr><td><code>/api/dramas/&#123;dramaId&#125;/episodes/all</code></td><td>GET</td><td>短剧剧集列表</td><td>公开</td></tr><tr><td><code>/api/episodes/&#123;episodeId&#125;/like</code></td><td>POST</td><td>点赞&#x2F;取消点赞</td><td>需登录</td></tr><tr><td><code>/api/episodes/&#123;episodeId&#125;/comments</code></td><td>GET</td><td>获取评论列表</td><td>公开</td></tr></tbody></table><hr><h3 id="3-2-content-service（内容服务）"><a href="#3-2-content-service（内容服务）" class="headerlink" title="3.2 content-service（内容服务）"></a>3.2 content-service（内容服务）</h3><h4 id="3-2-1-服务定位"><a href="#3-2-1-服务定位" class="headerlink" title="3.2.1 服务定位"></a>3.2.1 服务定位</h4><p><strong>角色</strong>: 核心内容管理服务</p><p><strong>核心职责</strong>:</p><ol><li>短剧、剧集、演员、分类、标签的CRUD</li><li>短剧发布流程（多表事务操作）</li><li>文件上传（MinIO对象存储）</li><li>视频转码（腾讯云VOD）</li><li>审核流程集成（调用camunda-service）</li><li>提供RPC接口给user-service</li></ol><h4 id="3-2-2-技术架构"><a href="#3-2-2-技术架构" class="headerlink" title="3.2.2 技术架构"></a>3.2.2 技术架构</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Controller层<br>  ├── DramasController (短剧管理)<br>  ├── EpisodesController (剧集管理)<br>  ├── ActorsController (演员管理)<br>  ├── CategoriesController (分类管理)<br>  ├── TagsController (标签管理)<br>  ├── PublishController (短剧发布)<br>  ├── AuthCheckController (审核检查)<br>  ├── UploadController (文件上传)<br>  └── rpc/<br>      ├── AppHomeDataController (首页数据RPC)<br>      └── TencentVodController (视频转码RPC)<br>       ↓<br>BizService层<br>  ├── DramaPublishServiceImpl (发布业务)<br>  ├── AuthCheckServiceImpl (审核业务)<br>  ├── DramaHomeServiceImpl (首页业务)<br>  └── TencentVodServiceImpl (转码业务)<br>       ↓<br>Feign客户端<br>  └── CamundaFeignClient → camunda<span class="hljs-params">-service</span><br>       ↓<br>Service层（<span class="hljs-number">10</span>个Service）<br>  ├── DramasService<br>  ├── EpisodesService<br>  ├── ActorsService<br>  └── <span class="hljs-params">...</span> (其他Service)<br>       ↓<br>Mapper层<br>  └── <span class="hljs-number">10</span>个Mapper + <span class="hljs-built_in">XML</span><br></code></pre></td></tr></table></figure><h4 id="3-2-3-核心功能模块"><a href="#3-2-3-核心功能模块" class="headerlink" title="3.2.3 核心功能模块"></a>3.2.3 核心功能模块</h4><p><strong>1. 短剧发布流程（事务性操作）</strong></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-number">1</span>. 保存短剧基本信息 → dramas表<br><span class="hljs-number">2</span>. 保存短剧与分类关联 → dram<span class="hljs-built_in">a_categories</span>表<br><span class="hljs-number">3</span>. 保存短剧与标签关联 → dram<span class="hljs-built_in">a_tags</span>表<br><span class="hljs-number">4</span>. 保存短剧与演员关联 → dram<span class="hljs-built_in">a_actors</span>表<br>   - 新演员：先插入actors表，再插入关联表<br>   - 已有演员：直接插入关联表<br><span class="hljs-number">5</span>. 保存剧集信息 → episodes表<br><span class="hljs-number">6</span>. 启动Camunda审核流程 → 调用camunda-service<br><span class="hljs-number">7</span>. 保存审核流程关系 → dram<span class="hljs-built_in">a_auth</span>表<br></code></pre></td></tr></table></figure><p><strong>2. 文件上传模块</strong></p><ul><li>使用MinIO对象存储</li><li>Bucket: “kcat”</li><li>支持图片、视频上传</li><li>返回访问URL</li></ul><p><strong>3. 视频转码模块</strong></p><ul><li><strong>信息流转码</strong>（竖屏短视频格式）:<ul><li>处理预告片或第一集</li><li>保存到dramas.trailerInfoflowUrl</li></ul></li><li><strong>画质转码</strong>（多清晰度）:<ul><li>1080p (高清) → episodes.videoUrlHd</li><li>720p (标清) → episodes.videoUrlSd</li><li>480p (低清) → episodes.videoUrlLd</li></ul></li><li><strong>转码流程</strong>:<ol><li>从MinIO下载视频到临时文件</li><li>上传到腾讯云VOD</li><li>指定转码模板</li><li>轮询PullEvents获取转码结果</li><li>ConfirmEvents确认事件</li><li>更新数据库URL</li></ol></li></ul><p><strong>4. 审核状态管理</strong></p><ul><li>AI审核状态查询</li><li>更新审核状态（审核完成后回调）</li><li>将通过审核的dramaId添加到布隆过滤器</li></ul><p><strong>5. 首页数据接口（RPC）</strong></p><ul><li><strong>查询首页精选视频</strong>:<ul><li>分页查询已上架且审核通过的短剧</li><li>返回信息流剧集</li><li>包含短剧详情、演员、标签、分类</li></ul></li><li><strong>查询短剧所有剧集</strong>:<ul><li>短剧基本信息</li><li>所有剧集列表（按集数排序）</li><li>统计信息（总集数、可观看数等）</li></ul></li><li><strong>查询短剧详情</strong>:<ul><li>封面、标题、描述</li><li>播放量、点赞数</li><li>演员信息</li></ul></li></ul><p><strong>6. 布隆过滤器维护</strong></p><ul><li>应用启动时初始化</li><li>定时任务：每晚3点增量添加短剧ID</li><li>每周重建布隆过滤器</li></ul><h4 id="3-2-4-数据模型（10张表）"><a href="#3-2-4-数据模型（10张表）" class="headerlink" title="3.2.4 数据模型（10张表）"></a>3.2.4 数据模型（10张表）</h4><table><thead><tr><th>表名</th><th>说明</th><th>核心字段</th></tr></thead><tbody><tr><td>dramas</td><td>短剧表</td><td>dramaId, title, cover, poster, trailerUrl, description, totalEpisodes, status, auditStatus</td></tr><tr><td>episodes</td><td>剧集表</td><td>episodeId, dramaId, title, episodeNumber, videoUrl(多清晰度), duration, isFree, coinPrice</td></tr><tr><td>actors</td><td>演员表</td><td>actorId, actorName, actorImg, actorInfo, birthday, nationality</td></tr><tr><td>categories</td><td>分类表</td><td>categoryId, categoryName, parentId, sort</td></tr><tr><td>tags</td><td>标签表</td><td>tagId, tagName, hotCount</td></tr><tr><td>content_audits</td><td>内容审核记录表</td><td>auditId, contentId, contentType, auditStatus, auditReason, auditor</td></tr><tr><td>drama_auth</td><td>短剧审核流程表</td><td>dramaId, processId(Camunda流程ID), stepName, authStatus</td></tr><tr><td>drama_actors</td><td>短剧演员关联表</td><td>dramaId, actorId, roleName, roleType(主角&#x2F;配角&#x2F;客串), sortOrder</td></tr><tr><td>drama_categories</td><td>短剧分类关联表</td><td>dramaId, categoryId</td></tr><tr><td>drama_tags</td><td>短剧标签关联表</td><td>dramaId, tagId</td></tr></tbody></table><h4 id="3-2-5-外部依赖"><a href="#3-2-5-外部依赖" class="headerlink" title="3.2.5 外部依赖"></a>3.2.5 外部依赖</h4><table><thead><tr><th>服务</th><th>用途</th><th>调用方式</th></tr></thead><tbody><tr><td>camunda-service</td><td>启动审核流程</td><td>Feign</td></tr><tr><td>MinIO</td><td>文件存储</td><td>MinioTemplate</td></tr><tr><td>腾讯云VOD</td><td>视频转码</td><td>VOD SDK</td></tr><tr><td>XXL-Job</td><td>定时任务（布隆过滤器重建、转码任务）</td><td>HTTP调用</td></tr><tr><td>Redis&#x2F;Redisson</td><td>布隆过滤器、缓存</td><td>Redisson客户端</td></tr></tbody></table><hr><h3 id="3-3-interaction-service（互动服务）"><a href="#3-3-interaction-service（互动服务）" class="headerlink" title="3.3 interaction-service（互动服务）"></a>3.3 interaction-service（互动服务）</h3><h4 id="3-3-1-服务定位"><a href="#3-3-1-服务定位" class="headerlink" title="3.3.1 服务定位"></a>3.3.1 服务定位</h4><p><strong>角色</strong>: 用户互动数据服务</p><p><strong>核心职责</strong>:</p><ol><li>点赞、评论、弹幕、分享、举报等互动功能</li><li>Kafka消费点赞事件（最终一致性）</li><li>更新Redis缓存中的点赞数</li><li>内容统计数据管理</li><li>提供RPC接口给user-service</li></ol><h4 id="3-3-2-技术架构"><a href="#3-3-2-技术架构" class="headerlink" title="3.3.2 技术架构"></a>3.3.2 技术架构</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Controller层<br>  └── rpc/<br>      ├── LikeActionController (点赞接口)<br>      └── CommentsController (评论接口)<br>       ↓<br>BizService层<br>  ├── LikeBizServiceImpl (点赞业务)<br>  └── CommentBizServiceImpl (评论业务)<br>       ↓<br>Kafka监听器<br>  └── LikeEventListener (点赞事件消费)<br>       ↓<br>Service层（<span class="hljs-number">9</span>个Service）<br>  ├── UserLikesService<br>  ├── CommentsService<br>  ├── ContentStatisticsService<br>  ├── DanmakuService<br>  └── <span class="hljs-params">...</span> (其他Service)<br>       ↓<br>Mapper层<br>  └── <span class="hljs-number">9</span>个Mapper + <span class="hljs-built_in">XML</span><br></code></pre></td></tr></table></figure><h4 id="3-3-3-核心功能模块"><a href="#3-3-3-核心功能模块" class="headerlink" title="3.3.3 核心功能模块"></a>3.3.3 核心功能模块</h4><p><strong>1. 点赞功能（Kafka异步消费）</strong></p><ul><li><strong>Kafka监听器</strong>:<ul><li>Topic: <code>like-event-topic</code></li><li>消费LikeEvent事件</li><li>更新数据库点赞记录（幂等操作）</li><li>更新Redis缓存中的点赞数（首页精选视频缓存）</li><li>手动ACK确认</li></ul></li><li><strong>幂等性处理</strong>:<ul><li>布隆过滤器 + Redis Set记录已处理消息ID</li><li>数据库维护消息表（利用ACID）</li></ul></li></ul><p><strong>2. 评论功能</strong></p><ul><li><strong>查询评论列表</strong>:<ul><li>过滤条件：parentId&#x3D;0（一级评论）、status&#x3D;1（正常）、auditStatus&#x3D;1（审核通过）</li><li>排序规则：按点赞数和创建时间倒序</li><li>分页查询</li></ul></li><li><strong>TODO</strong>: 判断当前用户是否对评论点赞（Kafka + 双写一致性）</li></ul><p><strong>3. 弹幕功能（待实现）</strong></p><ul><li>实时弹幕发送</li><li>弹幕时间轴定位</li><li>敏感词过滤</li></ul><p><strong>4. 分享与举报（待实现）</strong></p><ul><li>多平台分享统计</li><li>内容举报与审核</li></ul><h4 id="3-3-4-数据模型（9张表）"><a href="#3-3-4-数据模型（9张表）" class="headerlink" title="3.3.4 数据模型（9张表）"></a>3.3.4 数据模型（9张表）</h4><table><thead><tr><th>表名</th><th>说明</th><th>核心字段</th></tr></thead><tbody><tr><td>user_likes</td><td>用户点赞记录</td><td>likeId, userId, targetId, targetType(短剧&#x2F;剧集&#x2F;评论&#x2F;弹幕), status(0取消&#x2F;1有效)</td></tr><tr><td>comments</td><td>评论表</td><td>commentId, userId, dramaId, episodeId, content, parentId, rootId, likeCount, status, auditStatus</td></tr><tr><td>content_statistics</td><td>内容统计</td><td>statId, contentId, contentType, commentCount, danmakuCount, likeCount, hotScore</td></tr><tr><td>danmaku</td><td>弹幕表</td><td>danmakuId, episodeId, userId, content, timePoint, color, position, fontSize, speed</td></tr><tr><td>danmaku_filter_words</td><td>弹幕过滤词</td><td>wordId, word, status</td></tr><tr><td>user_dislikes</td><td>用户点踩记录</td><td>dislikeId, userId, targetId, targetType</td></tr><tr><td>share_records</td><td>分享记录</td><td>shareId, userId, contentId, contentType, sharePlatform</td></tr><tr><td>reports</td><td>举报记录</td><td>reportId, userId, contentId, contentType, reportReason, reportType, status</td></tr><tr><td>user_interaction_statistics</td><td>用户互动统计</td><td>statId, userId, totalLikes, totalComments, totalShares, totalCollections</td></tr></tbody></table><h4 id="3-3-5-Redis缓存架构"><a href="#3-3-5-Redis缓存架构" class="headerlink" title="3.3.5 Redis缓存架构"></a>3.3.5 Redis缓存架构</h4><p><strong>RedisService工具类</strong>:</p><ol><li><strong>缓存穿透解决方案</strong>:<ul><li>空占位符: “NULL”（TTL&#x3D;30分钟）</li></ul></li><li><strong>缓存雪崩解决方案</strong>:<ul><li>随机过期时间（0-99999秒）</li></ul></li><li><strong>分布式锁实现</strong>:<ul><li>Lua脚本保证原子性（SETNX + 过期时间）</li><li>释放锁时比较值再删除</li></ul></li></ol><p><strong>缓存Key设计</strong>:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">HOME_EPISODES_FEATURED_CACHE_KEY</span> = <span class="hljs-string">&quot;home:episodes:featured:&#123;pageNum&#125;:&#123;pageSize&#125;&quot;</span><br><span class="hljs-attr">DRAMA_DETAIL_CACHE_KEY</span> = <span class="hljs-string">&quot;drama:detail:&#123;dramaId&#125;&quot;</span><br><span class="hljs-attr">DRAMA_EPISODES_CACHE_KEY</span> = <span class="hljs-string">&quot;drama:episodes:&#123;dramaId&#125;&quot;</span><br><span class="hljs-attr">LIKE_EPISODE_KEY</span> = <span class="hljs-string">&quot;like:episode:&#123;episodeId&#125;&quot;</span>  <span class="hljs-comment"># Set结构存储点赞用户ID</span><br><span class="hljs-attr">PHONE_VERIFY_CODE_KEY</span> = <span class="hljs-string">&quot;phone:code:&#123;phone&#125;&quot;</span><br></code></pre></td></tr></table></figure><hr><h3 id="3-4-camunda-service（工作流服务）"><a href="#3-4-camunda-service（工作流服务）" class="headerlink" title="3.4 camunda-service（工作流服务）"></a>3.4 camunda-service（工作流服务）</h3><h4 id="3-4-1-服务定位"><a href="#3-4-1-服务定位" class="headerlink" title="3.4.1 服务定位"></a>3.4.1 服务定位</h4><p><strong>角色</strong>: 工作流引擎与审核编排服务</p><p><strong>核心职责</strong>:</p><ol><li>BPMN流程定义部署</li><li>短剧审核流程编排（AI审核 + 人工审核）</li><li>AI情感分析（Ollama模型）</li><li>审核流程管理（启动、查询、完成任务）</li><li>审核通过后触发后续任务（转码、数据入库）</li></ol><h4 id="3-4-2-技术架构"><a href="#3-4-2-技术架构" class="headerlink" title="3.4.2 技术架构"></a>3.4.2 技术架构</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss">Controller层<br>  ├── ProcessDeployController (流程部署)<br>  └── ProcessManagerController (流程管理)<br>       ↓<br>Service层<br>  ├── ProcessManagerServiceImpl (流程管理服务)<br>  └── OllamaEmotionalAnalysisServiceImpl (情感分析服务)<br>       ↓<br>Biz层（业务委托处理器）<br>  └── CamundaJavaDelegateHandler<br>       ├── aiCheck (AI审核)<br>       ├── updateDramaAuthStatus (更新审核状态)<br>       ├── tencentVodTranslate (触发转码)<br>       └── ragDataHandler (RAG数据入库)<br>       ↓<br>Feign客户端<br>  └── ContentFeignClient → <span class="hljs-attribute">content</span>-service<br>       ↓<br>Camunda引擎<br>  ├── RepositoryService (流程部署)<br>  ├── RuntimeService (流程启动)<br>  └── TaskService (任务管理)<br></code></pre></td></tr></table></figure><h4 id="3-4-3-短剧审核流程（DramaAuthProcess）"><a href="#3-4-3-短剧审核流程（DramaAuthProcess）" class="headerlink" title="3.4.3 短剧审核流程（DramaAuthProcess）"></a>3.4.3 短剧审核流程（DramaAuthProcess）</h4><p><strong>BPMN流程定义</strong>:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs">开始 → AI内容审核 → 人工审核 → 审核决策网关<br>                                    ├─ 不通过 → 更新数据库状态 → 结束<br>                                    └─ 通过 → 并行网关<br>                                              ├─ 腾讯云转码<br>                                              └─ RAG数据入库<br>                                              ↓<br>                                         并行网关汇聚<br>                                              ↓<br>                                         更新数据库状态<br>                                              ↓<br>                                            结束<br></code></pre></td></tr></table></figure><p><strong>流程变量</strong>:</p><ul><li><strong>输入变量</strong>: dramaId, title, description</li><li><strong>AI审核结果</strong>: titleAuthResult, descriptionAuthResult</li><li><strong>人工审核结果</strong>: approve(Boolean), auditStatus, auditReason</li></ul><p><strong>条件表达式</strong>:</p><ul><li>审核不通过: <code>$&#123;!approve&#125;</code></li><li>审核通过: <code>$&#123;approve&#125;</code></li></ul><p><strong>核心节点详解</strong>:</p><ol><li><p><strong>AI内容审核（Service Task）</strong>:</p><ul><li>JavaDelegate: <code>$&#123;aiCheck&#125;</code></li><li>功能: 使用Ollama AI模型对标题和简介进行情感分析</li><li>结果: 0-负面, 1-正面</li></ul></li><li><p><strong>人工审核（User Task）</strong>:</p><ul><li>任务名称: “人工审核”</li><li>审核员手动执行审核</li><li>提交审核结果（通过&#x2F;不通过、原因）</li></ul></li><li><p><strong>腾讯云转码（Service Task）</strong>:</p><ul><li>JavaDelegate: <code>$&#123;tecentVodTranslator&#125;</code></li><li>功能: 触发content-service的视频转码接口</li></ul></li><li><p><strong>RAG数据入库（Service Task）</strong>:</p><ul><li>JavaDelegate: <code>$&#123;ragDataHandler&#125;</code></li><li>功能: 将审核通过的数据入RAG知识库（待实现）</li></ul></li><li><p><strong>更新数据库状态（Service Task）</strong>:</p><ul><li>JavaDelegate: <code>$&#123;updateDramaAuthStatus&#125;</code></li><li>功能: 调用content-service更新审核状态</li></ul></li></ol><h4 id="3-4-4-API接口清单"><a href="#3-4-4-API接口清单" class="headerlink" title="3.4.4 API接口清单"></a>3.4.4 API接口清单</h4><table><thead><tr><th>接口路径</th><th>方法</th><th>功能</th></tr></thead><tbody><tr><td><code>/workflow/deploy</code></td><td>POST</td><td>部署BPMN流程文件</td></tr><tr><td><code>/workflow/process/dramaAuth/start</code></td><td>POST</td><td>启动短剧审核流程</td></tr><tr><td><code>/workflow/process/variables/&#123;processId&#125;</code></td><td>GET</td><td>获取流程变量</td></tr><tr><td><code>/workflow/process/manual/authTask</code></td><td>PUT</td><td>执行人工审核任务</td></tr></tbody></table><h4 id="3-4-5-AI能力集成"><a href="#3-4-5-AI能力集成" class="headerlink" title="3.4.5 AI能力集成"></a>3.4.5 AI能力集成</h4><p><strong>Ollama情感分析</strong>:</p><ul><li><strong>模型</strong>: 本地部署的Ollama模型</li><li><strong>输入</strong>: 文本（标题或简介）</li><li><strong>输出</strong>: 0-负面, 1-正面</li><li><strong>系统提示词</strong>: 指导AI识别正负面情感</li></ul><p><strong>Spring AI配置</strong>:</p><ul><li><code>OllamaChatModel</code>: Ollama客户端</li><li><code>Prompt</code>: 构建System Message + User Message</li><li>返回结果转换为整数</li></ul><hr><h2 id="四、核心业务流程"><a href="#四、核心业务流程" class="headerlink" title="四、核心业务流程"></a>四、核心业务流程</h2><h3 id="4-1-短剧发布与审核完整流程"><a href="#4-1-短剧发布与审核完整流程" class="headerlink" title="4.1 短剧发布与审核完整流程"></a>4.1 短剧发布与审核完整流程</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs markdown">┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段1：短剧发布（content-service）                                    │<br>└─────────────────────────────────────────────────────────────────────┘<br>用户提交短剧信息（基本信息+分类+标签+演员+剧集）<br>  ↓<br>PublishController接收请求<br>  ↓<br>DramaPublishService开启事务<br>  ↓<br><span class="hljs-bullet">1.</span> 保存短剧信息 → dramas表 → 生成dramaId<br><span class="hljs-bullet">2.</span> 保存短剧与分类关联 → drama<span class="hljs-emphasis">_categories表</span><br><span class="hljs-emphasis">3. 保存短剧与标签关联 → drama_</span>tags表<br><span class="hljs-bullet">4.</span> 保存短剧与演员关联 → drama<span class="hljs-emphasis">_actors表（新演员先插入actors表）</span><br><span class="hljs-emphasis">5. 保存剧集信息 → episodes表</span><br><span class="hljs-emphasis">6. 启动Camunda审核流程 → Feign调用camunda-service</span><br><span class="hljs-emphasis">7. 保存审核流程关系 → drama_</span>auth表（记录processId）<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段2：AI自动审核（camunda-service）                                  │<br>└─────────────────────────────────────────────────────────────────────┘<br>Camunda流程启动 → 执行AI内容审核节点<br>  ↓<br>CamundaJavaDelegateHandler.aiCheck()<br>  ↓<br><span class="hljs-bullet">1.</span> 从流程变量获取dramaId、title、description<br><span class="hljs-bullet">2.</span> 调用Ollama情感分析服务分析标题 → titleAuthResult (0/1)<br><span class="hljs-bullet">3.</span> 调用Ollama情感分析服务分析简介 → descriptionAuthResult (0/1)<br><span class="hljs-bullet">4.</span> 将AI审核结果存入流程变量<br>  ↓<br>进入人工审核节点（User Task）<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段3：人工审核（camunda-service）                                    │<br>└─────────────────────────────────────────────────────────────────────┘<br>审核人员通过管理后台查看待审核短剧<br>  ↓<br>调用 /workflow/process/manual/authTask 接口<br>  ↓<br>ProcessManagerService执行任务：<br><span class="hljs-bullet">1.</span> 查询当前待处理任务<br><span class="hljs-bullet">2.</span> 任务领取（claim）<br><span class="hljs-bullet">3.</span> 完成任务并提交审核结果（approve, auditStatus, auditReason）<br>  ↓<br>流程进入决策网关<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段4a：审核不通过分支                                                │<br>└─────────────────────────────────────────────────────────────────────┘<br>审核决策网关判断：approve = false<br>  ↓<br>执行 updateDramaAuthStatus 节点<br>  ↓<br>CamundaJavaDelegateHandler.updateDramaAuthStatus()<br>  ↓<br><span class="hljs-bullet">1.</span> 构建DramaAuthCompleteDto对象<br><span class="hljs-bullet">2.</span> Feign调用content-service的 /dramas/updateDramaAuthStatus 接口<br><span class="hljs-bullet">3.</span> 更新dramas表的审核状态（auditStatus=2，auditReason=原因）<br><span class="hljs-bullet">4.</span> 更新drama<span class="hljs-emphasis">_auth表</span><br><span class="hljs-emphasis">  ↓</span><br><span class="hljs-emphasis">流程结束</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">┌─────────────────────────────────────────────────────────────────────┐</span><br><span class="hljs-emphasis">│ 阶段4b：审核通过分支                                                  │</span><br><span class="hljs-emphasis">└─────────────────────────────────────────────────────────────────────┘</span><br><span class="hljs-emphasis">审核决策网关判断：approve = true</span><br><span class="hljs-emphasis">  ↓</span><br><span class="hljs-emphasis">进入并行网关（同时执行两个任务）</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">┌──────────────────────────┐    ┌──────────────────────────┐</span><br><span class="hljs-emphasis">│ 任务1：腾讯云视频转码     │    │ 任务2：RAG数据入库        │</span><br><span class="hljs-emphasis">│ (tecentVodTranslator)    │    │ (ragDataHandler)         │</span><br><span class="hljs-emphasis">└──────────────────────────┘    └──────────────────────────┘</span><br><span class="hljs-emphasis">         ↓                               ↓</span><br><span class="hljs-emphasis">CamundaJavaDelegateHandler           CamundaJavaDelegateHandler</span><br><span class="hljs-emphasis">.tencentVodTranslate()               .ragDataHandler()</span><br><span class="hljs-emphasis">         ↓                               ↓</span><br><span class="hljs-emphasis">Feign调用content-service             打印日志（待实现）</span><br><span class="hljs-emphasis">/tencent/vod/translate?dramaId=xxx</span><br><span class="hljs-emphasis">         ↓</span><br><span class="hljs-emphasis">XXL-Job定时任务开始转码</span><br><span class="hljs-emphasis">         ↓</span><br><span class="hljs-emphasis">     (详见4.2)</span><br><span class="hljs-emphasis">         ↓</span><br><span class="hljs-emphasis">┌─────────────────────────────────────────────────────────────────────┐</span><br><span class="hljs-emphasis">│ 并行网关汇聚（等待两个任务完成）                                       │</span><br><span class="hljs-emphasis">└─────────────────────────────────────────────────────────────────────┘</span><br><span class="hljs-emphasis">         ↓</span><br><span class="hljs-emphasis">执行 updateDramaAuthStatus 节点</span><br><span class="hljs-emphasis">         ↓</span><br><span class="hljs-emphasis">CamundaJavaDelegateHandler.updateDramaAuthStatus()</span><br><span class="hljs-emphasis">         ↓</span><br><span class="hljs-emphasis">1. 更新dramas表的审核状态（auditStatus=1）</span><br><span class="hljs-emphasis">2. 更新drama_</span>auth表<br><span class="hljs-bullet">3.</span> 将dramaId添加到BloomFilter<br><span class="hljs-code">         ↓</span><br><span class="hljs-code">流程结束</span><br></code></pre></td></tr></table></figure><h4 id="Mermaid时序图"><a href="#Mermaid时序图" class="headerlink" title="Mermaid时序图"></a>Mermaid时序图</h4><pre><code class=" mermaid">sequenceDiagram    participant User as 用户    participant Content as content-service    participant DB as MySQL数据库    participant Camunda as camunda-service    participant Ollama as Ollama AI    participant Admin as 审核人员    participant XXL as XXL-Job    Note over User,XXL: 阶段1：短剧发布    User-&gt;&gt;Content: 提交短剧信息    activate Content    Content-&gt;&gt;DB: 开启事务    Content-&gt;&gt;DB: 1. 保存短剧信息(dramas)    Content-&gt;&gt;DB: 2. 保存分类关联(drama_categories)    Content-&gt;&gt;DB: 3. 保存标签关联(drama_tags)    Content-&gt;&gt;DB: 4. 保存演员关联(drama_actors)    Content-&gt;&gt;DB: 5. 保存剧集信息(episodes)    Note over Content,Camunda: 启动审核流程    Content-&gt;&gt;Camunda: Feign调用启动审核流程    activate Camunda    Camunda--&gt;&gt;Content: 返回processId    Content-&gt;&gt;DB: 6. 保存审核流程关系(drama_auth)    Content-&gt;&gt;DB: 提交事务    Content--&gt;&gt;User: 发布成功    deactivate Content    Note over Camunda,Ollama: 阶段2：AI自动审核    Camunda-&gt;&gt;Camunda: 执行AI内容审核节点    Camunda-&gt;&gt;Ollama: 分析标题情感    Ollama--&gt;&gt;Camunda: titleAuthResult(0/1)    Camunda-&gt;&gt;Ollama: 分析简介情感    Ollama--&gt;&gt;Camunda: descriptionAuthResult(0/1)    Camunda-&gt;&gt;Camunda: 存入流程变量    Note over Camunda,Admin: 阶段3：人工审核    Camunda-&gt;&gt;Admin: 分配人工审核任务    Admin-&gt;&gt;Camunda: 提交审核结果(approve)    alt 审核不通过        Note over Camunda,Content: 阶段4a：审核不通过        Camunda-&gt;&gt;Camunda: 执行updateDramaAuthStatus        Camunda-&gt;&gt;Content: Feign调用更新审核状态        activate Content        Content-&gt;&gt;DB: 更新dramas审核状态(rejected)        Content-&gt;&gt;DB: 更新drama_auth表        Content--&gt;&gt;Camunda: 更新成功        deactivate Content        Camunda-&gt;&gt;Camunda: 流程结束    else 审核通过        Note over Camunda,XXL: 阶段4b：审核通过        Camunda-&gt;&gt;Camunda: 进入并行网关        par 并行任务1：视频转码            Camunda-&gt;&gt;Content: Feign调用触发转码            activate Content            Content-&gt;&gt;XXL: 创建转码任务            XXL--&gt;&gt;Content: 任务创建成功            deactivate Content        and 并行任务2：RAG数据入库            Camunda-&gt;&gt;Camunda: 执行ragDataHandler            Note right of Camunda: 待实现        end        Note over Camunda,Content: 并行网关汇聚        Camunda-&gt;&gt;Camunda: 执行updateDramaAuthStatus        Camunda-&gt;&gt;Content: Feign调用更新审核状态        activate Content        Content-&gt;&gt;DB: 更新dramas审核状态(approved)        Content-&gt;&gt;DB: 更新drama_auth表        Content-&gt;&gt;Content: 添加dramaId到BloomFilter        Content--&gt;&gt;Camunda: 更新成功        deactivate Content        Camunda-&gt;&gt;Camunda: 流程结束    end    deactivate Camunda</code></pre><h3 id="4-2-视频转码流程（content-service）"><a href="#4-2-视频转码流程（content-service）" class="headerlink" title="4.2 视频转码流程（content-service）"></a>4.2 视频转码流程（content-service）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs markdown">┌─────────────────────────────────────────────────────────────────────┐<br>│ 转码触发：camunda-service调用content-service转码接口                  │<br>└─────────────────────────────────────────────────────────────────────┘<br>TencentVodController.translate(dramaId)<br>  ↓<br>创建XXL-Job任务（TranslateJob）<br>  ↓<br>XXL-Job调度执行<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 任务1：信息流转码（竖屏短视频格式）                                    │<br>└─────────────────────────────────────────────────────────────────────┘<br><span class="hljs-bullet">1.</span> 查询dramas表，获取trailerUrl（预告片URL）或第一集videoUrl<br><span class="hljs-bullet">2.</span> 从MinIO下载视频到临时文件<br><span class="hljs-bullet">3.</span> 上传到腾讯云VOD<br><span class="hljs-bullet">4.</span> 指定信息流转码模板ID<br><span class="hljs-bullet">5.</span> 轮询PullEvents拉取转码事件<br><span class="hljs-bullet">6.</span> 获取转码结果URL<br><span class="hljs-bullet">7.</span> 更新dramas.trailerInfoflowUrl<br><span class="hljs-bullet">8.</span> ConfirmEvents确认事件<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 任务2：画质转码（1080p/720p/480p）                                    │<br>└─────────────────────────────────────────────────────────────────────┘<br><span class="hljs-bullet">1.</span> 查询episodes表，获取所有剧集<br><span class="hljs-bullet">2.</span> 批量处理每一集：<br>   a. 从MinIO下载视频到临时文件<br>   b. 上传到腾讯云VOD<br>   c. 指定画质转码模板ID（1080p/720p/480p）<br>   d. 轮询PullEvents拉取转码事件<br>   e. 获取转码结果URL（3个清晰度）<br>   f. 更新episodes表的videoUrlHd/Sd/Ld字段<br>   g. ConfirmEvents确认事件<br><span class="hljs-bullet">3.</span> 完成所有剧集转码<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 转码完成                                                             │<br>└─────────────────────────────────────────────────────────────────────┘<br>短剧状态：已审核+已转码 → 可以上架展示<br></code></pre></td></tr></table></figure><h4 id="Mermaid流程图"><a href="#Mermaid流程图" class="headerlink" title="Mermaid流程图"></a>Mermaid流程图</h4><pre><code class=" mermaid">sequenceDiagram    participant Camunda as camunda-service    participant Content as content-service    participant XXL as XXL-Job    participant DB as MySQL    participant MinIO as MinIO对象存储    participant VOD as 腾讯云VOD    Note over Camunda,Content: 转码触发    Camunda-&gt;&gt;Content: Feign调用/tencent/vod/translate    activate Content    Content-&gt;&gt;XXL: 创建转码任务    Content--&gt;&gt;Camunda: 任务创建成功    deactivate Content    Note over XXL,VOD: XXL-Job执行转码任务    XXL-&gt;&gt;XXL: 调度执行TranslateJob    rect rgb(240, 248, 255)        Note over XXL,VOD: 任务1：信息流转码        XXL-&gt;&gt;DB: 查询dramas表获取trailerUrl        DB--&gt;&gt;XXL: 返回视频URL        XXL-&gt;&gt;MinIO: 下载视频到临时文件        MinIO--&gt;&gt;XXL: 返回视频文件        XXL-&gt;&gt;VOD: 上传视频        VOD--&gt;&gt;XXL: 返回fileId        XXL-&gt;&gt;VOD: 指定信息流转码模板        loop 轮询转码状态            XXL-&gt;&gt;VOD: PullEvents拉取转码事件            VOD--&gt;&gt;XXL: 返回转码进度        end        VOD--&gt;&gt;XXL: 返回转码结果URL        XXL-&gt;&gt;VOD: ConfirmEvents确认事件        XXL-&gt;&gt;DB: 更新dramas.trailerInfoflowUrl    end    rect rgb(255, 250, 240)        Note over XXL,VOD: 任务2：画质转码(1080p/720p/480p)        XXL-&gt;&gt;DB: 查询episodes表获取所有剧集        DB--&gt;&gt;XXL: 返回剧集列表        loop 每一集剧集            XXL-&gt;&gt;MinIO: 下载剧集视频            MinIO--&gt;&gt;XXL: 返回视频文件            XXL-&gt;&gt;VOD: 上传视频            VOD--&gt;&gt;XXL: 返回fileId            XXL-&gt;&gt;VOD: 指定画质转码模板(1080p/720p/480p)            loop 轮询转码状态                XXL-&gt;&gt;VOD: PullEvents拉取转码事件                VOD--&gt;&gt;XXL: 返回转码进度            end            VOD--&gt;&gt;XXL: 返回3个清晰度URL            XXL-&gt;&gt;VOD: ConfirmEvents确认事件            XXL-&gt;&gt;DB: 更新episodes(videoUrlHd/Sd/Ld)        end    end    Note over XXL,DB: 转码完成    XXL-&gt;&gt;DB: 短剧状态: 已审核+已转码</code></pre><h3 id="4-3-用户登录流程（user-service）"><a href="#4-3-用户登录流程（user-service）" class="headerlink" title="4.3 用户登录流程（user-service）"></a>4.3 用户登录流程（user-service）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs markdown">┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段1：发送验证码                                                     │<br>└─────────────────────────────────────────────────────────────────────┘<br>用户输入手机号 → 点击&quot;获取验证码&quot;<br>  ↓<br>调用 /api/send-code 接口<br>  ↓<br>VerifyCodeServiceImpl.sendVerifyCode(phone)<br>  ↓<br><span class="hljs-bullet">1.</span> 生成6位随机数字验证码<br><span class="hljs-bullet">2.</span> 调用SmsTemplate发送短信（阿里云短信服务）<br><span class="hljs-bullet">3.</span> 验证码存入Redis（key: phone:verify:code:&#123;phone&#125;，TTL=5分钟）<br><span class="hljs-bullet">4.</span> 返回成功响应（包含expireTime）<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段2：验证码登录                                                     │<br>└─────────────────────────────────────────────────────────────────────┘<br>用户输入手机号+验证码 → 点击&quot;登录&quot;<br>  ↓<br>调用 /api/login 接口（LoginReqVo: phone, code）<br>  ↓<br>UserAuthServiceImpl.login(LoginReqVo)<br>  ↓<br><span class="hljs-bullet">1.</span> 从Redis查询验证码（key: phone:verify:code:&#123;phone&#125;）<br><span class="hljs-bullet">2.</span> 验证码不存在或不匹配 → 返回&quot;验证码错误&quot;<br><span class="hljs-bullet">3.</span> 验证通过 → 删除Redis中的验证码（防止重复使用）<br><span class="hljs-bullet">4.</span> 查询users表（phone = ?）<br><span class="hljs-bullet">5.</span> 用户不存在？<br>   ├─ 是 → 调用register(phone)<br>   │       ├─ 生成随机昵称（游客+6位随机数）<br>   │       ├─ 插入users表<br>   │       └─ 返回userId<br>   └─ 否 → 直接获取userId<br><span class="hljs-bullet">6.</span> Sa-Token登录：StpUtil.login(userId, LoginConfig携带phone、nickname等扩展信息)<br><span class="hljs-bullet">7.</span> 生成JWT令牌：StpUtil.getTokenValue()<br><span class="hljs-bullet">8.</span> 计算过期时间：StpUtil.getTokenTimeout()<br><span class="hljs-bullet">9.</span> 返回LoginResVo（token, expires）<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段3：后续请求携带Token                                              │<br>└─────────────────────────────────────────────────────────────────────┘<br>客户端后续请求：<br>  Header: Authorization: Bearer &#123;token&#125;<br>  ↓<br>Sa-Token拦截器验证Token<br>  ↓<br>StpUtil.isLogin() → true<br>  ↓<br>业务代码获取当前用户：StpUtil.getLoginIdAsLong()<br></code></pre></td></tr></table></figure><h4 id="Mermaid时序图-1"><a href="#Mermaid时序图-1" class="headerlink" title="Mermaid时序图"></a>Mermaid时序图</h4><pre><code class=" mermaid">sequenceDiagram    participant User as 用户    participant App as App客户端    participant UserSvc as user-service    participant Redis as Redis    participant SMS as 阿里云短信    participant DB as MySQL    participant SaToken as Sa-Token    Note over User,SMS: 阶段1：发送验证码    User-&gt;&gt;App: 输入手机号，点击&quot;获取验证码&quot;    App-&gt;&gt;UserSvc: POST /api/send-code    activate UserSvc    UserSvc-&gt;&gt;UserSvc: 生成6位随机验证码    UserSvc-&gt;&gt;SMS: 发送短信验证码    SMS--&gt;&gt;UserSvc: 发送成功    UserSvc-&gt;&gt;Redis: 存储验证码(TTL=5分钟)    Redis--&gt;&gt;UserSvc: 存储成功    UserSvc--&gt;&gt;App: 返回成功(expireTime)    deactivate UserSvc    App--&gt;&gt;User: 显示&quot;验证码已发送&quot;    Note over User,SaToken: 阶段2：验证码登录    User-&gt;&gt;App: 输入验证码，点击&quot;登录&quot;    App-&gt;&gt;UserSvc: POST /api/login &#123;phone, code&#125;    activate UserSvc    UserSvc-&gt;&gt;Redis: 查询验证码    Redis--&gt;&gt;UserSvc: 返回验证码    alt 验证码错误或过期        UserSvc--&gt;&gt;App: 返回&quot;验证码错误&quot;        App--&gt;&gt;User: 显示错误提示    else 验证码正确        UserSvc-&gt;&gt;Redis: 删除验证码(防止重复使用)        UserSvc-&gt;&gt;DB: 查询users表(phone)        DB--&gt;&gt;UserSvc: 返回用户信息        alt 用户不存在            UserSvc-&gt;&gt;UserSvc: 生成随机昵称(游客+6位数)            UserSvc-&gt;&gt;DB: 插入users表            DB--&gt;&gt;UserSvc: 返回userId        else 用户已存在            UserSvc-&gt;&gt;UserSvc: 获取userId        end        UserSvc-&gt;&gt;SaToken: StpUtil.login(userId, 扩展信息)        activate SaToken        SaToken-&gt;&gt;Redis: 存储Token会话信息        SaToken--&gt;&gt;UserSvc: 返回JWT Token        deactivate SaToken        UserSvc--&gt;&gt;App: 返回&#123;token, expires&#125;        deactivate UserSvc        App-&gt;&gt;App: 存储Token到本地        App--&gt;&gt;User: 登录成功，跳转首页    end    Note over User,SaToken: 阶段3：后续请求携带Token    User-&gt;&gt;App: 浏览首页    App-&gt;&gt;UserSvc: GET /api/episodes/featured&lt;br/&gt;Header: Authorization: Bearer &#123;token&#125;    activate UserSvc    UserSvc-&gt;&gt;SaToken: 验证Token    activate SaToken    SaToken-&gt;&gt;Redis: 查询Token会话信息    Redis--&gt;&gt;SaToken: 返回会话信息    SaToken--&gt;&gt;UserSvc: 验证通过，返回userId    deactivate SaToken    UserSvc-&gt;&gt;UserSvc: 获取当前用户ID    UserSvc-&gt;&gt;UserSvc: 执行业务逻辑    UserSvc--&gt;&gt;App: 返回数据    deactivate UserSvc    App--&gt;&gt;User: 展示数据</code></pre><h3 id="4-4-首页精选视频流程（user-service-content-service）"><a href="#4-4-首页精选视频流程（user-service-content-service）" class="headerlink" title="4.4 首页精选视频流程（user-service + content-service）"></a>4.4 首页精选视频流程（user-service + content-service）</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段1：用户请求首页精选（user-service）                                │<br>└─────────────────────────────────────────────────────────────────────┘<br>App请求 /api/episodes/featured?pageNum=1&amp;pageSize=10<br>  ↓<br>AppHomeController.getEpisodesFeatured(PageReqDto)<br>  ↓<br>DramaBizServiceImpl.getEpisodesFeatured(PageReqDto)<br>  ↓<br><span class="hljs-number">1.</span> 拼接缓存<span class="hljs-keyword">Key</span>: <span class="hljs-string">&quot;home:episodes:featured:1:10&quot;</span><br><span class="hljs-number">2.</span> 查询Redis缓存<br><span class="hljs-number">3.</span> 缓存命中？<br>   ├─ 是 → 直接返回缓存数据 → 跳转到阶段<span class="hljs-number">3</span><br>   └─ 否 → 继续下一步<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段<span class="hljs-number">2</span>：远程调用content-service获取数据                                │<br>└─────────────────────────────────────────────────────────────────────┘<br>Feign调用 ContentFeignClient.getEpisodesFeatured(PageReqDto)<br>  ↓<br>content-service的AppHomeDataController接收请求<br>  ↓<br>DramaHomeServiceImpl.getEpisodesFeatured(pageNum, pageSize)<br>  ↓<br><span class="hljs-number">1.</span> 查询数据库（dramas表）：<br>   - 条件：status=<span class="hljs-number">1</span>（已上架）、auditStatus=<span class="hljs-number">1</span>（审核通过）<br>   - 分页：<span class="hljs-keyword">offset</span>=(pageNum<span class="hljs-number">-1</span>)*pageSize, <span class="hljs-keyword">limit</span>=pageSize<br>   - 排序：按创建时间倒序<br><span class="hljs-number">2.</span> 对每个短剧：<br>   a. 查询信息流剧集（trailerInfoflowUrl或第一集）<br>   b. 查询演员信息（关联drama_actors、actors表）<br>   c. 查询标签列表（关联drama_tags、tags表）<br>   d. 查询分类列表（关联drama_categories、categories表）<br>   <span class="hljs-built_in">e</span>. 组装HomeFeaturedDto对象<br><span class="hljs-number">3.</span> 计算分页信息（total, hasMore）<br><span class="hljs-number">4.</span> 返回数据给<span class="hljs-keyword">user</span>-service<br>  ↓<br><span class="hljs-keyword">user</span>-service接收到数据<br>  ↓<br><span class="hljs-number">1.</span> 将数据写入Redis缓存（TTL=<span class="hljs-number">7</span>天+随机<span class="hljs-number">5</span>位数秒）<br><span class="hljs-number">2.</span> 继续下一步<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段<span class="hljs-number">3</span>：查询点赞状态（<span class="hljs-keyword">user</span>-service）                                    │<br>└─────────────────────────────────────────────────────────────────────┘<br>遍历HomeFeaturedDto列表<br>  ↓<br>对每个剧集：<br><span class="hljs-number">1.</span> 获取episodeId<br><span class="hljs-number">2.</span> 判断用户是否登录？<br>   ├─ 否 → liked = <span class="hljs-literal">false</span><br>   └─ 是 → 查询Redis <span class="hljs-keyword">Set</span>（<span class="hljs-keyword">key</span>: <span class="hljs-string">&quot;like:episode:&#123;episodeId&#125;&quot;</span>）<br>           判断当前userId是否在<span class="hljs-keyword">Set</span>中<br>           ├─ 在 → liked = <span class="hljs-literal">true</span><br>           └─ 不在 → liked = <span class="hljs-literal">false</span><br><span class="hljs-number">3.</span> 设置liked字段<br>  ↓<br>返回完整数据给App端<br></code></pre></td></tr></table></figure><h4 id="Mermaid时序图-2"><a href="#Mermaid时序图-2" class="headerlink" title="Mermaid时序图"></a>Mermaid时序图</h4><pre><code class=" mermaid">sequenceDiagram    participant App as App客户端    participant UserSvc as user-service    participant Redis as Redis缓存    participant ContentSvc as content-service    participant DB as MySQL    Note over App,Redis: 阶段1：查询缓存    App-&gt;&gt;UserSvc: GET /api/episodes/featured?pageNum=1&amp;pageSize=10    activate UserSvc    UserSvc-&gt;&gt;UserSvc: 拼接缓存Key&lt;br/&gt;&quot;home:episodes:featured:1:10&quot;    UserSvc-&gt;&gt;Redis: 查询缓存    Redis--&gt;&gt;UserSvc: 返回缓存结果    alt 缓存命中        UserSvc-&gt;&gt;UserSvc: 获取缓存数据        Note over UserSvc: 跳转到阶段3    else 缓存未命中        Note over UserSvc,DB: 阶段2：远程调用content-service        UserSvc-&gt;&gt;ContentSvc: Feign调用getEpisodesFeatured        activate ContentSvc        ContentSvc-&gt;&gt;DB: 查询dramas表&lt;br/&gt;(status=1, auditStatus=1, 分页)        DB--&gt;&gt;ContentSvc: 返回短剧列表        loop 每个短剧            ContentSvc-&gt;&gt;DB: 查询信息流剧集(episodes)            ContentSvc-&gt;&gt;DB: 查询演员信息(drama_actors + actors)            ContentSvc-&gt;&gt;DB: 查询标签列表(drama_tags + tags)            ContentSvc-&gt;&gt;DB: 查询分类列表(drama_categories + categories)            DB--&gt;&gt;ContentSvc: 返回关联数据            ContentSvc-&gt;&gt;ContentSvc: 组装HomeFeaturedDto        end        ContentSvc-&gt;&gt;ContentSvc: 计算分页信息(total, hasMore)        ContentSvc--&gt;&gt;UserSvc: 返回数据列表        deactivate ContentSvc        UserSvc-&gt;&gt;Redis: 写入缓存(TTL=7天+随机时间)        Redis--&gt;&gt;UserSvc: 写入成功    end    Note over UserSvc,Redis: 阶段3：查询点赞状态    alt 用户未登录        UserSvc-&gt;&gt;UserSvc: 所有剧集liked=false    else 用户已登录        UserSvc-&gt;&gt;UserSvc: 获取当前userId        loop 遍历每个剧集            UserSvc-&gt;&gt;Redis: 查询Set &quot;like:episode:&#123;episodeId&#125;&quot;            Redis--&gt;&gt;UserSvc: 返回点赞用户集合            alt userId在Set中                UserSvc-&gt;&gt;UserSvc: 设置liked=true            else userId不在Set中                UserSvc-&gt;&gt;UserSvc: 设置liked=false            end        end    end    UserSvc--&gt;&gt;App: 返回完整数据(含点赞状态)    deactivate UserSvc    App-&gt;&gt;App: 渲染首页视频流</code></pre><h3 id="4-5-短剧详情查询流程（user-service-content-service）"><a href="#4-5-短剧详情查询流程（user-service-content-service）" class="headerlink" title="4.5 短剧详情查询流程（user-service + content-service）"></a>4.5 短剧详情查询流程（user-service + content-service）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs markdown">┌─────────────────────────────────────────────────────────────────────┐<br>│ 完整缓存流程（三高防护）                                              │<br>└─────────────────────────────────────────────────────────────────────┘<br>App请求 /api/dramas/&#123;dramaId&#125;<br>  ↓<br>AppHomeController.getDramaDetail(dramaId)<br>  ↓<br>DramaBizServiceImpl.getDramaDetail(dramaId) [@CacheData注解]<br>  ↓<br>CacheDataAspect切面拦截<br>  ↓<br><span class="hljs-bullet">1.</span> 拼接缓存Key: &quot;drama:detail:&#123;dramaId&#125;&quot;<br><span class="hljs-bullet">2.</span> 查询Redis缓存<br><span class="hljs-bullet">3.</span> 缓存命中？<br>   ├─ 是 → 直接返回缓存数据 → 结束<br>   └─ 否 → 继续下一步（缓存未命中）<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 防护1：布隆过滤器防止缓存穿透                                          │<br>└─────────────────────────────────────────────────────────────────────┘<br><span class="hljs-bullet">4.</span> 查询布隆过滤器（bloomFilterKey: &quot;bloom:filter:dramas:id&quot;）<br><span class="hljs-bullet">5.</span> 布隆过滤器不存在该dramaId？<br>   ├─ 是 → 直接返回null（防止查询不存在的数据） → 结束<br>   └─ 否 → 继续下一步（dramaId可能存在）<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 防护2：分布式锁防止缓存击穿                                            │<br>└─────────────────────────────────────────────────────────────────────┘<br><span class="hljs-bullet">6.</span> 尝试获取Redisson分布式锁（lockKey: &quot;lock:drama:detail:&#123;dramaId&#125;&quot;）<br><span class="hljs-bullet">7.</span> 获取锁成功？<br>   ├─ 是 → 继续下一步（当前线程负责查询数据库）<br>   └─ 否 → 等待2秒 → 重新查询Redis缓存 → 返回<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 查询数据库并回写缓存                                                  │<br>└─────────────────────────────────────────────────────────────────────┘<br><span class="hljs-bullet">8.</span> Feign调用ContentFeignClient.getDramaDetail(dramaId)<br><span class="hljs-bullet">9.</span> content-service查询数据库：<br>   a. 查询dramas表<br>   b. 查询演员信息<br>   c. 查询标签列表<br>   d. 组装HomeDramaInfoDto<br><span class="hljs-bullet">10.</span> 数据不存在？<br><span class="hljs-code">    ├─ 是 → 写入空占位符到Redis（TTL=30分钟） → 释放锁 → 返回null</span><br><span class="hljs-code">    └─ 否 → 继续下一步</span><br><span class="hljs-code"></span><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 防护3：随机过期时间防止缓存雪崩                                        │<br>└─────────────────────────────────────────────────────────────────────┘<br><span class="hljs-bullet">11.</span> 写入Redis缓存：<br><span class="hljs-bullet">    -</span> TTL = 7天 + 随机5位数秒（最大约19小时）<br><span class="hljs-bullet">    -</span> 避免大量key同时失效<br><span class="hljs-bullet">12.</span> 释放分布式锁<br><span class="hljs-bullet">13.</span> 返回数据<br></code></pre></td></tr></table></figure><h4 id="Mermaid流程图（三高防护机制）"><a href="#Mermaid流程图（三高防护机制）" class="headerlink" title="Mermaid流程图（三高防护机制）"></a>Mermaid流程图（三高防护机制）</h4><pre><code class=" mermaid">flowchart TD    Start([App请求短剧详情]) --&gt; A[user-service接收请求]    A --&gt; B[&quot;@CacheData切面拦截&quot;]    B --&gt; C&#123;查询Redis缓存&#125;    C --&gt;|缓存命中| End1([返回缓存数据])    C --&gt;|缓存未命中| D&#123;&quot;查询布隆过滤器&lt;br/&gt;bloom:filter:dramas:id&quot;&#125;    D --&gt;|dramaId不存在| End2([&quot;返回null&lt;br/&gt;防护1: 缓存穿透&quot;])    D --&gt;|dramaId可能存在| E&#123;&quot;尝试获取分布式锁&lt;br/&gt;lock:drama:detail&quot;&#125;    E --&gt;|获取锁失败| F[等待2秒]    F --&gt; G&#123;重新查询缓存&#125;    G --&gt;|有数据| End3([返回缓存数据])    G --&gt;|无数据| End4([返回null])    E --&gt;|获取锁成功| H[Feign调用content-service]    H --&gt; I[查询MySQL数据库]    I --&gt; J&#123;数据存在?&#125;    J --&gt;|不存在| K[&quot;写入空占位符&lt;br/&gt;TTL:30分钟&quot;]    K --&gt; L[释放分布式锁]    L --&gt; End5([&quot;返回null&lt;br/&gt;防护1: 缓存穿透&quot;])    J --&gt;|存在| M[&quot;写入Redis缓存&lt;br/&gt;TTL:7天+随机时间&quot;]    M --&gt; N[释放分布式锁]    N --&gt; End6([&quot;返回数据&lt;br/&gt;防护3: 缓存雪崩&quot;])    style D fill:#e1f5ff    style E fill:#fff4e1    style M fill:#e8f5e9    style K fill:#ffebee</code></pre><p><strong>三高防护说明</strong>:</p><ul><li><strong>防护1（缓存穿透）</strong>: 布隆过滤器快速判断数据是否存在 + 空值缓存</li><li><strong>防护2（缓存击穿）</strong>: Redisson分布式锁，只有一个线程回源查询</li><li><strong>防护3（缓存雪崩）</strong>: 随机过期时间（7天+0-27小时），避免集体失效</li></ul><h3 id="4-6-点赞功能流程（user-service-interaction-service-Kafka）"><a href="#4-6-点赞功能流程（user-service-interaction-service-Kafka）" class="headerlink" title="4.6 点赞功能流程（user-service + interaction-service + Kafka）"></a>4.6 点赞功能流程（user-service + interaction-service + Kafka）</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs nix">┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段<span class="hljs-number">1</span>：用户点击点赞（user-service）                                    │<br>└─────────────────────────────────────────────────────────────────────┘<br>App请求 <span class="hljs-operator">/</span>api<span class="hljs-operator">/</span>episodes<span class="hljs-operator">/</span>&#123;episodeId&#125;<span class="hljs-symbol">/like</span><br>  <span class="hljs-params">Body:</span> &#123; <span class="hljs-params">action:</span> <span class="hljs-string">&quot;like&quot;</span> &#125;  <span class="hljs-operator">//</span> 或 <span class="hljs-string">&quot;unlike&quot;</span><br>  <span class="hljs-params">Header:</span> <span class="hljs-params">Authorization:</span> Bearer &#123;token&#125;<br>  ↓<br>AppInteractionController.likeEpisode(episodeId, EpisodesLikeReqVo)<br>  ↓<br><span class="hljs-number">1</span>. Sa-Token登录校验：StpUtil.isLogin() → 未登录抛出异常<br><span class="hljs-number">2</span>. 获取当前用户ID：StpUtil.getLoginIdAsLong()<br>  ↓<br>LikeBizServiceImpl.likeEpisode(episodeId, reqVo)<br>  ↓<br><span class="hljs-number">3</span>. 构造LikeEvent事件对象：<br>   <span class="hljs-operator">-</span> <span class="hljs-params">episodeId:</span> 剧集ID<br>   <span class="hljs-operator">-</span> <span class="hljs-params">action:</span> <span class="hljs-string">&quot;like&quot;</span> 或 <span class="hljs-string">&quot;unlike&quot;</span><br>   <span class="hljs-operator">-</span> <span class="hljs-params">msgId:</span> <span class="hljs-literal">null</span>（生产者拦截器自动填充）<br>   <span class="hljs-operator">-</span> <span class="hljs-params">userId:</span> <span class="hljs-literal">null</span>（生产者拦截器自动填充）<br>   <span class="hljs-operator">-</span> <span class="hljs-params">timestamp:</span> <span class="hljs-literal">null</span>（生产者拦截器自动填充）<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段<span class="hljs-number">2</span>：发送Kafka消息                                                  │<br>└─────────────────────────────────────────────────────────────────────┘<br><span class="hljs-number">4</span>. KafkaTemplate.send()：<br>   <span class="hljs-operator">-</span> <span class="hljs-params">Topic:</span> <span class="hljs-string">&quot;like-event-topic&quot;</span><br>   <span class="hljs-operator">-</span> <span class="hljs-params">Key:</span> <span class="hljs-string">&quot;like-event-&#123;episodeId&#125;-&#123;userId&#125;&quot;</span>（保证同一用户对同一剧集的操作顺序）<br>   <span class="hljs-operator">-</span> <span class="hljs-params">Value:</span> LikeEvent对象<br>  ↓<br><span class="hljs-number">5</span>. KafkaEventProducerInterceptor拦截器自动填充：<br>   <span class="hljs-operator">-</span> <span class="hljs-params">msgId:</span> IdUtil.getSnowflakeNextId()（雪花算法生成唯一ID）<br>   <span class="hljs-operator">-</span> <span class="hljs-params">userId:</span> StpUtil.getLoginIdAsLong()<br>   <span class="hljs-operator">-</span> <span class="hljs-params">timestamp:</span> System.currentTimeMillis()<br>  ↓<br><span class="hljs-number">6</span>. 消息发送到Kafka Broker<br><span class="hljs-number">7</span>. 返回成功响应给App（不等待消费完成）<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段<span class="hljs-number">3</span>：Kafka消费者处理（user-service 和 interaction-service）          │<br>└─────────────────────────────────────────────────────────────────────┘<br><br>┌──────────────────────────────────────────────────────────────────┐<br>│ 消费者<span class="hljs-number">1</span>：user-service (LikeEventListener)                         │<br>└──────────────────────────────────────────────────────────────────┘<br><span class="hljs-number">8</span>. 监听<span class="hljs-params">Topic:</span> <span class="hljs-string">&quot;like-event-topic&quot;</span><br><span class="hljs-number">9</span>. 接收LikeEvent消息<br><span class="hljs-number">10</span>. 更新Redis缓存（首页精选视频缓存）：<br>    a. 查询Redis缓存（<span class="hljs-params">key:</span> <span class="hljs-string">&quot;home:episodes:featured:&#123;pageNum&#125;:&#123;pageSize&#125;&quot;</span>）<br>    b. 遍历短剧列表，找到对应的episodeId<br>    c. action <span class="hljs-operator">=</span> <span class="hljs-string">&quot;like&quot;</span> <span class="hljs-operator">?</span><br>       ├─ 是 → likeCount <span class="hljs-operator">+</span> <span class="hljs-number">1</span><br>       └─ 否 → likeCount <span class="hljs-operator">-</span> <span class="hljs-number">1</span><br>    d. 回写Redis缓存<br><span class="hljs-number">11</span>. 更新Redis Set（点赞状态）：<br>    a. <span class="hljs-params">key:</span> <span class="hljs-string">&quot;like:episode:&#123;episodeId&#125;&quot;</span><br>    b. action <span class="hljs-operator">=</span> <span class="hljs-string">&quot;like&quot;</span> <span class="hljs-operator">?</span><br>       ├─ 是 → sadd userId<br>       └─ 否 → srem userId<br><span class="hljs-number">12</span>. 手动ACK确认<br><br>┌──────────────────────────────────────────────────────────────────┐<br>│ 消费者<span class="hljs-number">2</span>：interaction-service (LikeEventListener)                  │<br>└──────────────────────────────────────────────────────────────────┘<br><span class="hljs-number">13</span>. 监听<span class="hljs-params">Topic:</span> <span class="hljs-string">&quot;like-event-topic&quot;</span><br><span class="hljs-number">14</span>. 接收LikeEvent消息<br><span class="hljs-number">15</span>. LikeBizServiceImpl.likeEpisode()：<br>    a. 查询user_likes表：<br>       <span class="hljs-operator">-</span> userId <span class="hljs-operator">=</span> <span class="hljs-operator">?</span><br>       <span class="hljs-operator">-</span> targetId <span class="hljs-operator">=</span> episodeId<br>       <span class="hljs-operator">-</span> targetType <span class="hljs-operator">=</span> <span class="hljs-number">2</span>（剧集）<br>    b. 记录存在？<br>       ├─ 是 → 更新status字段（action<span class="hljs-operator">=</span><span class="hljs-string">&quot;like&quot;</span> → <span class="hljs-number">1</span>, <span class="hljs-string">&quot;unlike&quot;</span> → <span class="hljs-number">0</span>）<br>       └─ 否 → 插入新记录<br><span class="hljs-number">16</span>. 更新Redis缓存（首页精选视频缓存中的点赞数）<br><span class="hljs-number">17</span>. 手动ACK确认<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 最终一致性保证                                                        │<br>└─────────────────────────────────────────────────────────────────────┘<br><span class="hljs-operator">-</span> 数据库持久化（interaction-service）<br><span class="hljs-operator">-</span> Redis缓存更新（user-service <span class="hljs-operator">+</span> interaction-service）<br><span class="hljs-operator">-</span> 幂等性保证：同一消息多次消费结果一致（数据库幂等更新 <span class="hljs-operator">+</span> Redis Set操作幂等）<br></code></pre></td></tr></table></figure><h4 id="Mermaid时序图（Kafka异步处理）"><a href="#Mermaid时序图（Kafka异步处理）" class="headerlink" title="Mermaid时序图（Kafka异步处理）"></a>Mermaid时序图（Kafka异步处理）</h4><pre><code class=" mermaid">sequenceDiagram    participant App as App客户端    participant UserSvc as user-service    participant KafkaP as Kafka Producer    participant Kafka as Kafka Broker&lt;br/&gt;(like-event-topic)    participant UserConsumer as user-service&lt;br/&gt;LikeEventListener    participant InterConsumer as interaction-service&lt;br/&gt;LikeEventListener    participant Redis as Redis    participant DB as MySQL    Note over App,KafkaP: 阶段1：用户点击点赞    App-&gt;&gt;UserSvc: POST /api/episodes/&#123;episodeId&#125;/like&lt;br/&gt;&#123;action: &quot;like&quot;&#125;    activate UserSvc    UserSvc-&gt;&gt;UserSvc: Sa-Token登录校验    UserSvc-&gt;&gt;UserSvc: 获取userId    Note over UserSvc,Kafka: 阶段2：发送Kafka消息    UserSvc-&gt;&gt;KafkaP: 构造LikeEvent事件    activate KafkaP    KafkaP-&gt;&gt;KafkaP: 拦截器自动填充&lt;br/&gt;msgId(雪花ID), userId, timestamp    KafkaP-&gt;&gt;Kafka: 发送消息&lt;br/&gt;Key: like-event-&#123;episodeId&#125;-&#123;userId&#125;    deactivate KafkaP    Kafka--&gt;&gt;UserSvc: 发送成功    UserSvc--&gt;&gt;App: 返回成功响应(不等待消费)    deactivate UserSvc    App-&gt;&gt;App: 立即更新UI(乐观更新)    Note over Kafka,DB: 阶段3：Kafka异步消费    par 消费者1: user-service        Kafka-&gt;&gt;UserConsumer: 推送LikeEvent消息        activate UserConsumer        UserConsumer-&gt;&gt;Redis: 查询首页缓存&lt;br/&gt;&quot;home:episodes:featured:*&quot;        Redis--&gt;&gt;UserConsumer: 返回缓存数据        alt action = &quot;like&quot;            UserConsumer-&gt;&gt;UserConsumer: likeCount + 1        else action = &quot;unlike&quot;            UserConsumer-&gt;&gt;UserConsumer: likeCount - 1        end        UserConsumer-&gt;&gt;Redis: 更新缓存中的点赞数        Redis--&gt;&gt;UserConsumer: 更新成功        UserConsumer-&gt;&gt;Redis: 更新点赞状态Set&lt;br/&gt;&quot;like:episode:&#123;episodeId&#125;&quot;        alt action = &quot;like&quot;            Redis-&gt;&gt;Redis: sadd userId        else action = &quot;unlike&quot;            Redis-&gt;&gt;Redis: srem userId        end        Redis--&gt;&gt;UserConsumer: 更新成功        UserConsumer-&gt;&gt;Kafka: 手动ACK确认        deactivate UserConsumer    and 消费者2: interaction-service        Kafka-&gt;&gt;InterConsumer: 推送LikeEvent消息        activate InterConsumer        InterConsumer-&gt;&gt;DB: 查询user_likes表&lt;br/&gt;(userId, episodeId)        DB--&gt;&gt;InterConsumer: 返回查询结果        alt 记录已存在            alt action = &quot;like&quot;                InterConsumer-&gt;&gt;DB: UPDATE status = 1            else action = &quot;unlike&quot;                InterConsumer-&gt;&gt;DB: UPDATE status = 0            end        else 记录不存在            InterConsumer-&gt;&gt;DB: INSERT 新记录        end        DB--&gt;&gt;InterConsumer: 更新成功        InterConsumer-&gt;&gt;Redis: 更新缓存中的点赞数        Redis--&gt;&gt;InterConsumer: 更新成功        InterConsumer-&gt;&gt;Kafka: 手动ACK确认        deactivate InterConsumer    end    Note over UserConsumer,InterConsumer: 最终一致性保证&lt;br/&gt;数据库持久化 + Redis缓存同步</code></pre><p><strong>流程说明</strong>:</p><ol><li><strong>异步响应</strong>: 用户点赞后立即返回成功，不等待消费完成（降低响应时间）</li><li><strong>并行消费</strong>: user-service和interaction-service同时消费消息，互不阻塞</li><li><strong>最终一致性</strong>: 数据库持久化 + Redis缓存最终同步</li><li><strong>幂等性保证</strong>:<ul><li>数据库: 通过唯一索引 + UPDATE操作保证幂等</li><li>Redis Set: sadd&#x2F;srem操作天然幂等</li></ul></li></ol><hr><h2 id="五、服务间交互关系"><a href="#五、服务间交互关系" class="headerlink" title="五、服务间交互关系"></a>五、服务间交互关系</h2><h3 id="5-1-服务依赖关系图"><a href="#5-1-服务依赖关系图" class="headerlink" title="5.1 服务依赖关系图"></a>5.1 服务依赖关系图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql">┌──────────────────────────────────────────────────────────────────┐<br>│                         <span class="hljs-keyword">user</span><span class="hljs-operator">-</span>service                             │<br>│                      (BFF聚合层<span class="hljs-operator">/</span>API网关)                          │<br>└───────────┬─────────────────────────┬──────────────────────────┘<br>            │                         │<br>            │ Feign                   │ Feign<br>            ▼                         ▼<br>┌────────────────────────┐   ┌────────────────────────┐<br>│   content<span class="hljs-operator">-</span>service      │   │  interaction<span class="hljs-operator">-</span>service   │<br>│                        │   │                        │<br>│  ┌──────────────────┐ │   │  ┌──────────────────┐  │<br>│  │ Feign            │ │   │  │ Kafka Consumer   │  │<br>│  │   ↓              │ │   │  │   ↓              │  │<br>│  │ camunda<span class="hljs-operator">-</span>service  │ │   │  │ <span class="hljs-keyword">user</span><span class="hljs-operator">-</span>service     │  │<br>│  └──────────────────┘ │   │  └──────────────────┘  │<br>└────────────────────────┘   └────────────────────────┘<br>            ↓                         ↑<br>            │ Feign                   │ Kafka<br>            ▼                         │<br>┌────────────────────────┐            │<br>│   camunda<span class="hljs-operator">-</span>service      │            │<br>│                        │            │<br>│  ┌──────────────────┐ │            │<br>│  │ Feign            │ │            │<br>│  │   ↓              │ │            │<br>│  │ content<span class="hljs-operator">-</span>service  │ │            │<br>│  └──────────────────┘ │            │<br>└────────────────────────┘            │<br>                                      │<br>┌─────────────────────────────────────┴───────────────────────────┐<br>│                         Kafka集群                                │<br>│     Topic: <span class="hljs-keyword">like</span><span class="hljs-operator">-</span>event<span class="hljs-operator">-</span>topic (<span class="hljs-number">10</span>分区)                             │<br>│     生产者: <span class="hljs-keyword">user</span><span class="hljs-operator">-</span>service                                         │<br>│     消费者: <span class="hljs-keyword">user</span><span class="hljs-operator">-</span>service <span class="hljs-operator">+</span> interaction<span class="hljs-operator">-</span>service                   │<br>└──────────────────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure><h3 id="5-2-Feign调用关系表"><a href="#5-2-Feign调用关系表" class="headerlink" title="5.2 Feign调用关系表"></a>5.2 Feign调用关系表</h3><table><thead><tr><th>调用方</th><th>被调用方</th><th>接口</th><th>用途</th></tr></thead><tbody><tr><td>user-service</td><td>content-service</td><td>POST &#x2F;home&#x2F;featured&#x2F;infoflow</td><td>查询首页精选视频</td></tr><tr><td>user-service</td><td>content-service</td><td>POST &#x2F;home&#x2F;dramas&#x2F;{dramaId}&#x2F;episodes&#x2F;all</td><td>查询短剧剧集列表</td></tr><tr><td>user-service</td><td>content-service</td><td>POST &#x2F;home&#x2F;dramas&#x2F;{dramaId}</td><td>查询短剧详情</td></tr><tr><td>user-service</td><td>interaction-service</td><td>GET &#x2F;interaction&#x2F;comments</td><td>查询评论列表</td></tr><tr><td>content-service</td><td>camunda-service</td><td>POST &#x2F;workflow&#x2F;process&#x2F;dramaAuth&#x2F;start</td><td>启动短剧审核流程</td></tr><tr><td>content-service</td><td>camunda-service</td><td>GET &#x2F;workflow&#x2F;process&#x2F;variables&#x2F;{processId}</td><td>查询流程变量</td></tr><tr><td>content-service</td><td>camunda-service</td><td>PUT &#x2F;workflow&#x2F;process&#x2F;manual&#x2F;authTask</td><td>执行人工审核任务</td></tr><tr><td>camunda-service</td><td>content-service</td><td>PUT &#x2F;dramas&#x2F;updateDramaAuthStatus</td><td>更新短剧审核状态</td></tr><tr><td>camunda-service</td><td>content-service</td><td>GET &#x2F;tencent&#x2F;vod&#x2F;translate</td><td>触发视频转码</td></tr></tbody></table><h3 id="5-3-Kafka主题与消费者关系"><a href="#5-3-Kafka主题与消费者关系" class="headerlink" title="5.3 Kafka主题与消费者关系"></a>5.3 Kafka主题与消费者关系</h3><table><thead><tr><th>Topic</th><th>生产者</th><th>消费者</th><th>消息类型</th><th>用途</th></tr></thead><tbody><tr><td>like-event-topic</td><td>user-service</td><td>user-service + interaction-service</td><td>LikeEvent</td><td>点赞事件异步处理</td></tr></tbody></table><p><strong>消息分区策略</strong>:</p><ul><li>Key设计: <code>like-event-&#123;episodeId&#125;-&#123;userId&#125;</code></li><li>保证同一用户对同一剧集的操作顺序性</li><li>10个分区，均匀分布</li></ul><p><strong>消费者组</strong>:</p><ul><li>user-service: 更新Redis缓存中的点赞数和点赞状态</li><li>interaction-service: 更新数据库点赞记录</li></ul><h3 id="5-4-数据流向图"><a href="#5-4-数据流向图" class="headerlink" title="5.4 数据流向图"></a>5.4 数据流向图</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css">┌─────────────────────────────────────────────────────────────────────┐<br>│ 用户操作 → user-service → <span class="hljs-attribute">content</span>-service → camunda-service         │<br>│             ↓              ↓                  ↓                       │<br>│          Redis缓存      MySQL数据库       Camunda引擎               │<br>│             ↑              ↑                  ↓                       │<br>│             └──────────────┴───────────── <span class="hljs-attribute">content</span>-service           │<br>│                                               ↓                       │<br>│                                          腾讯云VOD转码                │<br>│                                               ↓                       │<br>│                                          MySQL数据库                 │<br>└─────────────────────────────────────────────────────────────────────┘<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 用户点赞 → user-service → Kafka → interaction-service               │<br>│             ↓                       ↓                                 │<br>│          Redis缓存              MySQL数据库                          │<br>│             ↑                       ↑                                 │<br>│             └───── Kafka ──────────┘                                 │<br>└─────────────────────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure><hr><h2 id="六、数据库设计"><a href="#六、数据库设计" class="headerlink" title="六、数据库设计"></a>六、数据库设计</h2><h3 id="6-1-数据库架构"><a href="#6-1-数据库架构" class="headerlink" title="6.1 数据库架构"></a>6.1 数据库架构</h3><p><strong>数据库实例</strong>: MySQL 8.0+<br><strong>字符集</strong>: UTF8MB4<br><strong>存储引擎</strong>: InnoDB<br><strong>数据库数量</strong>: 4个业务数据库</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kcat_user</span>       (用户服务数据库 - <span class="hljs-number">9</span>张表)<br><span class="hljs-attribute">kcat_content</span>    (内容服务数据库 - <span class="hljs-number">10</span>张表)<br><span class="hljs-attribute">kcat_interaction</span> (互动服务数据库 - <span class="hljs-number">9</span>张表)<br><span class="hljs-attribute">kcat_camunda</span>    (工作流服务数据库 - Camunda引擎表 + <span class="hljs-number">1</span>张业务表)<br></code></pre></td></tr></table></figure><h3 id="6-2-核心表设计"><a href="#6-2-核心表设计" class="headerlink" title="6.2 核心表设计"></a>6.2 核心表设计</h3><h4 id="6-2-1-用户服务（kcat-user）"><a href="#6-2-1-用户服务（kcat-user）" class="headerlink" title="6.2.1 用户服务（kcat_user）"></a>6.2.1 用户服务（kcat_user）</h4><p><strong>users（用户表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> users (<br>  user_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,<br>  phone <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;手机号&#x27;</span>,<br>  nickname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;昵称&#x27;</span>,<br>  avatar <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;头像URL&#x27;</span>,<br>  gender TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;性别(0未知/1男/2女)&#x27;</span>,<br>  birthday <span class="hljs-type">DATE</span> COMMENT <span class="hljs-string">&#x27;生日&#x27;</span>,<br>  level <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> COMMENT <span class="hljs-string">&#x27;用户等级&#x27;</span>,<br>  experience <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;经验值&#x27;</span>,<br>  coin_balance <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;金币余额&#x27;</span>,<br>  vip_expire_time DATETIME COMMENT <span class="hljs-string">&#x27;VIP到期时间&#x27;</span>,<br>  status TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> COMMENT <span class="hljs-string">&#x27;状态(0禁用/1正常)&#x27;</span>,<br>  create_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  update_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  INDEX idx_phone (phone),<br>  INDEX idx_nickname (nickname),<br>  INDEX idx_level (level)<br>) COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户基本信息表&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>user_auths（用户认证表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> user_auths (<br>  auth_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,<br>  user_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;用户ID&#x27;</span>,<br>  auth_type <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;认证类型(password/sms/wechat/qq/apple)&#x27;</span>,<br>  auth_key <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;认证标识(手机号/openid等)&#x27;</span>,<br>  auth_credential <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;认证凭证(密码hash/access_token)&#x27;</span>,<br>  create_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  update_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  <span class="hljs-keyword">UNIQUE</span> KEY uk_auth_type_key (auth_type, auth_key),<br>  INDEX idx_user_id (user_id)<br>) COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户认证方式表&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>user_follows（用户关注关系表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> user_follows (<br>  follow_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,<br>  follower_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;关注者ID&#x27;</span>,<br>  followee_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;被关注者ID&#x27;</span>,<br>  status TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> COMMENT <span class="hljs-string">&#x27;状态(0取消/1有效)&#x27;</span>,<br>  create_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  update_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  <span class="hljs-keyword">UNIQUE</span> KEY uk_follower_followee (follower_id, followee_id),<br>  INDEX idx_follower (follower_id),<br>  INDEX idx_followee (followee_id)<br>) COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户关注关系表&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="6-2-2-内容服务（kcat-content）"><a href="#6-2-2-内容服务（kcat-content）" class="headerlink" title="6.2.2 内容服务（kcat_content）"></a>6.2.2 内容服务（kcat_content）</h4><p><strong>dramas（短剧表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> dramas (<br>  drama_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,<br>  title <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;标题&#x27;</span>,<br>  sub_title <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) COMMENT <span class="hljs-string">&#x27;副标题&#x27;</span>,<br>  cover <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;封面URL&#x27;</span>,<br>  poster <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;海报URL&#x27;</span>,<br>  trailer_url <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;预告片URL&#x27;</span>,<br>  trailer_infoflow_url <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;信息流预告片URL&#x27;</span>,<br>  description TEXT COMMENT <span class="hljs-string">&#x27;简介&#x27;</span>,<br>  story_line TEXT COMMENT <span class="hljs-string">&#x27;剧情介绍&#x27;</span>,<br>  director <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) COMMENT <span class="hljs-string">&#x27;导演&#x27;</span>,<br>  screenwriter <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) COMMENT <span class="hljs-string">&#x27;编剧&#x27;</span>,<br>  production_company <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) COMMENT <span class="hljs-string">&#x27;制作公司&#x27;</span>,<br>  release_date <span class="hljs-type">DATE</span> COMMENT <span class="hljs-string">&#x27;发布日期&#x27;</span>,<br>  total_episodes <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;总集数&#x27;</span>,<br>  episode_duration <span class="hljs-type">INT</span> COMMENT <span class="hljs-string">&#x27;单集时长(秒)&#x27;</span>,<br>  total_duration <span class="hljs-type">INT</span> COMMENT <span class="hljs-string">&#x27;总时长(秒)&#x27;</span>,<br>  <span class="hljs-keyword">language</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;zh-CN&#x27;</span> COMMENT <span class="hljs-string">&#x27;语言&#x27;</span>,<br>  region <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) COMMENT <span class="hljs-string">&#x27;地区&#x27;</span>,<br>  <span class="hljs-keyword">year</span> <span class="hljs-type">INT</span> COMMENT <span class="hljs-string">&#x27;年份&#x27;</span>,<br>  quality <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) COMMENT <span class="hljs-string">&#x27;画质&#x27;</span>,<br>  age_rating <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) COMMENT <span class="hljs-string">&#x27;年龄分级&#x27;</span>,<br>  is_finished TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;是否完结(0连载/1完结)&#x27;</span>,<br>  is_vip TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;是否VIP(0否/1是)&#x27;</span>,<br>  is_new TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;是否新剧(0否/1是)&#x27;</span>,<br>  is_hot TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;是否热播(0否/1是)&#x27;</span>,<br>  is_recommended TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;是否推荐(0否/1是)&#x27;</span>,<br>  play_count <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;播放次数&#x27;</span>,<br>  like_count <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;点赞数&#x27;</span>,<br>  comment_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;评论数&#x27;</span>,<br>  share_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;分享数&#x27;</span>,<br>  collection_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;收藏数&#x27;</span>,<br>  follow_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;追剧数&#x27;</span>,<br>  rating_score <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;评分&#x27;</span>,<br>  rating_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;评分人数&#x27;</span>,<br>  status TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;上架状态(0下架/1上架)&#x27;</span>,<br>  audit_status TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;审核状态(0待审核/1通过/2拒绝)&#x27;</span>,<br>  audit_reason <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;审核拒绝原因&#x27;</span>,<br>  sort_order <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;排序&#x27;</span>,<br>  create_by <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>),<br>  create_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  update_by <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>),<br>  update_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  INDEX idx_title (title),<br>  INDEX idx_status_audit (status, audit_status),<br>  INDEX idx_create_time (create_time),<br>  INDEX idx_hot (is_hot),<br>  INDEX idx_new (is_new)<br>) COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;短剧表&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>episodes（剧集表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> episodes (<br>  episode_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,<br>  drama_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;短剧ID&#x27;</span>,<br>  title <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) COMMENT <span class="hljs-string">&#x27;标题&#x27;</span>,<br>  episode_number <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;集数&#x27;</span>,<br>  cover <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;封面URL&#x27;</span>,<br>  video_url <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;视频URL&#x27;</span>,<br>  video_url_hd <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;高清视频URL&#x27;</span>,<br>  video_url_sd <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;标清视频URL&#x27;</span>,<br>  video_url_ld <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;低清视频URL&#x27;</span>,<br>  subtitle_url <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;字幕URL&#x27;</span>,<br>  duration <span class="hljs-type">INT</span> COMMENT <span class="hljs-string">&#x27;时长(秒)&#x27;</span>,<br>  description TEXT COMMENT <span class="hljs-string">&#x27;简介&#x27;</span>,<br>  is_free TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;是否免费(0付费/1免费)&#x27;</span>,<br>  is_trailer TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;是否预告片(0否/1是)&#x27;</span>,<br>  coin_price <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;金币价格&#x27;</span>,<br>  play_count <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;播放次数&#x27;</span>,<br>  like_count <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;点赞数&#x27;</span>,<br>  comment_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;评论数&#x27;</span>,<br>  share_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;分享数&#x27;</span>,<br>  danmaku_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;弹幕数&#x27;</span>,<br>  status TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> COMMENT <span class="hljs-string">&#x27;状态(0删除/1正常)&#x27;</span>,<br>  audit_status TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;审核状态(0待审核/1通过/2拒绝)&#x27;</span>,<br>  audit_reason <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;审核拒绝原因&#x27;</span>,<br>  publish_time DATETIME COMMENT <span class="hljs-string">&#x27;发布时间&#x27;</span>,<br>  create_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  update_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  INDEX idx_drama_id (drama_id),<br>  INDEX idx_episode_number (episode_number),<br>  <span class="hljs-keyword">UNIQUE</span> KEY uk_drama_episode (drama_id, episode_number)<br>) COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;剧集表&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>drama_auth（短剧审核流程表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> drama_auth (<br>  drama_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;短剧ID&#x27;</span>,<br>  process_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;Camunda流程实例ID&#x27;</span>,<br>  step_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) COMMENT <span class="hljs-string">&#x27;当前步骤名称&#x27;</span>,<br>  auth_status TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;审核状态(-1未通过/0审核中/1通过)&#x27;</span>,<br>  create_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  update_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (drama_id),<br>  INDEX idx_process_id (process_id),<br>  INDEX idx_auth_status (auth_status)<br>) COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;短剧审核流程表&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="6-2-3-互动服务（kcat-interaction）"><a href="#6-2-3-互动服务（kcat-interaction）" class="headerlink" title="6.2.3 互动服务（kcat_interaction）"></a>6.2.3 互动服务（kcat_interaction）</h4><p><strong>user_likes（用户点赞记录表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> user_likes (<br>  like_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,<br>  user_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;用户ID&#x27;</span>,<br>  target_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;目标ID&#x27;</span>,<br>  target_type TINYINT <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;目标类型(1短剧/2剧集/3评论/4弹幕)&#x27;</span>,<br>  target_user_id <span class="hljs-type">BIGINT</span> COMMENT <span class="hljs-string">&#x27;目标所属用户ID&#x27;</span>,<br>  drama_id <span class="hljs-type">BIGINT</span> COMMENT <span class="hljs-string">&#x27;短剧ID(冗余字段)&#x27;</span>,<br>  episode_id <span class="hljs-type">BIGINT</span> COMMENT <span class="hljs-string">&#x27;剧集ID(冗余字段)&#x27;</span>,<br>  status TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> COMMENT <span class="hljs-string">&#x27;状态(0取消/1有效)&#x27;</span>,<br>  create_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  update_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  <span class="hljs-keyword">UNIQUE</span> KEY uk_user_target (user_id, target_id, target_type),<br>  INDEX idx_target (target_id, target_type),<br>  INDEX idx_drama (drama_id),<br>  INDEX idx_episode (episode_id)<br>) COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户点赞记录表&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>comments（评论表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> comments (<br>  comment_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,<br>  user_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;用户ID&#x27;</span>,<br>  user_nickname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) COMMENT <span class="hljs-string">&#x27;用户昵称(冗余)&#x27;</span>,<br>  user_avatar <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;用户头像(冗余)&#x27;</span>,<br>  drama_id <span class="hljs-type">BIGINT</span> COMMENT <span class="hljs-string">&#x27;短剧ID&#x27;</span>,<br>  episode_id <span class="hljs-type">BIGINT</span> COMMENT <span class="hljs-string">&#x27;剧集ID&#x27;</span>,<br>  content TEXT <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;评论内容&#x27;</span>,<br>  parent_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;父评论ID&#x27;</span>,<br>  root_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;根评论ID&#x27;</span>,<br>  reply_user_id <span class="hljs-type">BIGINT</span> COMMENT <span class="hljs-string">&#x27;回复用户ID&#x27;</span>,<br>  reply_user_nickname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) COMMENT <span class="hljs-string">&#x27;回复用户昵称&#x27;</span>,<br>  like_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;点赞数&#x27;</span>,<br>  dislike_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;点踩数&#x27;</span>,<br>  reply_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;回复数&#x27;</span>,<br>  is_hot TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;是否热门(0否/1是)&#x27;</span>,<br>  is_top TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;是否置顶(0否/1是)&#x27;</span>,<br>  ip_address <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) COMMENT <span class="hljs-string">&#x27;IP地址&#x27;</span>,<br>  location <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) COMMENT <span class="hljs-string">&#x27;地理位置&#x27;</span>,<br>  device_info <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;设备信息&#x27;</span>,<br>  status TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> COMMENT <span class="hljs-string">&#x27;状态(0删除/1正常/2审核中/3已屏蔽)&#x27;</span>,<br>  audit_status TINYINT <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;审核状态(0待审核/1通过/2拒绝)&#x27;</span>,<br>  audit_reason <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) COMMENT <span class="hljs-string">&#x27;审核拒绝原因&#x27;</span>,<br>  create_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  update_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  INDEX idx_user_id (user_id),<br>  INDEX idx_drama_id (drama_id),<br>  INDEX idx_episode_id (episode_id),<br>  INDEX idx_parent_id (parent_id),<br>  INDEX idx_root_id (root_id),<br>  INDEX idx_create_time (create_time)<br>) COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;评论表&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>content_statistics（内容统计表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> content_statistics (<br>  stat_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,<br>  content_id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;内容ID&#x27;</span>,<br>  content_type TINYINT <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;内容类型(1短剧/2剧集)&#x27;</span>,<br>  comment_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;评论数&#x27;</span>,<br>  danmaku_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;弹幕数&#x27;</span>,<br>  like_count <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;点赞数&#x27;</span>,<br>  dislike_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;点踩数&#x27;</span>,<br>  share_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;分享数&#x27;</span>,<br>  report_count <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;举报数&#x27;</span>,<br>  hot_score <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;热度分数&#x27;</span>,<br>  create_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  update_time DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>  <span class="hljs-keyword">UNIQUE</span> KEY uk_content (content_id, content_type)<br>) COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;内容统计表&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="6-3-表关系ER图"><a href="#6-3-表关系ER图" class="headerlink" title="6.3 表关系ER图"></a>6.3 表关系ER图</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">┌──────────────────────────────────────────────────────────────────────┐<br>│ 用户服务（<span class="hljs-type">kcat_user</span>）                                                 │<br>└──────────────────────────────────────────────────────────────────────┘<br>    <span class="hljs-variable">users</span> <span class="hljs-punctuation">(</span>用户基本信息<span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-type">user_auths</span> <span class="hljs-punctuation">(</span>认证方式<span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-type">user_follows</span> <span class="hljs-punctuation">(</span>关注关系 <span class="hljs-operator">-</span> <span class="hljs-type">follower_id</span><span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-built_in">N</span><span class="hljs-operator">:</span><span class="hljs-number">1</span> ← <span class="hljs-type">user_follows</span> <span class="hljs-punctuation">(</span>粉丝关系 <span class="hljs-operator">-</span> <span class="hljs-type">followee_id</span><span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-type">user_collections</span> <span class="hljs-punctuation">(</span>收藏<span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-type">user_browse</span><span class="hljs-type">_history</span> <span class="hljs-punctuation">(</span>浏览历史<span class="hljs-punctuation">)</span><br>      └── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-type">user_devices</span> <span class="hljs-punctuation">(</span>设备<span class="hljs-punctuation">)</span><br><br>┌──────────────────────────────────────────────────────────────────────┐<br>│ 内容服务（<span class="hljs-type">kcat_content</span>）                                              │<br>└──────────────────────────────────────────────────────────────────────┘<br>    <span class="hljs-variable">dramas</span> <span class="hljs-punctuation">(</span>短剧<span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-variable">episodes</span> <span class="hljs-punctuation">(</span>剧集<span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-variable">M</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-variable">actors</span> <span class="hljs-punctuation">(</span>演员<span class="hljs-punctuation">)</span> 通过 <span class="hljs-type">drama_actors</span><br>      ├── <span class="hljs-variable">M</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-variable">categories</span> <span class="hljs-punctuation">(</span>分类<span class="hljs-punctuation">)</span> 通过 <span class="hljs-type">drama_categories</span><br>      ├── <span class="hljs-variable">M</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-variable">tags</span> <span class="hljs-punctuation">(</span>标签<span class="hljs-punctuation">)</span> 通过 <span class="hljs-type">drama_tags</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-number">1</span> → <span class="hljs-type">drama_auth</span> <span class="hljs-punctuation">(</span>审核流程<span class="hljs-punctuation">)</span><br>      └── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-type">content_audits</span> <span class="hljs-punctuation">(</span>审核记录<span class="hljs-punctuation">)</span><br><br>┌──────────────────────────────────────────────────────────────────────┐<br>│ 互动服务（<span class="hljs-type">kcat_interaction</span>）                                          │<br>└──────────────────────────────────────────────────────────────────────┘<br>    <span class="hljs-variable">users</span> <span class="hljs-punctuation">(</span>外键引用<span class="hljs-type">kcat_user</span><span class="hljs-operator">.</span><span class="hljs-variable">users</span><span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-type">user_likes</span> <span class="hljs-punctuation">(</span>点赞<span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-variable">comments</span> <span class="hljs-punctuation">(</span>评论<span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-variable">danmaku</span> <span class="hljs-punctuation">(</span>弹幕<span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-type">share_records</span> <span class="hljs-punctuation">(</span>分享<span class="hljs-punctuation">)</span><br>      └── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-variable">reports</span> <span class="hljs-punctuation">(</span>举报<span class="hljs-punctuation">)</span><br><br>    <span class="hljs-variable">dramas</span><span class="hljs-operator">/</span><span class="hljs-variable">episodes</span> <span class="hljs-punctuation">(</span>外键引用<span class="hljs-type">kcat_content</span>表<span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-type">user_likes</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-variable">comments</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-variable">danmaku</span><br>      ├── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-built_in">N</span> → <span class="hljs-type">share_records</span><br>      └── <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-number">1</span> → <span class="hljs-type">content_statistics</span> <span class="hljs-punctuation">(</span>统计<span class="hljs-punctuation">)</span><br><br>┌──────────────────────────────────────────────────────────────────────┐<br>│ 工作流服务（<span class="hljs-type">kcat_camunda</span>）                                            │<br>└──────────────────────────────────────────────────────────────────────┘<br>    <span class="hljs-variable">Camunda</span>引擎表（由<span class="hljs-variable">Camunda</span> <span class="hljs-variable">BPM</span>自动创建管理）<br>      ├── <span class="hljs-type">act_re</span><span class="hljs-type">_</span><span class="hljs-operator">*</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Repository</span> <span class="hljs-operator">-</span> 流程定义<span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-type">act_ru</span><span class="hljs-type">_</span><span class="hljs-operator">*</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Runtime</span> <span class="hljs-operator">-</span> 运行时实例<span class="hljs-punctuation">)</span><br>      ├── <span class="hljs-type">act_hi</span><span class="hljs-type">_</span><span class="hljs-operator">*</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">History</span> <span class="hljs-operator">-</span> 历史数据<span class="hljs-punctuation">)</span><br>      └── <span class="hljs-type">act_id</span><span class="hljs-type">_</span><span class="hljs-operator">*</span> <span class="hljs-punctuation">(</span><span class="hljs-built_in">Identity</span> <span class="hljs-operator">-</span> 用户组织<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h3 id="6-4-索引设计原则"><a href="#6-4-索引设计原则" class="headerlink" title="6.4 索引设计原则"></a>6.4 索引设计原则</h3><ol><li><strong>主键索引</strong>: 所有表使用BIGINT自增主键</li><li><strong>唯一索引</strong>: 手机号、认证标识等唯一字段</li><li><strong>复合索引</strong>: 高频查询条件组合（如status+audit_status）</li><li><strong>外键索引</strong>: 关联查询的字段（userId, dramaId, episodeId）</li><li><strong>时间索引</strong>: 支持按时间排序和范围查询</li><li><strong>状态索引</strong>: 支持状态筛选查询</li></ol><hr><h2 id="七、技术亮点与最佳实践"><a href="#七、技术亮点与最佳实践" class="headerlink" title="七、技术亮点与最佳实践"></a>七、技术亮点与最佳实践</h2><h3 id="7-1-分布式缓存三高防护"><a href="#7-1-分布式缓存三高防护" class="headerlink" title="7.1 分布式缓存三高防护"></a>7.1 分布式缓存三高防护</h3><h4 id="7-1-1-缓存穿透防护（布隆过滤器）"><a href="#7-1-1-缓存穿透防护（布隆过滤器）" class="headerlink" title="7.1.1 缓存穿透防护（布隆过滤器）"></a>7.1.1 缓存穿透防护（布隆过滤器）</h4><p><strong>实现方案</strong>: Redisson BloomFilter</p><p><strong>特性</strong>:</p><ul><li>预计元素: 1000万</li><li>误判率: 0.001%</li><li>内存占用: 约14.4MB</li></ul><p><strong>重建机制</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建临时布隆过滤器</span><br>RBloomFilter&lt;Long&gt; tempFilter = redissonClient.getBloomFilter(<span class="hljs-string">&quot;temp_bloom_filter&quot;</span>);<br>tempFilter.tryInit(<span class="hljs-number">10_000_000</span>, <span class="hljs-number">0.001</span>);<br><br><span class="hljs-comment">// 查询所有短剧ID并添加</span><br>List&lt;Long&gt; dramaIds = dramaMapper.selectAllDramaIds();<br><span class="hljs-keyword">for</span> (Long dramaId : dramaIds) &#123;<br>    tempFilter.add(dramaId);<br>&#125;<br><br><span class="hljs-comment">// 毫秒级切换（rename）</span><br>RBloomFilter&lt;Long&gt; oldFilter = redissonClient.getBloomFilter(<span class="hljs-string">&quot;bloom:filter:dramas:id&quot;</span>);<br>oldFilter.rename(<span class="hljs-string">&quot;old_bloom_filter&quot;</span>);<br>tempFilter.rename(<span class="hljs-string">&quot;bloom:filter:dramas:id&quot;</span>);<br>redissonClient.getKeys().delete(<span class="hljs-string">&quot;old_bloom_filter&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong>: 短剧详情查询、剧集详情查询</p><hr><h4 id="7-1-2-缓存击穿防护（分布式锁）"><a href="#7-1-2-缓存击穿防护（分布式锁）" class="headerlink" title="7.1.2 缓存击穿防护（分布式锁）"></a>7.1.2 缓存击穿防护（分布式锁）</h4><p><strong>实现方案</strong>: Redisson RLock</p><p><strong>加锁流程</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span> + cacheKey;<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(lockKey);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">lockResult</span> <span class="hljs-operator">=</span> lock.tryLock();<br><br><span class="hljs-keyword">if</span> (lockResult) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 双重检查缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">cacheData</span> <span class="hljs-operator">=</span> redisService.getData(cacheKey);<br>        <span class="hljs-keyword">if</span> (cacheData != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> cacheData;<br>        &#125;<br><br>        <span class="hljs-comment">// 查询数据库</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">dbData</span> <span class="hljs-operator">=</span> queryDatabase();<br><br>        <span class="hljs-comment">// 写入缓存</span><br>        redisService.setData(cacheKey, dbData);<br><br>        <span class="hljs-keyword">return</span> dbData;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 获取锁失败，等待2秒后重试</span><br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>    <span class="hljs-keyword">return</span> getData(cacheKey);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优势</strong>: 只有一个线程回源查询，避免数据库瞬时压力</p><hr><h4 id="7-1-3-缓存雪崩防护（随机过期时间）"><a href="#7-1-3-缓存雪崩防护（随机过期时间）" class="headerlink" title="7.1.3 缓存雪崩防护（随机过期时间）"></a>7.1.3 缓存雪崩防护（随机过期时间）</h4><p><strong>实现方案</strong>: 基础TTL + 随机时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认TTL = 7天</span><br><span class="hljs-type">long</span> <span class="hljs-variable">baseTtl</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;<br><br><span class="hljs-comment">// 随机TTL = 0-99999秒（约0-27小时）</span><br><span class="hljs-type">long</span> <span class="hljs-variable">randomTtl</span> <span class="hljs-operator">=</span> Long.parseLong(RandomUtil.randomNumbers(<span class="hljs-number">5</span>));<br><br><span class="hljs-comment">// 最终TTL</span><br><span class="hljs-type">long</span> <span class="hljs-variable">finalTtl</span> <span class="hljs-operator">=</span> baseTtl + randomTtl;<br><br>stringRedisTemplate.opsForValue().set(cacheKey, jsonStr, finalTtl, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p><strong>效果</strong>: 缓存失效时间分散，避免集体失效</p><hr><h4 id="7-1-4-缓存一致性（延迟双删）"><a href="#7-1-4-缓存一致性（延迟双删）" class="headerlink" title="7.1.4 缓存一致性（延迟双删）"></a>7.1.4 缓存一致性（延迟双删）</h4><p><strong>实现方案</strong>: 立即删除 + 延迟删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 更新数据库</span><br>updateDatabase(data);<br><br><span class="hljs-comment">// 第一次删除缓存</span><br>stringRedisTemplate.delete(cacheKey);<br><br><span class="hljs-comment">// 延迟10秒再删除（使用ScheduledThreadPoolExecutor）</span><br>scheduledThreadPoolExecutor.schedule(() -&gt; &#123;<br>    stringRedisTemplate.delete(cacheKey);<br>&#125;, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p><strong>适用场景</strong>: 数据更新操作（99%场景有效）</p><hr><h3 id="7-2-自定义AOP缓存注解"><a href="#7-2-自定义AOP缓存注解" class="headerlink" title="7.2 自定义AOP缓存注解"></a>7.2 自定义AOP缓存注解</h3><p><strong>@CacheData注解</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CacheData &#123;<br>    String <span class="hljs-title function_">cacheKey</span><span class="hljs-params">()</span>;               <span class="hljs-comment">// 缓存Key（支持SpEL格式化）</span><br>    String <span class="hljs-title function_">bloomFilterKey</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 布隆过滤器Key</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheData(cacheKey = RedisConstants.DRAMA_DETAIL_CACHE_KEY,</span><br><span class="hljs-meta">           bloomFilterKey = RedisConstants.BLOOM_FILTER_DRAMAS_ID)</span><br><span class="hljs-keyword">public</span> HomeDramaInfoDto <span class="hljs-title function_">getDramaDetail</span><span class="hljs-params">(Long dramaId)</span> &#123;<br>    <span class="hljs-comment">// 方法体：远程调用content-service</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>CacheDataAspect切面逻辑</strong>:</p><ol><li>解析方法参数（dramaId）和返回值类型</li><li>拼接缓存Key（支持格式化占位符，如<code>drama:detail:&#123;dramaId&#125;</code>）</li><li>查询缓存 → 命中则返回</li><li>未命中 → 判断布隆过滤器 → 不存在则返回null</li><li>存在 → 尝试获取分布式锁</li><li>获取锁成功 → 执行目标方法 → 写入缓存 → 释放锁</li><li>获取锁失败 → 等待2秒 → 重新查询缓存</li></ol><p><strong>优势</strong>: 业务代码无侵入，一个注解搞定完整缓存流程</p><hr><h3 id="7-3-Kafka事件驱动架构"><a href="#7-3-Kafka事件驱动架构" class="headerlink" title="7.3 Kafka事件驱动架构"></a>7.3 Kafka事件驱动架构</h3><h4 id="7-3-1-生产者拦截器（自动填充公共字段）"><a href="#7-3-1-生产者拦截器（自动填充公共字段）" class="headerlink" title="7.3.1 生产者拦截器（自动填充公共字段）"></a>7.3.1 生产者拦截器（自动填充公共字段）</h4><p><strong>KafkaEventProducerInterceptor</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ProducerRecord&lt;String, Object&gt; <span class="hljs-title function_">onSend</span><span class="hljs-params">(ProducerRecord&lt;String, Object&gt; record)</span> &#123;<br>    <span class="hljs-type">BaseEvent</span> <span class="hljs-variable">baseEvent</span> <span class="hljs-operator">=</span> (BaseEvent) record.value();<br><br>    <span class="hljs-comment">// 自动填充msgId（雪花ID）</span><br>    baseEvent.setMsgId(IdUtil.getSnowflakeNextId());<br><br>    <span class="hljs-comment">// 自动填充userId（从Sa-Token获取）</span><br>    baseEvent.setUserId(StpUtil.getLoginIdAsLong());<br><br>    <span class="hljs-comment">// 自动填充timestamp</span><br>    baseEvent.setTimestamp(System.currentTimeMillis());<br><br>    <span class="hljs-keyword">return</span> record;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>效果</strong>: 业务代码只需构造核心业务字段，公共字段自动填充</p><hr><h4 id="7-3-2-消息幂等性保证"><a href="#7-3-2-消息幂等性保证" class="headerlink" title="7.3.2 消息幂等性保证"></a>7.3.2 消息幂等性保证</h4><p><strong>方案1</strong>: Redis Set记录已处理消息ID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">doneKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;done:like:msg&quot;</span>;<br><span class="hljs-keyword">if</span> (redisTemplate.opsForSet().isMember(doneKey, msgId)) &#123;<br>    <span class="hljs-comment">// 消息已处理，直接ACK</span><br>    ack.acknowledge();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 处理业务逻辑</span><br>processBusiness(event);<br><br><span class="hljs-comment">// 记录消息ID</span><br>redisTemplate.opsForSet().add(doneKey, msgId);<br><br><span class="hljs-comment">// 手动ACK</span><br>ack.acknowledge();<br></code></pre></td></tr></table></figure><p><strong>方案2</strong>: 数据库唯一索引 + 幂等更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- user_likes表设计</span><br><span class="hljs-keyword">UNIQUE</span> KEY uk_user_target (user_id, target_id, target_type)<br><br><span class="hljs-comment">-- 幂等更新SQL</span><br><span class="hljs-keyword">UPDATE</span> user_likes <span class="hljs-keyword">SET</span> status <span class="hljs-operator">=</span> ? <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> ? <span class="hljs-keyword">AND</span> target_id <span class="hljs-operator">=</span> ? <span class="hljs-keyword">AND</span> target_type <span class="hljs-operator">=</span> ?<br></code></pre></td></tr></table></figure><hr><h4 id="7-3-3-最终一致性保证"><a href="#7-3-3-最终一致性保证" class="headerlink" title="7.3.3 最终一致性保证"></a>7.3.3 最终一致性保证</h4><p><strong>流程</strong>:</p><ol><li>用户点击点赞 → 发送Kafka消息 → 立即返回成功</li><li>Kafka消费者1（user-service）→ 更新Redis缓存</li><li>Kafka消费者2（interaction-service）→ 更新数据库</li><li>消息持久化 + 手动ACK → 保证消息不丢失</li><li>幂等性处理 → 重复消费结果一致</li></ol><p><strong>优势</strong>:</p><ul><li>降低接口响应时间（异步处理） </li><li>削峰填谷（高并发缓冲）</li><li>最终一致性（数据库与缓存同步）</li></ul><hr><h3 id="7-4-Feign响应统一处理"><a href="#7-4-Feign响应统一处理" class="headerlink" title="7.4 Feign响应统一处理"></a>7.4 Feign响应统一处理</h3><p><strong>FeignResponseDecoder</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">decode</span><span class="hljs-params">(Response response, Type type)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">decode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.decode(response, type);<br><br>    <span class="hljs-keyword">if</span> (decode <span class="hljs-keyword">instanceof</span> R&lt;?&gt;) &#123;<br>        R&lt;?&gt; r = (R&lt;?&gt;) decode;<br>        <span class="hljs-keyword">if</span> (r.getCode() != <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceException</span>(r.getMsg(), r.getCode());<br>        &#125;<br>        <span class="hljs-comment">// 自动解包，返回data</span><br>        <span class="hljs-keyword">return</span> r.getData();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> decode;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优势</strong>:</p><ul><li>业务代码无需关注R对象的code判断</li><li>自动解包，直接获取data</li><li>统一异常处理</li></ul><p><strong>使用示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用方代码（无需判断R.code）</span><br><span class="hljs-type">HomeDramaInfoDto</span> <span class="hljs-variable">dto</span> <span class="hljs-operator">=</span> contentFeignClient.getDramaDetail(dramaId);<br></code></pre></td></tr></table></figure><hr><h3 id="7-5-线程池并发查询"><a href="#7-5-线程池并发查询" class="headerlink" title="7.5 线程池并发查询"></a>7.5 线程池并发查询</h3><p><strong>ThreadPoolConfig配置</strong>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">thread-pool:</span><br>  <span class="hljs-attr">core-size:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">max-size:</span> <span class="hljs-number">20</span><br>  <span class="hljs-attr">queue-capacity:</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><strong>应用场景</strong>: 用户信息查询（5个维度数据并发查询）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Users&gt; baseInfoFuture = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">return</span> usersService.getById(userId);<br>&#125;, threadPoolExecutor);<br><br>CompletableFuture&lt;Long&gt; followCountFuture = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">return</span> userFollowsService.count(Wrappers.&lt;UserFollows&gt;lambdaQuery()<br>        .eq(UserFollows::getFollowerId, userId));<br>&#125;, threadPoolExecutor);<br><br><span class="hljs-comment">// ... (其他3个Future)</span><br><br>CompletableFuture.allOf(baseInfoFuture, followCountFuture, ...).join();<br><br><span class="hljs-comment">// 获取结果</span><br><span class="hljs-type">Users</span> <span class="hljs-variable">users</span> <span class="hljs-operator">=</span> baseInfoFuture.get();<br><span class="hljs-type">Long</span> <span class="hljs-variable">followCount</span> <span class="hljs-operator">=</span> followCountFuture.get();<br></code></pre></td></tr></table></figure><p><strong>性能提升</strong>: 5个串行查询（假设每个100ms &#x3D; 500ms）→ 并发查询（约100ms）</p><hr><h3 id="7-6-Sa-Token轻量级认证"><a href="#7-6-Sa-Token轻量级认证" class="headerlink" title="7.6 Sa-Token轻量级认证"></a>7.6 Sa-Token轻量级认证</h3><p><strong>配置模式</strong>: JWT Simple模式（<code>StpLogicJwtForSimple</code>）</p><p><strong>特性</strong>:</p><ol><li><strong>Token生成</strong>: 登录时携带扩展信息（phone, nickname）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">StpUtil.login(userId, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SaLoginModel</span>()<br>    .setExtra(<span class="hljs-string">&quot;phone&quot;</span>, phone)<br>    .setExtra(<span class="hljs-string">&quot;nickname&quot;</span>, nickname));<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>Token验证</strong>: <code>@SaCheckLogin</code>注解自动鉴权</li><li><strong>用户信息获取</strong>:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> StpUtil.getLoginIdAsLong();<br><span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> StpUtil.getExtra(<span class="hljs-string">&quot;phone&quot;</span>).toString();<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>Redis存储</strong>: Token与用户信息映射关系存储在Redis</li></ol><p><strong>优势</strong>: 轻量级、易用、集成简单</p><hr><h3 id="7-7-Camunda工作流引擎"><a href="#7-7-Camunda工作流引擎" class="headerlink" title="7.7 Camunda工作流引擎"></a>7.7 Camunda工作流引擎</h3><p><strong>优势</strong>:</p><ol><li><strong>可视化建模</strong>: BPMN 2.0标准，支持可视化流程设计</li><li><strong>灵活扩展</strong>: JavaDelegate机制，业务逻辑与流程解耦</li><li><strong>并行任务</strong>: Parallel Gateway支持并行执行</li><li><strong>条件路由</strong>: Exclusive Gateway支持条件分支</li><li><strong>人工任务</strong>: User Task支持人工审核</li><li><strong>流程监控</strong>: 内置流程实例监控和历史查询</li></ol><p><strong>应用场景</strong>: 短剧审核流程编排</p><p><strong>流程定义</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bpmn:process</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DramaAuthProcess&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;短剧审核流程&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bpmn:startEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StartEvent_1&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bpmn:serviceTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;AI_Check&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AI内容审核&quot;</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">camunda:delegateExpression</span>=<span class="hljs-string">&quot;$&#123;aiCheck&#125;&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bpmn:userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Manual_Audit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;人工审核&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bpmn:exclusiveGateway</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Gateway_1&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bpmn:parallelGateway</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Parallel_1&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bpmn:serviceTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;VOD_Translate&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;腾讯云转码&quot;</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">camunda:delegateExpression</span>=<span class="hljs-string">&quot;$&#123;tecentVodTranslator&#125;&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bpmn:serviceTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;RAG_Data&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RAG数据入库&quot;</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">camunda:delegateExpression</span>=<span class="hljs-string">&quot;$&#123;ragDataHandler&#125;&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bpmn:endEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;EndEvent_1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bpmn:process</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="八、部署架构"><a href="#八、部署架构" class="headerlink" title="八、部署架构"></a>八、部署架构</h2><h3 id="8-1-开发环境部署"><a href="#8-1-开发环境部署" class="headerlink" title="8.1 开发环境部署"></a>8.1 开发环境部署</h3><p><strong>Docker Compose部署清单</strong>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:8.0</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/mysql:/var/lib/mysql</span><br><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6379:6379&quot;</span><br><br>  <span class="hljs-attr">kafka:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">bitnami/kafka:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9092:9092&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="hljs-string">zookeeper:2181</span><br><br>  <span class="hljs-attr">zookeeper:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">bitnami/zookeeper:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;2181:2181&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">ALLOW_ANONYMOUS_LOGIN:</span> <span class="hljs-literal">yes</span><br><br>  <span class="hljs-attr">nacos:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nacos/nacos-server:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8848:8848&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MODE:</span> <span class="hljs-string">standalone</span><br><br>  <span class="hljs-attr">minio:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">minio/minio:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9000:9000&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9001:9001&quot;</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">server</span> <span class="hljs-string">/data</span> <span class="hljs-string">--console-address</span> <span class="hljs-string">&quot;:9001&quot;</span><br><br>  <span class="hljs-attr">ollama:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">ollama/ollama:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;11434:11434&quot;</span><br><br>  <span class="hljs-attr">xxl-job-admin:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">xuxueli/xxl-job-admin:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8080:8080&quot;</span><br></code></pre></td></tr></table></figure><p><strong>服务启动顺序</strong>:</p><ol><li>MySQL、Redis、Kafka、Zookeeper、Nacos、MinIO、Ollama、XXL-Job</li><li>camunda-service、content-service、interaction-service、user-service</li></ol><hr><h3 id="8-2-生产环境部署"><a href="#8-2-生产环境部署" class="headerlink" title="8.2 生产环境部署"></a>8.2 生产环境部署</h3><p><strong>Kubernetes部署架构</strong>:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk">┌─────────────────────────────────────────────────────────────────────┐<br>│ Ingress Controller (Nginx)                                          │<br>│   ├── <span class="hljs-regexp">/api/</span>* → user-service                                         │<br>│   ├── <span class="hljs-regexp">/content/</span>* → content-service                                  │<br>│   ├── <span class="hljs-regexp">/interaction/</span>* → interaction-service                          │<br>│   └── <span class="hljs-regexp">/workflow/</span>* → camunda-service                                 │<br>└─────────────────────────────────────────────────────────────────────┘<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ Service (ClusterIP)                                                  │<br>│   ├── user-service (<span class="hljs-number">3</span> replicas)                                     │<br>│   ├── content-service (<span class="hljs-number">3</span> replicas)                                  │<br>│   ├── interaction-service (<span class="hljs-number">3</span> replicas)                              │<br>│   └── camunda-service (<span class="hljs-number">2</span> replicas)                                  │<br>└─────────────────────────────────────────────────────────────────────┘<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ StatefulSet                                                          │<br>│   ├── MySQL (Master-Slave <span class="hljs-number">1</span>主<span class="hljs-number">2</span>从)                                   │<br>│   ├── Redis (Cluster <span class="hljs-number">6</span>节点)                                         │<br>│   ├── Kafka (<span class="hljs-number">3</span> brokers)                                             │<br>│   └── Nacos (Cluster <span class="hljs-number">3</span>节点)                                         │<br>└─────────────────────────────────────────────────────────────────────┘<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 外部服务                                                             │<br>│   ├── 腾讯云VOD                                                      │<br>│   ├── MinIO集群                                                      │<br>│   ├── Ollama GPU节点                                                 │<br>│   └── 阿里云短信                                                     │<br>└─────────────────────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure><p><strong>资源配置建议</strong>:</p><table><thead><tr><th>服务</th><th>CPU</th><th>内存</th><th>副本数</th></tr></thead><tbody><tr><td>user-service</td><td>2核</td><td>4GB</td><td>3</td></tr><tr><td>content-service</td><td>2核</td><td>4GB</td><td>3</td></tr><tr><td>interaction-service</td><td>2核</td><td>4GB</td><td>3</td></tr><tr><td>camunda-service</td><td>1核</td><td>2GB</td><td>2</td></tr><tr><td>MySQL</td><td>4核</td><td>16GB</td><td>3</td></tr><tr><td>Redis</td><td>2核</td><td>8GB</td><td>6</td></tr><tr><td>Kafka</td><td>4核</td><td>8GB</td><td>3</td></tr><tr><td>Nacos</td><td>2核</td><td>4GB</td><td>3</td></tr></tbody></table><hr><h3 id="8-3-监控体系"><a href="#8-3-监控体系" class="headerlink" title="8.3 监控体系"></a>8.3 监控体系</h3><p><strong>监控指标</strong>:</p><ol><li><p><strong>应用监控</strong>:</p><ul><li>Prometheus + Grafana</li><li>JVM指标（堆内存、GC、线程）</li><li>接口QPS、响应时间、错误率</li></ul></li><li><p><strong>中间件监控</strong>:</p><ul><li>MySQL慢查询、连接数</li><li>Redis缓存命中率、内存使用率</li><li>Kafka消息积压、消费延迟</li></ul></li><li><p><strong>业务监控</strong>:</p><ul><li>短剧发布量、审核通过率</li><li>用户注册量、活跃用户数</li><li>点赞数、评论数、播放量</li></ul></li><li><p><strong>日志监控</strong>:</p><ul><li>ELK (Elasticsearch + Logstash + Kibana)</li><li>日志聚合、全文检索、可视化</li></ul></li><li><p><strong>链路追踪</strong>:</p><ul><li>SkyWalking &#x2F; Zipkin</li><li>全链路追踪、调用链分析</li></ul></li></ol><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="A-常用命令"><a href="#A-常用命令" class="headerlink" title="A. 常用命令"></a>A. 常用命令</h3><p><strong>启动Docker Compose</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><p><strong>查看服务状态</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose ps<br></code></pre></td></tr></table></figure><p><strong>查看服务日志</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose logs -f user-service<br></code></pre></td></tr></table></figure><p><strong>重启服务</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose restart user-service<br></code></pre></td></tr></table></figure><p><strong>Maven打包</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn clean package -Dmaven.test.skip=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>Kafka创建Topic</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">kafka-topics.sh --create \<br>  --bootstrap-server localhost:9092 \<br>  --topic like-event-topic \<br>  --partitions 10 \<br>  --replication-factor 1<br></code></pre></td></tr></table></figure><hr><h3 id="B-配置文件模板"><a href="#B-配置文件模板" class="headerlink" title="B. 配置文件模板"></a>B. 配置文件模板</h3><p><strong>application.yml（Nacos配置）</strong>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># application-common.yml（公共配置）</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-string">3000ms</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">-1ms</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br><br>  <span class="hljs-attr">kafka:</span><br>    <span class="hljs-attr">bootstrap-servers:</span> <span class="hljs-string">kafka:9092</span><br>    <span class="hljs-attr">producer:</span><br>      <span class="hljs-attr">key-serializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span><br>      <span class="hljs-attr">value-serializer:</span> <span class="hljs-string">org.springframework.kafka.support.serializer.JsonSerializer</span><br>    <span class="hljs-attr">consumer:</span><br>      <span class="hljs-attr">group-id:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span><br>      <span class="hljs-attr">key-deserializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span><br>      <span class="hljs-attr">value-deserializer:</span> <span class="hljs-string">org.springframework.kafka.support.serializer.JsonDeserializer</span><br>      <span class="hljs-attr">auto-offset-reset:</span> <span class="hljs-string">earliest</span><br>      <span class="hljs-attr">enable-auto-commit:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># datasource.yml（数据源配置）</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://mysql:3306/$&#123;db.name&#125;?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath*:mapper/**/*Mapper.xml</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.qwf.*.domain</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.slf4j.Slf4jImpl</span><br></code></pre></td></tr></table></figure><hr><h3 id="C-常见问题FAQ"><a href="#C-常见问题FAQ" class="headerlink" title="C. 常见问题FAQ"></a>C. 常见问题FAQ</h3><p><strong>Q1: Kafka消息积压怎么办？</strong><br>A: 增加消费者实例数、优化消费逻辑、增加分区数</p><p><strong>Q2: Redis内存不足怎么办？</strong><br>A: 设置合理的过期时间、使用LRU淘汰策略、扩容Redis节点</p><p><strong>Q3: Camunda流程实例查询慢？</strong><br>A: 定期归档历史数据、优化数据库索引、使用缓存</p><p><strong>Q4: 视频转码失败怎么办？</strong><br>A: 检查腾讯云VOD配置、增加重试机制</p><p><strong>Q5: 布隆过滤器误判怎么办？</strong><br>A: 降低误判率（增大内存）、配合缓存空对象使用</p><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文档详细描述了Kcat短剧平台的完整技术架构和业务流程，涵盖了4个核心微服务（user-service、content-service、interaction-service、camunda-service）的技术实现、服务交互、数据模型、部署架构等全方位内容。</p><p><strong>核心技术亮点</strong>:</p><ol><li>微服务架构（Spring Cloud + Nacos）</li><li>工作流引擎（Camunda BPM）</li><li>事件驱动架构（Kafka）</li><li>分布式缓存三高防护（布隆过滤器 + 分布式锁 + 随机过期）</li><li>AI能力集成（Ollama + DeepSeek）</li><li>视频云处理（腾讯云VOD）</li></ol><p><strong>业务场景</strong>:</p><ul><li>短剧内容管理与发布</li><li>AI自动审核 + 人工审核</li><li>视频转码与多清晰度支持</li><li>用户互动（点赞、评论、弹幕）</li><li>首页精选视频推荐</li></ul><p>该系统架构设计合理、分层清晰、扩展性强，是一个完整的企业级短视频内容分发平台解决方案。</p><hr><p><strong>文档版本</strong>: v1.0<br><strong>生成日期</strong>: 2025-09-30<br><strong>作者</strong>: Claude Code<br><strong>文档字数</strong>: 约35000字</p>]]></content>
    
    
    
    <tags>
      
      <tag>kcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>42Java集合基础</title>
    <link href="/2025/11/23/42Java%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/11/23/42Java%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java集合基础"><a href="#Java集合基础" class="headerlink" title="Java集合基础"></a>Java集合基础</h1><p><img src="/./../img/1717481094793-b8ffe6ae-2ee6-4de5-b61b-8468e32bf269.webp" alt="img"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="数组与集合区别，用过哪些？"><a href="#数组与集合区别，用过哪些？" class="headerlink" title="#数组与集合区别，用过哪些？"></a><a href="https://xiaolincoding.com/interview/collections.html#%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88%E5%8C%BA%E5%88%AB-%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B">#</a>数组与集合区别，用过哪些？</h3><p>数组和集合的区别：</p><ul><li>数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素。</li><li>数组可以包含基本数据类型和对象，而集合只能包含对象。</li><li>数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。</li></ul><h3 id="Java中的线程安全的集合是什么？"><a href="#Java中的线程安全的集合是什么？" class="headerlink" title="Java中的线程安全的集合是什么？"></a>Java中的线程安全的集合是什么？</h3><p>在 java.util 包中的线程安全的类主要 2 个，其他都是非线程安全的。</p><ul><li><strong>Vector</strong>：线程安全的动态数组，其内部方法基本都经过synchronized修饰，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</li><li><strong>Hashtable</strong>：线程安全的哈希表，HashTable 的加锁方法是给每个方法加上 synchronized 关键字，这样锁住的是整个 Table 对象，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用，如果要保证线程安全的哈希表，可以用ConcurrentHashMap。</li></ul><p>java.util.concurrent 包提供的都是线程安全的集合：</p><p>并发Map：</p><ul><li><strong>ConcurrentHashMap</strong>：它与 HashTable 的主要区别是二者加锁粒度的不同，在<strong>JDK1.7</strong>，ConcurrentHashMap加的是分段锁，也就是Segment锁，每个Segment 含有整个 table 的一部分，这样不同分段之间的并发操作就互不影响。在<strong>JDK 1.8</strong> ，它取消了Segment字段，直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。对于put操作，如果Key对应的数组元素为null，则通过CAS操作（Compare and Swap）将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用 synchronized 关键字申请锁，然后进行操作。如果该 put 操作使得当前链表长度超过一定阈值，则将该链表转换为红黑树，从而提高寻址效率。</li><li><strong>ConcurrentSkipListMap</strong>：实现了一个基于SkipList（跳表）算法的可排序的并发集合，SkipList是一种可以在对数预期时间内完成搜索、插入、删除等操作的数据结构，通过维护多个指向其他元素的“跳跃”链接来实现高效查找。</li></ul><p>并发Set：</p><ul><li><strong>ConcurrentSkipListSet</strong>：是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现。</li><li><strong>CopyOnWriteArraySet</strong>：是线程安全的Set实现，它是线程安全的无序的集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过“散列表”实现的，而CopyOnWriteArraySet则是通过“动态数组(CopyOnWriteArrayList)”实现的，并不是散列表。</li></ul><p>并发List：</p><ul><li><strong>CopyOnWriteArrayList</strong>：它是 ArrayList 的线程安全的变体，其中所有写操作（add，set等）都通过对底层数组进行全新复制来实现，允许存储 null 元素。即当对象进行写操作时，使用了Lock锁做同步处理，内部拷贝了原数组，并在新数组上进行添加操作，最后将新数组替换掉旧数组；若进行的读操作，则直接返回结果，操作过程中不需要进行同步。</li></ul><p>并发 Queue：</p><ul><li><strong>ConcurrentLinkedQueue</strong>：是一个适用于高并发场景下的队列，它通过无锁的方式(CAS)，实现了高并发状态下的高性能。通常，ConcurrentLinkedQueue 的性能要好于 BlockingQueue 。</li><li><strong>BlockingQueue</strong>：与 ConcurrentLinkedQueue 的使用场景不同，BlockingQueue 的主要功能并不是在于提升高并发时的队列性能，而在于简化多线程间的数据共享。BlockingQueue 提供一种读写阻塞等待的机制，即如果消费者速度较快，则 BlockingQueue 则可能被清空，此时消费线程再试图从 BlockingQueue 读取数据时就会被阻塞。反之，如果生产线程较快，则 BlockingQueue 可能会被装满，此时，生产线程再试图向 BlockingQueue 队列装入数据时，便会被阻塞等待。</li></ul><p>并发 Deque：</p><ul><li><strong>LinkedBlockingDeque</strong>：是一个线程安全的双端队列实现。它的内部使用链表结构，每一个节点都维护了一个前驱节点和一个后驱节点。LinkedBlockingDeque 没有进行读写锁的分离，因此同一时间只能有一个线程对其进行操作</li><li><strong>ConcurrentLinkedDeque</strong>：ConcurrentLinkedDeque是一种基于链接节点的无限并发链表。可以安全地并发执行插入、删除和访问操作。当许多线程同时访问一个公共集合时，ConcurrentLinkedDeque是一个合适的选择。</li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h3 id="ArrayList-和-LinkedList-的应用场景？"><a href="#ArrayList-和-LinkedList-的应用场景？" class="headerlink" title="ArrayList 和 LinkedList 的应用场景？"></a>ArrayList 和 LinkedList 的应用场景？</h3><ul><li>ArrayList适用于需要频繁访问集合元素的场景。它基于数组实现，可以通过索引快速访问元素，因此在按索引查找、遍历和随机访问元素的操作上具有较高的性能。当需要频繁访问和遍历集合元素，并且集合大小不经常改变时，推荐使用ArrayList</li><li>LinkedList适用于频繁进行插入和删除操作的场景。它基于链表实现，插入和删除元素的操作只需要调整节点的指针，因此在插入和删除操作上具有较高的性能。当需要频繁进行插入和删除操作，或者集合大小经常改变时，可以考虑使用LinkedList。</li></ul><h3 id="ArrayList的扩容机制说一下"><a href="#ArrayList的扩容机制说一下" class="headerlink" title="ArrayList的扩容机制说一下"></a>ArrayList的扩容机制说一下</h3><p>ArrayList在添加元素时，如果当前元素个数已经达到了内部数组的容量上限，就会触发扩容操作。ArrayList的扩容操作主要包括以下几个步骤：</p><ul><li>计算新的容量：一般情况下，新的容量会扩大为原容量的1.5倍（在JDK 10之后，扩容策略做了调整），然后检查是否超过了最大容量限制。</li><li>创建新的数组：根据计算得到的新容量，创建一个新的更大的数组。</li><li>将元素复制：将原来数组中的元素逐个复制到新数组中。</li><li>更新引用：将ArrayList内部指向原数组的引用指向新数组。</li><li>完成扩容：扩容完成后，可以继续添加新元素。</li></ul><p>ArrayList的扩容操作涉及到数组的复制和内存的重新分配，所以在频繁添加大量元素时，扩容操作可能会影响性能。为了减少扩容带来的性能损耗，可以在初始化ArrayList时预分配足够大的容量，避免频繁触发扩容操作。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><img src="/./../img/80ca60fe3653d2f834b76c3173466c30.png" alt="img"></p><h3 id="了解的哈希冲突解决方法有哪些？"><a href="#了解的哈希冲突解决方法有哪些？" class="headerlink" title="了解的哈希冲突解决方法有哪些？"></a>了解的哈希冲突解决方法有哪些？</h3><ul><li>链接法：使用链表或其他数据结构来存储冲突的键值对，将它们链接在同一个哈希桶中。</li><li>开放寻址法：在哈希表中找到另一个可用的位置来存储冲突的键值对，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列。</li><li>再哈希法（Rehashing）：当发生冲突时，使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对。</li><li>哈希桶扩容：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率</li></ul><h3 id="HashMap是线程安全的吗？"><a href="#HashMap是线程安全的吗？" class="headerlink" title="HashMap是线程安全的吗？"></a>HashMap是线程安全的吗？</h3><p>如果要保证线程安全，可以通过这些方法来保证：</p><ul><li>多线程环境可以使用Collections.synchronizedMap同步加锁的方式，还可以使用HashTable，但是同步的方式显然性能不达标，而ConurrentHashMap更适合高并发场景使用。</li><li>ConcurrentHashmap在JDK1.7和1.8的版本改动比较大，1.7使用Segment+HashEntry分段锁的方式实现，1.8则抛弃了Segment，改为使用CAS+synchronized+Node实现，同样也加入了红黑树，避免链表过长导致性能的问题。</li></ul><h3 id="hashmap的put过程介绍一下"><a href="#hashmap的put过程介绍一下" class="headerlink" title="hashmap的put过程介绍一下"></a>hashmap的put过程介绍一下</h3><p><img src="/./../img/1720684054342-1e3cb2a9-532e-40b8-b5cf-0043811391dc.png" alt="img"></p><p>HashMap HashMap的put()方法用于向HashMap中添加键值对，当调用HashMap的put()方法时，会按照以下详细流程执行（JDK8 1.8版本）：</p><blockquote><p>第一步：根据要添加的键的哈希码计算在数组中的位置（索引）。tab[i &#x3D; (n - 1) &amp; hash]</p></blockquote><blockquote><p>第二步：检查该位置是否为空（即没有键值对存在）</p></blockquote><ul><li>如果为空，则直接在该位置创建一个新的Entry对象来存储键值对。将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置。将HashMap的修改次数（modCount）加1，以便在进行迭代时发现并发修改。</li></ul><blockquote><p>第三步：如果该位置已经存在其他键值对，检查该位置的第一个键值对的哈希码和键是否与要添加的键值对相同？</p></blockquote><ul><li>如果相同，则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作。</li></ul><blockquote><p>第四步：如果第一个键值对的哈希码和键不相同，则需要遍历链表或红黑树来查找是否有相同的键：</p></blockquote><p>如果键值对集合是链表结构，从链表的头部开始逐个比较键的哈希码和equals()方法，直到找到相同的键或达到链表末尾。</p><ul><li>如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。</li><li>如果没有找到相同的键，则将新的键值对添加到链表的头部。</li></ul><p>如果键值对集合是红黑树结构，在红黑树中使用哈希码和equals()方法进行查找。根据键的哈希码，定位到红黑树中的某个节点，然后逐个比较键，直到找到相同的键或达到红黑树末尾。</p><ul><li>如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。</li><li>如果没有找到相同的键，则将新的键值对添加到红黑树中。</li></ul><blockquote><p>第五步：检查链表长度是否达到阈值（默认为8）：</p></blockquote><ul><li>如果链表长度超过阈值，且HashMap的数组长度大于等于64，则会将链表转换为红黑树，以提高查询效率。</li></ul><blockquote><p>第六步：检查负载因子是否超过阈值（默认为0.75）：</p></blockquote><ul><li>如果键值对的数量（size）与数组的长度的比值大于阈值，则需要进行扩容操作。</li></ul><blockquote><p>第七步：扩容操作：</p></blockquote><ul><li>创建一个新的两倍大小的数组。</li><li>将旧数组中的键值对重新计算哈希码并分配到新数组中的位置。</li><li>更新HashMap的数组引用和阈值参数。</li></ul><blockquote><p>第八步：完成添加操作。</p></blockquote><p>此外，HashMap是非线程安全的，如果在多线程环境下使用，需要采取额外的同步措施或使用线程安全的ConcurrentHashMap。</p><h3 id="为什么HashMap要用红黑树而不是平衡二叉树？"><a href="#为什么HashMap要用红黑树而不是平衡二叉树？" class="headerlink" title="为什么HashMap要用红黑树而不是平衡二叉树？"></a>为什么HashMap要用红黑树而不是平衡二叉树？</h3><ul><li>平衡二叉树追求的是一种 <strong>“完全平衡”</strong> 状态：任何结点的左右子树的高度差不会超过 1，优势是树的结点是很平均分配的。这个要求实在是太严了，导致每次进行插入&#x2F;删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树。</li><li>红黑树不追求这种完全平衡状态，而是追求一种 <strong>“弱平衡”</strong> 状态：整个树最长路径不会超过最短路径的 2 倍。优势是虽然牺牲了一部分查找的性能效率，但是能够换取一部分维持树平衡状态的成本。与平衡树不同的是，红黑树在插入、删除等操作，<strong>不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整</strong>，这也是我们为什么大多数情况下使用红黑树的原因</li></ul><h3 id="hashmap-key可以为null吗？"><a href="#hashmap-key可以为null吗？" class="headerlink" title="hashmap key可以为null吗？"></a>hashmap key可以为null吗？</h3><p>可以为 null。</p><ul><li>hashMap中使用hash()方法来计算key的哈希值，当key为空时，直接另key的哈希值为0，不走key.hashCode()方法；</li></ul><p><img src="/./../img/1720685862193-66a32b79-ddf0-46d5-87df-d2fc2b3d87cb.png" alt="img"></p><ul><li>hashMap虽然支持key和value为null，但是null作为key只能有一个，null作为value可以有多个；</li><li>因为hashMap中，如果key值一样，那么会覆盖相同key值的value为最新，所以key为null只能有一个。</li></ul><h3 id="重写HashMap的equal和hashcode方法需要注意什么？"><a href="#重写HashMap的equal和hashcode方法需要注意什么？" class="headerlink" title="重写HashMap的equal和hashcode方法需要注意什么？"></a>重写HashMap的equal和hashcode方法需要注意什么？</h3><p>HashMap使用Key对象的hashCode()和equals方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。</p><p>同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：</p><ul><li>如果o1.equals(o2)，那么o1.hashCode() &#x3D;&#x3D; o2.hashCode()总是为true的。</li><li>如果o1.hashCode() &#x3D;&#x3D; o2.hashCode()，并不意味着o1.equals(o2)会为true。</li></ul><h3 id="重写HashMap的equal方法不当会出现什么问题？"><a href="#重写HashMap的equal方法不当会出现什么问题？" class="headerlink" title="重写HashMap的equal方法不当会出现什么问题？"></a>重写HashMap的equal方法不当会出现什么问题？</h3><p>HashMap在比较元素时，会先通过hashCode进行比较，相同的情况下再通过equals进行比较。</p><p>所以 equals相等的两个对象，hashCode一定相等。hashCode相等的两个对象，equals不一定相等（比如散列冲突的情况）</p><p>重写了equals方法，不重写hashCode方法时，可能会出现equals方法返回为true，而hashCode方法却返回false，这样的一个后果会导致在hashmap等类中存储多个一模一样的对象，导致出现覆盖存储的数据的问题，这与hashmap只能有唯一的key的规范不符合。</p><h3 id="往hashmap存20个元素，会扩容几次？"><a href="#往hashmap存20个元素，会扩容几次？" class="headerlink" title="往hashmap存20个元素，会扩容几次？"></a>往hashmap存20个元素，会扩容几次？</h3><p>当插入 20 个元素时，HashMap 的扩容过程如下：</p><p><strong>初始容量</strong>：16</p><ul><li>插入第 1 到第 12 个元素时，不需要扩容。</li><li>插入第 13 个元素时，达到负载因子限制，需要扩容。此时，HashMap 的容量从 16 扩容到 32。</li></ul><p><strong>扩容后的容量</strong>：32</p><ul><li>插入第 14 到第 24 个元素时，不需要扩容。</li></ul><p>因此，总共会进行一次扩容。</p><h3 id="列举HashMap在多线程下可能会出现的问题？"><a href="#列举HashMap在多线程下可能会出现的问题？" class="headerlink" title="列举HashMap在多线程下可能会出现的问题？"></a>列举HashMap在多线程下可能会出现的问题？</h3><ul><li>JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li><li>多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</li></ul><h3 id="HashMap的扩容机制介绍一下"><a href="#HashMap的扩容机制介绍一下" class="headerlink" title="HashMap的扩容机制介绍一下"></a>HashMap的扩容机制介绍一下</h3><p>hashMap默认的负载因子是0.75，即如果hashmap中的元素个数超过了总容量75%，则会触发扩容，扩容分为两个步骤：</p><ul><li><strong>第1步</strong>是对哈希表长度的扩展（2倍）</li><li><strong>第2步</strong>是将旧哈希表中的数据放到新的哈希表中。</li></ul><p>因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p><p>如我们从16扩展为32时，具体的变化如下所示：</p><p><img src="/./../img/1713514753772-9467a399-6b18-4a47-89d4-957adcc53cc0.webp" alt="img"></p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="/./../img/1713514753786-cdca10bf-6eda-47f9-9bbe-0cc3beb67d76.webp" alt="img"></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了（原有的值相当于是暴露出来了可以使用了），是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：</p><p><img src="/./../img/1713514753885-d1529537-322c-49b1-beec-5d9953da5150.webp" alt="img"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="ConcurrentHashMap用了悲观锁还是乐观锁"><a href="#ConcurrentHashMap用了悲观锁还是乐观锁" class="headerlink" title="ConcurrentHashMap用了悲观锁还是乐观锁?"></a>ConcurrentHashMap用了悲观锁还是乐观锁?</h3><p>悲观锁和乐观锁都有用到。</p><p>添加元素时首先会判断容器是否为空：</p><ul><li>如果为空则使用 volatile 加 <strong>CAS （乐观锁）</strong> 来初始化。</li><li>如果容器不为空，则根据存储的元素计算该位置是否为空。</li><li>如果根据存储的元素计算结果为空，则利用 <strong>CAS（乐观锁）</strong> 设置该节点；</li><li>如果根据存储的元素计算结果不为空，则使用 <strong>synchronized（悲观锁）</strong> ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了</li></ul><h3 id="HashTable-底层实现原理是什么？"><a href="#HashTable-底层实现原理是什么？" class="headerlink" title="HashTable 底层实现原理是什么？"></a>HashTable 底层实现原理是什么？</h3><p><img src="/./../img/1719982934770-8587cb0a-6e1d-4007-9a22-bc1e41276491.png" alt="img"></p><ul><li>Hashtable的底层数据结构主要是<strong>数组加上链表</strong>，数组是主体，链表是解决hash冲突存在的。</li><li>HashTable是线程安全的，实现方式是<strong>Hashtable的所有公共方法均采用synchronized关键字</strong>，当一个线程访问同步方法，另一个线程也访问的时候，就会陷入阻塞或者轮询的状态。</li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h3 id="Set集合有什么特点？如何实现key无重复的？"><a href="#Set集合有什么特点？如何实现key无重复的？" class="headerlink" title="Set集合有什么特点？如何实现key无重复的？"></a>Set集合有什么特点？如何实现key无重复的？</h3><ul><li><strong>set集合特点</strong>：Set集合中的元素是唯一的，不会出现重复的元素。</li><li><strong>set实现原理</strong>：Set集合通过内部的数据结构（如哈希表、红黑树等）来实现key的无重复。（插入key，value为一个常量值present）</li></ul><h1 id="初始容量问题"><a href="#初始容量问题" class="headerlink" title="初始容量问题"></a>初始容量问题</h1><table><thead><tr><th>集合类</th><th>无参构造初始容量</th><th>首次添加后容量</th><th>最小允许显式容量</th><th>备注</th></tr></thead><tbody><tr><td>ArrayList</td><td>0</td><td>10</td><td>0</td><td>Java 8+延迟初始化</td></tr><tr><td>HashMap</td><td>0</td><td>16</td><td>1</td><td>容量总是2的幂</td></tr></tbody></table><ol><li><strong>HashMap容量规则</strong>：<ul><li>容量总是2的幂</li><li>指定容量0会被调整为1</li><li>指定容量1-16都会被调整为16（首次添加元素时）</li><li>实际容量计算：大于等于指定值的最小2的幂</li></ul></li><li><strong>性能影响</strong>：<ul><li>如果已知集合大小，最好在构造时指定合适的初始容量</li><li>避免频繁扩容带来的性能开销</li><li><strong>ArrayList扩容时会增加50%的容量</strong></li><li><strong>HashMap扩容会翻倍容量</strong></li></ul></li></ol><h4 id="Vector-遗留类，线程安全"><a href="#Vector-遗留类，线程安全" class="headerlink" title="Vector (遗留类，线程安全)"></a><strong>Vector</strong> (遗留类，线程安全)</h4><ul><li><strong>无延迟初始化</strong>：构造时立即分配数组</li><li>默认容量10，扩容时翻倍（与ArrayList的1.5倍不同</li></ul><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a><strong>PriorityQueue</strong></h4><ul><li>无延迟初始化，构造时分配大小为11的数组</li><li>为什么是11？历史原因，与堆数据结构特性有关</li></ul><h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a><strong>ArrayDeque</strong></h4><ul><li>无延迟初始化</li><li>为什么是16？优化循环数组操作，2的幂便于位运算</li></ul><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>100快猫短剧</title>
    <link href="/2025/11/22/100%E5%BF%AB%E7%8C%AB%E7%9F%AD%E5%89%A7/"/>
    <url>/2025/11/22/100%E5%BF%AB%E7%8C%AB%E7%9F%AD%E5%89%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="简历写法"><a href="#简历写法" class="headerlink" title="简历写法"></a>简历写法</h1><p><strong>当前市场</strong>：</p><ol><li><p><strong>微信小程序一堆的短剧</strong>、剧场类项目；这类项目唯一盈利点（付费解锁全集、月度&#x2F;年度会员）； 靠投广告，吸引用户看，开通付费</p></li><li><p><strong>应用市场一堆</strong> <strong>短剧</strong>、剧场类项目；App的盈利点</p></li></ol><p>(1)   大量的用户看广告，收广告的钱</p><p>(1)  先做一个简单的自我介绍，说一下最近的项目</p><p>面试官你好。Xxxxx</p><ol><li>最近项目、项目业务、业务技术（目的：给面试官感觉项目不错、技术栈挺ok、能问很多点）</li></ol><p>做了什么项目，项目技术栈（主要用了boot&#x2F;cloud&#x2F;缓存&#x2F;kafka），主要有哪些模块，自己做了哪些模块。模块的功能。功能的特色</p><p><strong>胖猫短剧平台</strong>是一个基于微服务架构的短视频内容分发平台，专注于短剧内容的创作、审核、发布、播放与用户互动。系统采用RuoYi-Cloud脚手架构建，集成了工作流引擎、AI审核、视频处理、消息队列等现代化技术栈。</p><h1 id="1-介绍！！（背诵）"><a href="#1-介绍！！（背诵）" class="headerlink" title="1.介绍！！（背诵）"></a>1.介绍！！（背诵）</h1><p><strong>最近项目</strong>：最近做了一个短剧项目，项目主要功能有短剧审核、短剧发布、App首页信息流刷剧、用户行为系统、会员系统等。</p><ol><li>我负责了 短剧审核的整个流程（上架上传审核通过等流程）的开发：</li></ol><p>整个审核是由Camunda流程引擎驱动，主要完成短剧发布后的Ai审核任务、视频信息流&#x2F;画质流转码任务。这些任务为了稳定调度，还引入了<strong>xxl-job</strong>。还涉及到 AI大模型在审核方面的使用，以及腾讯云VOD系统的转码以及可靠通知流程</p><ol start="2"><li><p>还做了App首页<strong>响应短剧数据请求接口的设计和开发</strong>；主要涉及到<strong>缓存</strong>的使用，使用之后大幅度提升性能。 </p></li><li><p>最后负责了用户<strong>交互系统</strong>的整个开发流程（短剧点赞、收藏、评论、评论点赞、播放记录、播放进度等…），特色：将<strong>用户交互行为系统（互动服务）<strong>抽取成事件模式，每一种用户行为事件，都由Kafka进行统一保存，内容服务、互动服务、用户服务等服务模块来消费Kafka消息。完成数据库数据和缓存数据的最终一致性。缓存进行特别的设计（数据只看缓存，数据库相当于备份）。以前都是先读缓存，缓存没有就查库。我们现在由于</strong>用户互动行为</strong>频率太高了，所以全部的操作都去缓存中操作，由数据库进行同步。整个的一致性同步是<strong>靠</strong> <strong>Kafka</strong> <strong>消息消费抵达，我们进行双写</strong>。</p></li></ol><h1 id="STAR话术（）"><a href="#STAR话术（）" class="headerlink" title="STAR话术（）"></a>STAR话术（）</h1><p><strong>STAR：</strong></p><ol><li><p><strong>S</strong>：需要开发开发完整的短剧上传-审核-转码-发布流程</p><p>整个审核是由Camunda流程引擎驱动，主要完成短剧发布后的Ai审核任务、视频信息流&#x2F;画质流转码任务。这些任务为了稳定调度，还引入了<strong>xxl-job</strong>。还涉及到 AI大模型在审核方面的使用，以及腾讯云VOD系统的转码以及可靠通知流程</p><ol><li><p><strong>T</strong>：<strong>主要AI审核和对接腾讯云视频转码平台</strong></p></li><li><p><strong>A</strong>：</p><ol start="2"><li><p>本地部署ollama，使用deepseekr1基本模型，基于提示词模板，进行结构化输出指定的json；</p></li><li><p>判断正向是否合法，负面是否不合法</p><ol><li>json结构：二分类：{negative: 0.7, positive:0.3},  {sad: 0.666, happy: 0.217, xxx}</li></ol></li><li><p>为了实<strong>现稳定转码，和人工兜底处理</strong>。&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;引入了 xxl-job，将转码任务交给 xxl-job 调度给某个机器，并且设置失败重试规则。 这样的好处是，即使多次失败后，任务还在xxl-job中有保存。手动修复相关问题后还可以继续手工启动任务；（主要核心思路，xxl-job原生只支持在控制台提交定时任务。现在需要AI审核通过以后，自动提交转码任务。所以默认robot机器人账号登录xxl-job，触发一个一次性任务启动）</p></li><li><p>使用轮询机制，每10秒（*2）获取 vod 的转码结果消息。 只要看到转码成功的状态，提取信息流和画质流分别对应的转码结果，特别是画质流，要从结果中基于视频的 height 分辨出 各种分辨率视频对应的url地址</p></li></ol></li><li><p><strong>R</strong>：（可观测出的指标都可以描述）</p><ol><li>最终基于线上的Prometheus+Grafana的整个监控系统反应。视频转码任务的调度成功率（成功次数&#x2F;总次数）保持在 90% 以上。基本上3次以内重试，保证99% 都能转码成功。可能网络或者云厂商系统故障导致的 需要人工介入的比例下降很多。</li></ol></li></ol></li><li><p>还做了App首页<strong>响应短剧数据请求接口的设计和开发</strong>；主要涉及到<strong>缓存</strong>的使用，使用之后大幅度提升性能。 </p></li><li><p>最后负责了用户<strong>交互系统</strong>的整个开发流程（短剧点赞、收藏、评论、评论点赞、播放记录、播放进度等…），特色：将<strong>用户交互行为系统（互动服务）<strong>抽取成事件模式，每一种用户行为事件，都由Kafka进行统一保存，内容服务、互动服务、用户服务等服务模块来消费Kafka消息。完成数据库数据和缓存数据的最终一致性。缓存进行特别的设计（数据只看缓存，数据库相当于备份）。以前都是先读缓存，缓存没有就查库。我们现在由于</strong>用户互动行为</strong>频率太高了，所以全部的操作都去缓存中操作，由数据库进行同步。整个的一致性同步是<strong>靠</strong> <strong>Kafka</strong> <strong>消息消费抵达，我们进行双写</strong>。</p></li></ol><p>二、</p><ol><li><strong>S</strong>：为了应对视频类应用的用户高频行为操作场景（主要是播放进度、点赞、收藏等一些用户行为）<ol><li>T：我们需要开发全用户事件感知系统</li><li>A：<ol><li>因为考虑到 播放进度需要前端每秒汇报一次，请求速率很高。并且记录用户的播放进度。引入kafka 进行血风田谷，并设计用户事件发送消息（UserEvent extends BaseEvent [唯一id，发送事件，用户]）。 用户的所有行为请求进来，直接封装为事件。发送给kafka；（基本信息的封装由kafkaTemplate的拦截器进行统一设置。）</li><li>其他服务模块监听<strong>kafka消息</strong>，从而实现同步；<ol><li><strong>Redis数据缓存系统</strong>：<strong>缓存优先模式</strong>（短剧信息、短剧点赞数量、短剧播放进度都直接查Redis，Redis没有再走回源逻辑即可）， 所有和用户对接的高频的增删改查，查redis即可； </li><li>这些数过期时间为24h，考虑到 一旦数据过期要回源。MySQL由于自己同步速度慢，没有同步到数据，导致回源无数据，从而产生数据不一致问题。</li><li>MySQL持久化系统：监听到消息以后。慢慢的进行数据保存；（Redis万一哪天没有数据，就回源MySQL查询）</li></ol></li></ol></li><li>R：实现了最终一致性MySQL目前和Redis数据差异基本在秒级（由于目前量还没有太大）；<strong>用户高频操作的缓存命中率：几乎100%；基本不回源</strong>。Redis 的线上故障时间（目前除了手动停机，Redis自己没停机过）。Redis 是 8核 32G 机器。 主从复制。无哨兵</li></ol></li></ol><p>面试问的大范围：</p><ol><li><p>流程引擎用法</p></li><li><p>Xxl-job 用法</p></li><li><p>Ai整合使用流程</p></li><li><p>信息流&#x2F;画质流，转码流程</p></li><li><p>腾讯云VOD系统，</p></li><li><p>高性能接口： 缓存、异步、排队</p></li><li><p>Kafka</p></li><li><p>最终一致性、Raft</p></li></ol><h1 id="2-重难点-亮点"><a href="#2-重难点-亮点" class="headerlink" title="2.重难点&#x2F;亮点"></a>2.重难点&#x2F;亮点</h1><p>面试官：你就说一下，你这个项目中你有遇到哪些难点问题吗？怎么解决的？</p><p>难点：视频转码任务；；xxl-job的二次开发、腾讯云事件的解析</p><p>重点：保证首页短剧的接口如何<strong>高性能</strong>；</p><h2 id="1-视频转码"><a href="#1-视频转码" class="headerlink" title="1. 视频转码"></a>1. 视频转码</h2><p>由于腾讯云视频转码是一个后台任务，不一定什么时候执行完。我们和腾讯云转码的联动是由xxl-job进行驱动。视频发布以后，启动转码任务，这个转码任务提交给xxl-job进行调度；</p><h3 id="1-我们对xxl-job-做了二次改造；"><a href="#1-我们对xxl-job-做了二次改造；" class="headerlink" title="1.我们对xxl-job 做了二次改造；"></a>1.我们对xxl-job 做了二次改造；</h3><p>由于xxl-job的任务，默认是在他的控制台进行手动配置然后定时触发。我们现在需要的是，视频一上传，自动给xxl-job提交任务，调用vod转码，因此需要完成自动提交任务功能</p><h4 id="需要对接口进行分析构造请求"><a href="#需要对接口进行分析构造请求" class="headerlink" title="需要对接口进行分析构造请求"></a>需要对接口进行分析构造请求</h4><p>所以我们先在 xxl-job 中开通一个 robot 账号。模拟机器人登录xxl-job。然后模拟给xxl-job 发请求（需要分析xxl-job-admin 哪些功能都发什么请求，需要解析出来，</p><p>比如：                                         <img src="./../img/image-20251124153836533.png" alt="image-20251124153836533" style="zoom:50%;" /></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> HttpCookie <span class="hljs-title">robotLogin</span><span class="hljs-params">()</span></span>&#123;<br>    Map&lt;<span class="hljs-type">String</span>,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;userName&quot;</span>,xxlJobConfig.<span class="hljs-built_in">getUsername</span>());<br>    map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;password&quot;</span>,xxlJobConfig.<span class="hljs-built_in">getPassword</span>());<br>    <span class="hljs-comment">//1、发送请求，模拟登录 xxl-job</span><br>    HttpResponse response = HttpUtil.<span class="hljs-built_in">createPost</span>(<br>        xxlJobConfig.<span class="hljs-built_in">getAdminAddresses</span>()+<span class="hljs-string">&quot;/auth/doLogin&quot;</span>)<br>        .form(map)<br>        .<span class="hljs-built_in">execute</span>();<br><br>    <span class="hljs-comment">//2、拿到响应的cookie</span><br>    List&lt;HttpCookie&gt; cookies = response.<span class="hljs-built_in">getCookies</span>();<br>    <span class="hljs-keyword">return</span> cookies.<span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> HttpResponse <span class="hljs-title">triggerJob</span><span class="hljs-params">(HttpCookie cookie, Map&lt;<span class="hljs-type">String</span>,Object&gt; map)</span></span>&#123;<br>    <span class="hljs-type">String</span> url = xxlJobConfig.<span class="hljs-built_in">getAdminAddresses</span>()+<span class="hljs-string">&quot;/jobinfo/trigger&quot;</span>;<br>    HttpResponse response = HttpUtil.<span class="hljs-built_in">createPost</span>(url)<br>        .form(map)<br>        .<span class="hljs-built_in">cookie</span>(cookie)<br>        .<span class="hljs-built_in">execute</span>();<br>    <span class="hljs-keyword">return</span> response;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造对应的请求数据，然后模拟后台操作）。 去启动一个转码任务。转码任务被调度以后， 会给腾讯云提交两个任务流，分别是信息流任务和画质流任务。信息流主要低码率视频，通过网络能快速传输，方便用户上下滑动切换的时候，视频可以流畅播放。画质流主要是多画质转码（480p、720p、1080p）。 任务流什么时候运行完不一定。</p><p>用xxl-job的好处，调度的任务，在控制台有手动触发的方式。提供了手动补偿的方式。</p><h3 id="2-我们需要获取腾讯云转码结果"><a href="#2-我们需要获取腾讯云转码结果" class="headerlink" title="2.我们需要获取腾讯云转码结果"></a>2.我们需要获取腾讯云转码结果</h3><p>使用腾讯云可靠消息模式（腾讯云每次完成的事件，会保存到他自己的队列中），需要我们客户端自己连上腾讯云拉取对应的事件。确认消费后，给腾讯云回复ok；</p><p><strong>消息的获取</strong>： 需要使用<strong>轮询</strong>（每隔3s拉取腾讯云的所有事件），一直到拉取到当前转码视频对应的事件，需要<strong>解包</strong>腾讯云的数据（数据层级关系比较深，分析起来有点麻烦），解析到对应数据后，要提交到转码后的视频流地址，统一收集所有地址，去数据库批量保存转码后的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取画质</span><br>    <span class="hljs-keyword">private</span> EpicodeVodRelation <span class="hljs-title function_">waitQualityTranslateResult</span><span class="hljs-params">(String fileId)</span>&#123;<br>        <span class="hljs-type">EpicodeVodRelation</span> <span class="hljs-variable">relation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EpicodeVodRelation</span>();<br>        <span class="hljs-comment">//等待转码结果</span><br>        <span class="hljs-type">PullEventsRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PullEventsRequest</span>();<br>        request.setSubAppId(vodProperties.getStuAppId());<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">PullEventsResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> vodClient.PullEvents(request);<br>            <span class="hljs-keyword">if</span> (response != <span class="hljs-literal">null</span> &amp;&amp; response.getEventSet() != <span class="hljs-literal">null</span>) &#123;<br>                log.info(<span class="hljs-string">&quot;获取到腾讯云事件....&#123;&#125;&quot;</span>,response);<br>                <span class="hljs-keyword">for</span> (EventContent content : response.getEventSet()) &#123;<br>                    log.info(<span class="hljs-string">&quot;事件类型：&#123;&#125;&quot;</span>,content.getEventType());<br>                    <span class="hljs-comment">//如果是转码事件，且是当前文件的</span><br>                    <span class="hljs-keyword">if</span> (content.getEventType().equals(VodConst.PROCEDURE_STATE_CHANGED)) &#123;<br>                        <span class="hljs-comment">//拿到了我的事件</span><br>                        <span class="hljs-type">ProcedureTask</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> content.getProcedureStateChangeEvent();<br>                        log.info(<span class="hljs-string">&quot;事件详情 fileId：&#123;&#125;&quot;</span>,event.getFileId());<br>                        <span class="hljs-comment">//拿到自己的转码数据</span><br>                        <span class="hljs-keyword">if</span> (event.getFileId().equals(fileId) &amp;&amp; event.getStatus().equals(VodConst.STATUS_FINISH)) &#123;<br><br>                            log.info(<span class="hljs-string">&quot;获取到自己的转码数据，正在处理.... &#123;&#125;&quot;</span>,event.getFileId());<br>                            <span class="hljs-type">ConfirmEventsRequest</span> <span class="hljs-variable">confirmReuest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfirmEventsRequest</span>();<br>                            confirmReuest.setSubAppId(vodProperties.getStuAppId());<br>                            confirmReuest.setEventHandles(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;content.getEventHandle()&#125;);<br><br><br>                            <span class="hljs-comment">//TODO 获取到数据; 封装转码后的结果</span><br>                            <span class="hljs-keyword">for</span> (MediaProcessTaskResult result : event.getMediaProcessResultSet()) &#123;<br>                                <span class="hljs-type">MediaTranscodeItem</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> result.getTranscodeTask().getOutput();<br>                                <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> output.getUrl();<br>                                <span class="hljs-keyword">switch</span> (output.getWidth()+<span class="hljs-string">&quot;&quot;</span>)&#123;<br>                                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1080&quot;</span>:<br>                                        relation.setHdUrl(url);<br>                                        <span class="hljs-keyword">break</span>;<br>                                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;720&quot;</span>:<br>                                        relation.setSdUrl(url);<br>                                        <span class="hljs-keyword">break</span>;<br>                                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;480&quot;</span>:<br>                                        relation.setLowUrl(url);<br>                                        <span class="hljs-keyword">break</span>;<br>                                &#125;<br><br>                            &#125;<br>                            XxlJobHelper.log(<span class="hljs-string">&quot;画质数据解析完成, &#123;&#125;&quot;</span>,relation);<br>                            log.info(<span class="hljs-string">&quot;画质数据解析完成, &#123;&#125;&quot;</span>,relation);<br>                            <span class="hljs-comment">//确认事件已经收到，防止重复获取</span><br>                            vodClient.ConfirmEvents(confirmReuest);<br>                            <span class="hljs-comment">//做完自己的事情跳出</span><br>                            <span class="hljs-keyword">return</span> relation;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;等待转码结果失败&quot;</span>,e);<br>            XxlJobHelper.log(<span class="hljs-string">&quot;等待转码结果失败: &#123;&#125;，稍后重试&quot;</span>,e.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">return</span> relation;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>(腾讯云一堆事件、所有的视频上传、删除、修改， 启动任务流、<strong>任务流状态变化</strong>…) 我们主要感知到信息流和画质流的任务状态变化。通过知道 status &#x3D; FINISH 且 事件对应的 fileId &#x3D; 当前视频。就相当于拿到数据了</p><p><strong>解完数据就无需再次轮询。就终止获取事件了</strong>。</p><p><strong>VOD</strong>：视频点播；保存腾讯云转码后的视频url地址。能开启*CDN加速，让用户访问腾讯云最近的服务器获取到数据</p><h1 id="难点使用-Camunda"><a href="#难点使用-Camunda" class="headerlink" title="难点使用 Camunda"></a>难点使用 Camunda</h1><p>参考话术：<br>视频审核是一个多阶段的流程：<br>AI审核–&gt;视频内容审核–&gt;人工审核–&gt;审核结果汇总<br>使用 Camunda 的目的是：<br>把复杂流程可视化<br>状态和节点可追溯<br>人工审核可以暂停&#x2F;回退<br>多个审核结果汇总更清晰<br>如果不用工作流，自己维护状态机会非常混乱。</p><h2 id="2-App首页端（重点）"><a href="#2-App首页端（重点）" class="headerlink" title="2. App首页端（重点）"></a>2. App首页端（重点）</h2><p><strong>高性能接口（缓存、异步）、</strong> <strong>自定义切面</strong></p><p>我们参与编写了几个核心的高性能接口，并进行对应压力测试，以满足要求（首页 95% 响应时间 150ms 以内， 99% 要求响应时间 300ms以内）</p><h3 id="1-首页推荐短剧信息流："><a href="#1-首页推荐短剧信息流：" class="headerlink" title="1. 首页推荐短剧信息流："></a>1. 首页推荐短剧信息流：</h3><p><strong>特色redis zset数据 <strong>+前后端配合使用</strong>cursor分页</strong> <strong>+</strong> <strong>定时任务给缓存上数据</strong> <strong>+</strong> <strong>异步线程池</strong></p><p><strong>由于这个接口第一次找数据库要的数据很多，第一次必须开启异步多线程同时获取各种数据</strong></p><p>所有短剧都是上缓存的。Redis中维护了缓存列表；</p><p>每天晚上<strong>xxl-job</strong>定时任务调度给某一个机器，把<strong>全量短剧</strong>上线到缓存中（分页查询数据库保存数据到redis）；</p><p>所有短剧实际上在一个 <strong>zset</strong> <strong>集合中</strong>。 每个短剧的分数目前就是点赞量，点赞是一个用户事件。点击以后会发送kafka消息，我们收到消息会更新缓存的同时，更新数据库。</p><p>用户获取短剧内容分页查询，但是<strong>分页不走数据库</strong>，我们使用redis对list&#x2F;<strong>zset</strong>&#x2F;set 提供的 zrange&#x2F;<strong>cursor</strong>（区间访问办法）</p><p>实现的分页。<strong>Cursor</strong> 有一个特点，不是说要10条redis就返回给用户10条。用户本质上是要新的一些数据，不一定返回10条，具体客户端此次请求要到的所有首页短剧信息流条目有多少以服务端为准。</p><h4 id="重点：所有的数据都上缓存，缓存使用zest结构（redis需要复习）"><a href="#重点：所有的数据都上缓存，缓存使用zest结构（redis需要复习）" class="headerlink" title="重点：所有的数据都上缓存，缓存使用zest结构（redis需要复习）"></a>重点：所有的数据都上缓存，缓存<strong>使用zest</strong>结构（redis需要复习）</h4><p>，使用<strong>cursor</strong>的方式处理前端的分页查询。 查询完成，会给前端返回新的<strong>cursor</strong>位置，前端下一次发请求带上新位置，从这个位置开始获取一页数据；  缓存数据什么时候会更新？（主动&#x2F;被动更新模式）</p><p><strong>集合中数据的变化有两种</strong>，暂时没有个性化推荐</p><ol><li><p>新发短剧，立即<strong>更新缓存</strong></p></li><li><p>每晚定时任务，更新<strong>短剧缓存</strong></p></li></ol><h3 id="2-短剧详情：（详情页）"><a href="#2-短剧详情：（详情页）" class="headerlink" title="2. 短剧详情：（详情页）"></a>2. 短剧详情：（详情页）</h3><p>特色：缓存切面（缓存各大问题方案 + 分布式锁 全部集成） + Redisson</p><p>演员、介绍、图片…</p><p><strong>缓存逻辑，短剧详细信息默认先查缓存</strong>，缓存中没有就准备回源。为了解决缓存的问题（穿透、击穿、雪崩）引入了一系列方案</p><h3 id="3-短剧剧集列表：每个短剧所有集信息（列表页）"><a href="#3-短剧剧集列表：每个短剧所有集信息（列表页）" class="headerlink" title="3. 短剧剧集列表：每个短剧所有集信息（列表页）"></a>3. 短剧剧集列表：每个短剧所有集信息（列表页）</h3><p><strong>缓存逻辑，短剧详细信息默认先查缓存</strong></p><p><img src="/./../img/image-20251123202120347.png" alt="image-20251123202120347"></p><h3 id="4-【自定义】：抽取了缓存注解和缓存切面"><a href="#4-【自定义】：抽取了缓存注解和缓存切面" class="headerlink" title="4. 【自定义】：抽取了缓存注解和缓存切面"></a>4. 【自定义】：抽取了缓存注解和缓存切面</h3><p><strong>我们抽取了两个通用的功能切面和注解：缓存注解和分布式锁注解</strong></p><p><strong>@CacheData</strong> 自定义注解：  Spring Cache 提供的缓存注解，仅仅是简单的把数据放到缓存。没有 <strong>布隆过滤器、分布式锁、穿透、击穿、雪崩</strong>的解决方案</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs processing">    @<span class="hljs-title function_">Around</span>(<span class="hljs-string">&quot;@annotation(com.lfy.kcat.user.cache.CacheData)&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span> <span class="hljs-title function_">around</span>(ProceedingJoinPoint joinPoint)<br>        <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//1、先看缓存中有没有；获取到当前方法标注的注解，看是用哪个cacheKey</span><br>        MethodSignature signature = (MethodSignature) joinPoint.<span class="hljs-property">getSignature</span>();<br><br>        <span class="hljs-comment">//2、获取当前方法标注的注解的详情</span><br>        CacheData cacheDataAnn = signature.<span class="hljs-property">getMethod</span>().<span class="hljs-property">getDeclaredAnnotation</span>(CacheData.<span class="hljs-property">class</span>);<br>        <span class="hljs-built_in">String</span> cacheKey = cacheDataAnn.<span class="hljs-property">cacheKey</span>();<br><br>        <span class="hljs-comment">//3、获取方法当时调用时的参数</span><br>        <span class="hljs-built_in">Object</span>[] args = joinPoint.<span class="hljs-property">getArgs</span>();<br><br>        <span class="hljs-comment">//4、根据方法的参数拼串得到 cacheKey 的全值</span><br>        cacheKey = cacheKey + args[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">//5、获取当前方法的返回值类型</span><br>        Class returnType = signature.<span class="hljs-property">getReturnType</span>();<br><br>        <span class="hljs-comment">//TODO 从缓存中获取数据</span><br>        <span class="hljs-built_in">Object</span> data = redisService.<span class="hljs-property">getData</span>(cacheKey, returnType);<br>        <span class="hljs-keyword">if</span>(data != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">log</span>.<span class="hljs-property">info</span>(<span class="hljs-string">&quot;缓存切面，缓存命中，cacheKey：&#123;&#125;&quot;</span>,cacheKey);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br><br>        <span class="hljs-comment">//能走到这里，说明缓存没有； 准备回源；</span><br>        <span class="hljs-built_in">String</span> bloomFilterName = cacheDataAnn.<span class="hljs-property">bloomFilterName</span>();<br>        <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-property">isEmpty</span>(bloomFilterName)) &#123;<br>            <span class="hljs-comment">//使用布隆进行过滤</span><br>            <span class="hljs-built_in">log</span>.<span class="hljs-property">info</span>(<span class="hljs-string">&quot;缓存切面，缓存未命中，准备回源之前，问布隆：&#123;&#125;&quot;</span>,bloomFilterName);<br>            RBloomFilter&lt;<span class="hljs-built_in">Object</span>&gt; <span class="hljs-built_in">filter</span> = redissonClient.<span class="hljs-property">getBloomFilter</span>(bloomFilterName);<br><br>            <span class="hljs-comment">//获取到方法的第一个参数；</span><br>            <span class="hljs-built_in">Object</span> bfEntityId = joinPoint.<span class="hljs-property">getArgs</span>()[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">boolean</span> contains = <span class="hljs-built_in">filter</span>.<span class="hljs-property">contains</span>(bfEntityId);<br>            <span class="hljs-keyword">if</span> (!contains) &#123;<br>                <span class="hljs-comment">//说明布隆过滤器中没有， 直接返回</span><br>                <span class="hljs-built_in">log</span>.<span class="hljs-property">info</span>(<span class="hljs-string">&quot;缓存切面，问 &#123;&#125; 布隆，布隆说没有：&#123;&#125;&quot;</span>,bloomFilterName,bfEntityId);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//布隆过滤器（防止缓存穿透）、分布式锁（防止缓存击穿）</span><br>        <span class="hljs-comment">//布隆说有，准备回源; 加分布式锁</span><br>        <span class="hljs-comment">// lock:home:dramas:episodes:1967494716564226050</span><br>        <span class="hljs-built_in">String</span> lockKey = <span class="hljs-string">&quot;lock:&quot;</span>+cacheKey;<br>        RLock lock = redissonClient.<span class="hljs-property">getLock</span>(lockKey);<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-type">boolean</span> b = lock.<span class="hljs-property">tryLock</span>();<br>            <span class="hljs-keyword">if</span> (b) &#123;<br>                <span class="hljs-comment">//TODO 得到锁的人，执行回源</span><br>                <span class="hljs-built_in">Object</span> proceed = joinPoint.<span class="hljs-property">proceed</span>();<br>                <span class="hljs-built_in">log</span>.<span class="hljs-property">info</span>(<span class="hljs-string">&quot;缓存切面回源完成... &#123;&#125;&quot;</span>, proceed);<br>                redisService.<span class="hljs-property">saveData</span>(cacheKey, proceed);<br>                <span class="hljs-built_in">log</span>.<span class="hljs-property">info</span>(<span class="hljs-string">&quot;缓存切面回源完成并保存到缓存中&quot;</span>);<br>                <span class="hljs-keyword">return</span> proceed;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//TODO 没有得到锁的人，等待2s，去缓存中直接拿</span><br>                <span class="hljs-built_in">log</span>.<span class="hljs-property">info</span>(<span class="hljs-string">&quot;缓存切面，没有得到锁，等待2s，去缓存中直接拿&quot;</span>);<br>                Thread.<span class="hljs-property">sleep</span>(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">return</span> redisService.<span class="hljs-property">getData</span>(cacheKey,returnType);<br>            &#125;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.<span class="hljs-property">unlock</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@RedisLock</strong>(key&#x3D;”lock”) 自定义注解：</p><p>redis设计模型</p><p><img src="/./../img/image-20251123202120347.png" alt="image-20251123202120347"></p><h2 id="3-互动服务（两点）"><a href="#3-互动服务（两点）" class="headerlink" title="3. 互动服务（两点）"></a>3. 互动服务（两点）</h2><p>在这一个模块，我们构建一个全用户事件感知系统，实现的是最终一致性方案，针对性的设计了缓存数据模型，并且缓存优先进行读写</p><p><strong>观看期间产生的所有用户事件</strong>： 由消息队列实现最终一致性进行处理。</p><p>用户事件是一个高频操作：单说<strong>播放进度</strong>，就是前端每秒会给我们<strong>汇报进度</strong>。高频操作。</p><p><img src="/./../img/image-20251123201922337.png" alt="image-20251123201922337"></p><h3 id="1-点赞-取消"><a href="#1-点赞-取消" class="headerlink" title="1. 点赞&#x2F;取消"></a>1. 点赞&#x2F;取消</h3><p><img src="/./../img/image-20251123202003700.png" alt="image-20251123202003700"></p><h3 id="1-短剧观看历史（点进短剧）"><a href="#1-短剧观看历史（点进短剧）" class="headerlink" title="1. 短剧观看历史（点进短剧）"></a>1. 短剧观看历史（点进短剧）</h3><h3 id="2-收藏-取消"><a href="#2-收藏-取消" class="headerlink" title="2. 收藏&#x2F;取消"></a>2. 收藏&#x2F;取消</h3><h3 id="3-评论"><a href="#3-评论" class="headerlink" title="3. 评论"></a>3. 评论</h3><h3 id="4-评论点赞"><a href="#4-评论点赞" class="headerlink" title="4. 评论点赞"></a>4. 评论点赞</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs nix">┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段<span class="hljs-number">1</span>：用户点击点赞（user-service）                                    │<br>└─────────────────────────────────────────────────────────────────────┘<br>App请求 <span class="hljs-operator">/</span>api<span class="hljs-operator">/</span>episodes<span class="hljs-operator">/</span>&#123;episodeId&#125;<span class="hljs-symbol">/like</span><br>  <span class="hljs-params">Body:</span> &#123; <span class="hljs-params">action:</span> <span class="hljs-string">&quot;like&quot;</span> &#125;  <span class="hljs-operator">//</span> 或 <span class="hljs-string">&quot;unlike&quot;</span><br>  <span class="hljs-params">Header:</span> <span class="hljs-params">Authorization:</span> Bearer &#123;token&#125;<br>  ↓<br>AppInteractionController.likeEpisode(episodeId, EpisodesLikeReqVo)<br>  ↓<br><span class="hljs-number">1</span>. Sa-Token登录校验：StpUtil.isLogin() → 未登录抛出异常<br><span class="hljs-number">2</span>. 获取当前用户ID：StpUtil.getLoginIdAsLong()<br>  ↓<br>LikeBizServiceImpl.likeEpisode(episodeId, reqVo)<br>  ↓<br><span class="hljs-number">3</span>. 构造LikeEvent事件对象：<br>   <span class="hljs-operator">-</span> <span class="hljs-params">episodeId:</span> 剧集ID<br>   <span class="hljs-operator">-</span> <span class="hljs-params">action:</span> <span class="hljs-string">&quot;like&quot;</span> 或 <span class="hljs-string">&quot;unlike&quot;</span><br>   <span class="hljs-operator">-</span> <span class="hljs-params">msgId:</span> <span class="hljs-literal">null</span>（生产者拦截器自动填充）<br>   <span class="hljs-operator">-</span> <span class="hljs-params">userId:</span> <span class="hljs-literal">null</span>（生产者拦截器自动填充）<br>   <span class="hljs-operator">-</span> <span class="hljs-params">timestamp:</span> <span class="hljs-literal">null</span>（生产者拦截器自动填充）<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段<span class="hljs-number">2</span>：发送Kafka消息                                                  │<br>└─────────────────────────────────────────────────────────────────────┘<br><span class="hljs-number">4</span>. KafkaTemplate.send()：<br>   <span class="hljs-operator">-</span> <span class="hljs-params">Topic:</span> <span class="hljs-string">&quot;like-event-topic&quot;</span><br>   <span class="hljs-operator">-</span> <span class="hljs-params">Key:</span> <span class="hljs-string">&quot;like-event-&#123;episodeId&#125;-&#123;userId&#125;&quot;</span>（保证同一用户对同一剧集的操作顺序）<br>   <span class="hljs-operator">-</span> <span class="hljs-params">Value:</span> LikeEvent对象<br>  ↓<br><span class="hljs-number">5</span>. KafkaEventProducerInterceptor拦截器自动填充：<br>   <span class="hljs-operator">-</span> <span class="hljs-params">msgId:</span> IdUtil.getSnowflakeNextId()（雪花算法生成唯一ID）<br>   <span class="hljs-operator">-</span> <span class="hljs-params">userId:</span> StpUtil.getLoginIdAsLong()<br>   <span class="hljs-operator">-</span> <span class="hljs-params">timestamp:</span> System.currentTimeMillis()<br>  ↓<br><span class="hljs-number">6</span>. 消息发送到Kafka Broker<br><span class="hljs-number">7</span>. 返回成功响应给App（不等待消费完成）<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 阶段<span class="hljs-number">3</span>：Kafka消费者处理（user-service 和 interaction-service）          │<br>└─────────────────────────────────────────────────────────────────────┘<br><br>┌──────────────────────────────────────────────────────────────────┐<br>│ 消费者<span class="hljs-number">1</span>：user-service (LikeEventListener)                         │<br>└──────────────────────────────────────────────────────────────────┘<br><span class="hljs-number">8</span>. 监听<span class="hljs-params">Topic:</span> <span class="hljs-string">&quot;like-event-topic&quot;</span><br><span class="hljs-number">9</span>. 接收LikeEvent消息<br><span class="hljs-number">10</span>. 更新Redis缓存（首页精选视频缓存）：<br>    a. 查询Redis缓存（<span class="hljs-params">key:</span> <span class="hljs-string">&quot;home:episodes:featured:&#123;pageNum&#125;:&#123;pageSize&#125;&quot;</span>）<br>    b. 遍历短剧列表，找到对应的episodeId<br>    c. action <span class="hljs-operator">=</span> <span class="hljs-string">&quot;like&quot;</span> <span class="hljs-operator">?</span><br>       ├─ 是 → likeCount <span class="hljs-operator">+</span> <span class="hljs-number">1</span><br>       └─ 否 → likeCount <span class="hljs-operator">-</span> <span class="hljs-number">1</span><br>    d. 回写Redis缓存<br><span class="hljs-number">11</span>. 更新Redis Set（点赞状态）：<br>    a. <span class="hljs-params">key:</span> <span class="hljs-string">&quot;like:episode:&#123;episodeId&#125;&quot;</span><br>    b. action <span class="hljs-operator">=</span> <span class="hljs-string">&quot;like&quot;</span> <span class="hljs-operator">?</span><br>       ├─ 是 → sadd userId<br>       └─ 否 → srem userId<br><span class="hljs-number">12</span>. 手动ACK确认<br><br>┌──────────────────────────────────────────────────────────────────┐<br>│ 消费者<span class="hljs-number">2</span>：interaction-service (LikeEventListener)                  │<br>└──────────────────────────────────────────────────────────────────┘<br><span class="hljs-number">13</span>. 监听<span class="hljs-params">Topic:</span> <span class="hljs-string">&quot;like-event-topic&quot;</span><br><span class="hljs-number">14</span>. 接收LikeEvent消息<br><span class="hljs-number">15</span>. LikeBizServiceImpl.likeEpisode()：<br>    a. 查询user_likes表：（更新mysql数据库）<br>       <span class="hljs-operator">-</span> userId <span class="hljs-operator">=</span> <span class="hljs-operator">?</span><br>       <span class="hljs-operator">-</span> targetId <span class="hljs-operator">=</span> episodeId<br>       <span class="hljs-operator">-</span> targetType <span class="hljs-operator">=</span> <span class="hljs-number">2</span>（剧集）<br>    b. 记录存在？<br>       ├─ 是 → 更新status字段（action<span class="hljs-operator">=</span><span class="hljs-string">&quot;like&quot;</span> → <span class="hljs-number">1</span>, <span class="hljs-string">&quot;unlike&quot;</span> → <span class="hljs-number">0</span>）<br>       └─ 否 → 插入新记录<br><span class="hljs-number">16</span>. 更新Redis缓存（首页精选视频缓存中的点赞数）<br><span class="hljs-number">17</span>. 手动ACK确认<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│ 最终一致性保证                                                        │<br>└─────────────────────────────────────────────────────────────────────┘<br><span class="hljs-operator">-</span> 数据库持久化（interaction-service）<br><span class="hljs-operator">-</span> Redis缓存更新（user-service <span class="hljs-operator">+</span> interaction-service）<br><span class="hljs-operator">-</span> 幂等性保证：同一消息多次消费结果一致（数据库幂等更新 <span class="hljs-operator">+</span> Redis Set操作幂等）<br></code></pre></td></tr></table></figure><p><strong>流程说明</strong>:</p><ol><li><strong>异步响应</strong>: 用户点赞后立即返回成功，不等待消费完成（降低响应时间）</li><li><strong>并行消费</strong>: user-service和interaction-service同时消费消息，互不阻塞</li><li><strong>最终一致性</strong>: 数据库持久化 + Redis缓存最终同步</li><li><strong>幂等性保证</strong>:<ul><li>数据库: 通过唯一索引 + UPDATE操作保证幂等</li><li>Redis Set: sadd&#x2F;srem操作天然幂等</li></ul></li></ol><h3 id="5-播放进度"><a href="#5-播放进度" class="headerlink" title="5. 播放进度"></a>5. 播放进度</h3><p>(1)  收到播放进度事件以后，每个用户哪个视频播放到哪里，在redis有维护进度列表（value是一个map类型）；先更新缓存，然后更新数据库</p><p>ScheduledExecutorService 是 Java 提供的更强大的延时任务实现方式。它可以创建一个线程池来执行延时任务，适用于大量异步任务的场景。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ScheduledExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledExecutorServiceExample</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>       executor.schedule(() -&gt; &#123;<br>           System.out.println(<span class="hljs-string">&quot;任务执行时间：&quot;</span> + System.currentTimeMillis());<br>       &#125;, <span class="hljs-number">60</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 延迟5秒执行</span><br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/./../img/image-20251123202106270.png" alt="image-20251123202106270"></p><p>其他各种事件</p><p><img src="/./../img/image-20251123202113537.png" alt="image-20251123202113537"></p><h3 id="6-所有的数据模型设计"><a href="#6-所有的数据模型设计" class="headerlink" title="6. 所有的数据模型设计"></a>6. 所有的数据模型设计</h3><p><img src="/./../img/image-20251123202120347.png" alt="image-20251123202120347"></p><h3 id="互动服务的最大难点在于："><a href="#互动服务的最大难点在于：" class="headerlink" title="互动服务的最大难点在于："></a><strong>互动服务的最大难点在于</strong>：</h3><ol><li><p>构建一套<strong>事件流的感知架构</strong>的系统。事件抵达以后，各种微服务收到消息，会修改对应的缓存和数据库<br>（缓存优先模式）</p></li><li><p>整个互动服务，所有数据的读写都是在缓存中进行。数据库反而现在需要同步缓存。我们并不去做数据库同步缓存的操作，而是构建稳定消息系统。<strong>消息抵达后，缓存和数据库是同时双写模式</strong>。实现的最终一致性效果。</p></li><li><p><strong>缓存中各种数据模型的设计</strong>。 设计一个合理的，易于修改的数据模型；（JSON不能乱用）</p></li></ol><h3 id="7-MySQL支持全文检索（轻量级，数据量小）"><a href="#7-MySQL支持全文检索（轻量级，数据量小）" class="headerlink" title="7. MySQL支持全文检索（轻量级，数据量小）"></a>7. MySQL支持全文检索（轻量级，数据量小）</h3><p>TEXT字段，建立  FULL_TEXT 索引； 玩具版</p><h1 id="4-每个点的技术细节"><a href="#4-每个点的技术细节" class="headerlink" title="4.每个点的技术细节"></a>4.每个点的技术细节</h1><h2 id="1-流程引擎用法"><a href="#1-流程引擎用法" class="headerlink" title="**1.**流程引擎用法"></a>**1.**<strong>流程引擎用法</strong></h2><p>Camunda主要两种用法。</p><p>1） Docker启动Camunda服务，Camunda提供REST API，我们应用和 Camunda 进行HTTP 交互</p><p>2） <strong>在****SpringBoot</strong> <strong>中整合</strong> <strong>Camunda</strong><strong>。</strong> <strong>能用<strong><strong>Camunda</strong></strong>提供的<strong><strong>SDK</strong></strong>一堆**<strong>API</strong></strong>；（我们用）**</p><p>a.     RepositoryService 主要做流程部署相关</p><p>b.     RuntimeService 主要做流程启动运行相关</p><p>c.      TaskService 主要做任务领取、完成相关</p><p>d.     HistoryService 主要做历史流程、历史变量相关</p><p>e.     xxxService</p><p><strong>核心：</strong></p><ol><li><p><strong>业务流程的设计和推进（网关【排他、包含、并行】）</strong></p></li><li><p><strong>业务推进期间共享一些数据，数据使用流程变量；</strong></p></li></ol><p>(1)  为什么用<strong>流程变量</strong>而不用redis共享数据呀？</p><p>①            主要因为用流程变量，即使流程结束还可以查询之前的历史，<strong>溯源</strong><br>②redis可能出现删除问题</p><ol start="3"><li>Camunda高阶： OA会签、子&#x2F;父流程、变换流转…</li></ol><p>重难点： API</p><h2 id="2-Xxl-job-用法"><a href="#2-Xxl-job-用法" class="headerlink" title="2. Xxl-job 用法"></a>2. Xxl-job 用法</h2><h2 id="3-Ai整合使用流程"><a href="#3-Ai整合使用流程" class="headerlink" title="3. Ai整合使用流程"></a>3. Ai整合使用流程</h2><p>AI大模型是用来做审核的。</p><p>提示词优化 + 模板化输出； 判定违禁词，方便给人工审核一个提示。</p><h2 id="4-信息流-画质流，转码流程"><a href="#4-信息流-画质流，转码流程" class="headerlink" title="4. 信息流&#x2F;画质流，转码流程"></a>4. 信息流&#x2F;画质流，转码流程</h2><h2 id="5-腾讯云VOD系统，"><a href="#5-腾讯云VOD系统，" class="headerlink" title="5. 腾讯云VOD系统，"></a>5. 腾讯云VOD系统，</h2><h2 id="6-高性能接口：-缓存、异步、排队"><a href="#6-高性能接口：-缓存、异步、排队" class="headerlink" title="6. 高性能接口： 缓存、异步、排队"></a>6. 高性能接口： 缓存、异步、排队</h2><p>1）、<strong>Redis</strong>（<strong>持久化</strong>、<strong>内存淘汰</strong>、<strong>基本数据类型</strong>）</p><p>2）、<strong>Redisson</strong>（<strong>分布式锁机制</strong>、看门狗(提交的一个异步延迟任务进行的续期)、 分布式锁原理【setnxex】）</p><p>3）、缓存整套流程、数据一致性如何保证</p><ol><li>缓存+数据库</li></ol><p>1)、失效模式&#x2F;增强版失效（延迟双删）</p><p>2)、双写模式</p><p>3)、互动服务中全消息的最终一致性</p><p>4）、异步</p><p>1）、CompletableFuture</p><p>2）、ThreadPoolExecutor； 线程池7大参数</p><h2 id="7-Kafka"><a href="#7-Kafka" class="headerlink" title="7. Kafka"></a>7. Kafka</h2><p>(1)  集群原理： topic、partition、ISR</p><p>(2)  <strong>消息可靠性</strong>：</p><p>①            发送者ack模式</p><ol><li><pre><code class="hljs">0：kafka收到消息给生产者回复ok</code></pre></li><li><pre><code class="hljs">1：kafka leader持久化后回复ok： 我们用这个</code></pre></li><li><pre><code class="hljs">-1：Kafka leader + isr 都持久化 回复 ok</code></pre></li></ol><p>②            消费者 手动ack</p><ol><li><pre><code class="hljs">收到消息，并执行成功，回复给kafka ok。提交偏移量</code></pre></li></ol><p>③            *<em>Kafka</em>***本身： 集群（topic多分区，每个分区的leader在不同机器，其他机器有备份）。Leader来接收所有消息的CRUD</p><p>(3)  消费模式：</p><p>①            点对点：同一个消费者组，一个消息只能给同组的一个人</p><p>②            发布&#x2F;订阅：不同消费者组，一个消息会广播给所有消息组</p><p>(4)  消息重复、消息顺序、消息丢失</p><p>①            消息重复：幂等性（消费者自己处理）</p><ol><li><pre><code class="hljs">典型情况：**重平衡（消费者数量发生变化）**；什么时候发生，发生后kafka怎么做</code></pre></li></ol><p>②            消息顺序：</p><ol><li><pre><code class="hljs">单发送者 + 主题单分区 + 单消费者单线程（必定有顺序）</code></pre></li><li><pre><code class="hljs">其他办法：分布式锁 + redis维护消息消费顺序</code></pre></li></ol><p>③            消息丢失：</p><ol><li><pre><code class="hljs">消息可靠性： 发送者Ack模式、（可靠回调）</code></pre></li><li><pre><code class="hljs">消费者手动ACK</code></pre></li></ol><p>(5)  Kafka的刷盘机制。</p><p>①            Kafka把消息写到页缓存就结束。不要修改刷盘策略（会影响吞吐量）</p><p>②            Kafka推荐利用ISR（多副本机制进行备份即可）</p><h2 id="8-最终一致性、Raft"><a href="#8-最终一致性、Raft" class="headerlink" title="8. 最终一致性、Raft"></a>8. 最终一致性、Raft</h2><h2 id="9-项目架构点-每个项目都长这样。"><a href="#9-项目架构点-每个项目都长这样。" class="headerlink" title="9. 项目架构点: 每个项目都长这样。"></a>9. 项目架构点: 每个项目都长这样。</h2><p>(1)  <strong>MySQL读写分离</strong>；shardingsphere</p><p>(2)  <strong>Redis</strong> <strong>主从同步</strong> 不加哨兵；（数据量没那么大）</p><p>①            要求客户端连接哨兵；</p><p>(3)  <strong>Kafka</strong> 3台机器，多节点集群。（副本数量最多为3）</p><p>(4)  Minio</p><p>(5)  Xxl-job</p><p>(6)  ShardingProxy</p><p>(7)  日志系统： ElasticSearch + Kibana + Filebeat(收集日志)</p><p>(8)  监控系统： Prometheus(时序数据库) + grafana<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;基本都长这样&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>自己按照简历模板：</strong></p><ol><li><strong>写一个自己简历里面的项目介绍；（不宜太多，重点亮眼）</strong></li></ol><p><strong>(1)  项目介绍</strong></p><p><strong>(2)  项目技术栈</strong></p><p><strong>(3)  个人职责</strong></p><p><strong>(4)  个人负责模块的技术特色</strong></p><ol start="2"><li>个人介绍 + 项目介绍： （1000字~1500字）</li></ol><p>(1)  控制口播稿 3-7分钟</p><p>(2)  提取点，就是面试官的拷打范围</p><p>背稿子，背面试场景题</p><ol><li><ol start="3"><li></li></ol></li></ol><h3 id="互动服务的最大难点在于：-1"><a href="#互动服务的最大难点在于：-1" class="headerlink" title="互动服务的最大难点在于："></a><strong>互动服务的最大难点在于</strong>：</h3><ol><li><p>构建一套<strong>事件流的感知架构</strong>的系统。事件抵达以后，各种微服务收到消息，会修改对应的缓存和数据库<br>（缓存优先模式）</p></li><li><p>整个互动服务，所有数据的读写都是在缓存中进行。数据库反而现在需要同步缓存。我们并不去做数据库同步缓存的操作，而是构建稳定消息系统。<strong>消息抵达后，缓存和数据库是同时双写模式</strong>。实现的最终一致性效果。</p></li><li><p><strong>缓存中各种数据模型的设计</strong>。 设计一个合理的，易于修改的数据模型；（JSON不能乱用）</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>kcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>41Java对象基础</title>
    <link href="/2025/11/22/41Java%E5%9F%BA%E7%A1%80%E5%AF%B9%E8%B1%A1/"/>
    <url>/2025/11/22/41Java%E5%9F%BA%E7%A1%80%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Java对象"><a href="#Java对象" class="headerlink" title="Java对象"></a>Java对象</h1><h3 id="Java创建对象除了new还有别的什么方式"><a href="#Java创建对象除了new还有别的什么方式" class="headerlink" title="Java创建对象除了new还有别的什么方式?"></a>Java创建对象除了new还有别的什么方式?</h3><ul><li><strong>通过反射创建对象</strong>：通过 Java 的反射机制可以在运行时动态地创建对象。可以使用 Class 类的 newInstance() 方法或者通过 Constructor 类来创建对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Constructor</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Class&lt;?&gt; clazz = MyClass.class;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> (MyClass) clazz.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>通过反序列化创建对象</strong>：通过将对象序列化（保存到文件或网络传输）然后再反序列化（从文件或网络传输中读取对象）的方式来创建对象，对象能被序列化和反序列化的前提是类实现Serializable接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">// Class definition</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// Serialize object</span><br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;object.ser&quot;</span>));<br>        out.writeObject(obj);<br>        out.close();<br>        <br>        <span class="hljs-comment">// Deserialize object</span><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;object.ser&quot;</span>));<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">newObj</span> <span class="hljs-operator">=</span> (MyClass) in.readObject();<br>        in.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>通过clone创建对象</strong>：所有 Java 对象都继承自 Object 类，Object 类中有一个 clone() 方法，可以用来创建对象的副本，要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> (MyClass) obj1.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何获取私有对象？"><a href="#如何获取私有对象？" class="headerlink" title="如何获取私有对象？"></a>如何获取私有对象？</h3><p>在 Java 中，私有对象通常指的是类中被声明为 <code>private</code> 的成员变量或方法。由于 <code>private</code> 访问修饰符的限制，这些成员只能在其所在的类内部被访问。</p><p>不过，可以通过下面两种方式来间接获取私有对象。</p><ul><li><p>使用公共访问器方法（getter 方法）：如果类的设计者遵循良好的编程规范，通常会为私有成员变量提供公共的访问器方法（即 <code>getter</code> 方法），通过调用这些方法可以安全地获取私有对象。</p></li><li><p>反射机制。反射机制允许在运行时检查和修改类、方法、字段等信息，通过反射可以绕过 <code>private</code> 访问修饰符的限制来获取私有对象。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">privateField</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;私有字段的值&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        <span class="hljs-comment">// 获取 Class 对象</span><br>        Class&lt;?&gt; clazz = obj.getClass();<br>        <span class="hljs-comment">// 获取私有字段</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">privateField</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;privateField&quot;</span>);<br>        <span class="hljs-comment">// 设置可访问性</span><br>        privateField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 获取私有字段的值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (String) privateField.get(obj);<br>        System.out.println(value); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="介绍一下Java异常"><a href="#介绍一下Java异常" class="headerlink" title="介绍一下Java异常"></a>介绍一下Java异常</h3><p>Java异常类层次结构图：<img src="/./../img/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp" alt="img">Java的异常体系主要基于两大类：Throwable类及其子类。Throwable有两个重要的子类：Error和Exception，它们分别代表了不同类型的异常情况。</p><ol><li><strong>Error（错误）</strong>：表示运行时环境的错误。错误是程序无法处理的严重问题，如系统崩溃、虚拟机错误、动态链接失败等。通常，程序不应该尝试捕获这类错误。例如，OutOfMemoryError、StackOverflowError等。</li><li><strong>Exception（异常）</strong>：表示程序本身可以处理的异常条件。异常分为两大类：<ul><li><strong>非运行时异常</strong>：这类异常在编译时期就必须被捕获或者声明抛出。它们通常是外部错误，如文件不存在（FileNotFoundException）、类未找到（ClassNotFoundException）等。非运行时异常强制程序员处理这些可能出现的问题，增强了程序的健壮性。</li><li><strong>运行时异常</strong>：这类异常包括运行时异常（RuntimeException）和错误（Error）。运行时异常由程序错误导致，如空指针访问（NullPointerException）、数组越界（ArrayIndexOutOfBoundsException）等。运行时异常是不需要在编译时强制捕获或声明的。</li><li>SecurityException我们直接获取[Unsafe]，调用其中属性方法时会出现异常：</li><li>ConcurrentModificationException-并发修改异常 –线程不安全集合案例</li><li>BeanCurrentlyInCreationException—循环依赖</li></ul></li></ol><h3 id="Java异常处理有哪些？"><a href="#Java异常处理有哪些？" class="headerlink" title="Java异常处理有哪些？"></a>Java异常处理有哪些？</h3><p>异常处理是通过使用try-catch语句块来捕获和处理异常。以下是Java中常用的异常处理方式：</p><ul><li>try-catch语句块：用于捕获并处理可能抛出的异常。try块中包含可能抛出异常的代码，catch块用于捕获并处理特定类型的异常。可以有多个catch块来处理不同类型的异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能抛出异常的代码</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType1 e1) &#123;<br>    <span class="hljs-comment">// 处理异常类型1的逻辑</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType2 e2) &#123;<br>    <span class="hljs-comment">// 处理异常类型2的逻辑</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType3 e3) &#123;<br>    <span class="hljs-comment">// 处理异常类型3的逻辑</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 可选的finally块，用于定义无论是否发生异常都会执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>throw语句：用于手动抛出异常。可以根据需要在代码中使用throw语句主动抛出特定类型的异常。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">throw new ExceptionType(&quot;Exception message&quot;);<br></code></pre></td></tr></table></figure><ul><li>throws关键字：用于在方法声明中声明可能抛出的异常类型。如果一个方法可能抛出异常，但不想在方法内部进行处理，可以使用throws关键字将异常传递给调用者来处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodName</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExceptionType &#123;<br>    <span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>finally块：用于定义无论是否发生异常都会执行的代码块。通常用于释放资源，确保资源的正确关闭。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能抛出异常的代码</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType e) &#123;<br>    <span class="hljs-comment">// 处理异常的逻辑</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 无论是否发生异常，都会执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="try-catch中的语句运行情况"><a href="#try-catch中的语句运行情况" class="headerlink" title="try catch中的语句运行情况"></a>try catch中的语句运行情况</h3><p>try块中的代码将按顺序执行，如果抛出异常，将在catch块中进行匹配和处理，然后程序将继续执行catch块之后的代码。如果没有匹配的catch块，异常将被传递给上一层调用的方法。</p><h3 id="try-return-“a”-finally-return-“b”-这条语句返回啥"><a href="#try-return-“a”-finally-return-“b”-这条语句返回啥" class="headerlink" title="try{return “a”} finally{return “b”}这条语句返回啥"></a>try{return “a”} finally{return “b”}这条语句返回啥</h3><p>finally块中的return语句会覆盖try块中的return返回，因此，该语句将返回”b”。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="能讲一讲Java注解的原理吗？"><a href="#能讲一讲Java注解的原理吗？" class="headerlink" title="能讲一讲Java注解的原理吗？"></a>能讲一讲Java注解的原理吗？</h3><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。</p><p>我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p><h3 id="对注解解析的底层实现了解吗？"><a href="#对注解解析的底层实现了解吗？" class="headerlink" title="对注解解析的底层实现了解吗？"></a>对注解解析的底层实现了解吗？</h3><p>注解本质上是一种特殊的接口，它继承自 <code>java.lang.annotation.Annotation</code> 接口，<strong>所以注解也叫声明式接口</strong>，例如，定义一个简单的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后，Java 编译器会将其转换为一个继承自 <code>Annotation</code> 的接口，并生成相应的字节码文件。</p><p>根据注解的作用范围，Java 注解可以分为以下几种类型：</p><ul><li><strong>源码级别注解</strong> ：仅存在于源码中，编译后不会保留（<code>@Retention(RetentionPolicy.SOURCE)</code>）。</li><li><strong>类文件级别注解</strong> ：保留在 <code>.class</code> 文件中，但运行时不可见（<code>@Retention(RetentionPolicy.CLASS)</code>）。</li><li><strong>运行时注解</strong> ：保留在 <code>.class</code> 文件中，并且可以通过反射在运行时访问（<code>@Retention(RetentionPolicy.RUNTIME)</code>）。</li></ul><h3 id="Java注解的作用域呢？"><a href="#Java注解的作用域呢？" class="headerlink" title="Java注解的作用域呢？"></a>Java注解的作用域呢？</h3><p>注解的作用域（Scope）指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。Java注解的作用域可以分为三种：</p><ol><li>类级别作用域：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，如类的访问级别、继承关系、注释等。</li><li>方法级别作用域：用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，如方法的访问级别、返回值类型、异常类型、注释等。</li><li>字段级别作用域：用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，如字段的访问级别、默认值、注释等。</li></ol><h1 id="java中的值传递和引用传递"><a href="#java中的值传递和引用传递" class="headerlink" title="java中的值传递和引用传递"></a>java中的值传递和引用传递</h1><p><img src="/./../img/image-20251124215833211.png" alt="image-20251124215833211"></p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><p>反射具有以下特性：</p><ol><li><strong>运行时类信息访问</strong>：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。</li><li><strong>动态对象创建</strong>：可以使用反射API动态地创建对象实例。</li><li><strong>动态方法调用</strong>：可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。</li><li><strong>访问和修改字段值</strong>：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。</li></ol><p><img src="/./../img/image-20251124220602549.png" alt="image-20251124220602549"></p><h2 id="Java-新特性"><a href="#Java-新特性" class="headerlink" title="Java 新特性"></a>Java 新特性</h2><h3 id="Java-8-你知道有什么新特性？"><a href="#Java-8-你知道有什么新特性？" class="headerlink" title="Java 8 你知道有什么新特性？"></a>Java 8 你知道有什么新特性？</h3><p>下面是 Java 8 主要新特性的整理表格，包含关键改进和示例说明：</p><table><thead><tr><th><strong>特性名称</strong></th><th><strong>描述</strong></th><th><strong>示例或说明</strong></th></tr></thead><tbody><tr><td><strong>Lambda 表达式</strong></td><td>简化匿名内部类，支持函数式编程</td><td><code>(a, b) -&gt; a + b</code> 代替匿名类实现接口</td></tr><tr><td><strong>函数式接口</strong></td><td>仅含一个抽象方法的接口，可用 <code>@FunctionalInterface</code> 注解标记</td><td><code>Runnable</code>, <code>Comparator</code>, 或自定义接口 <code>@FunctionalInterface interface MyFunc &#123; void run(); &#125;</code></td></tr><tr><td><strong>Stream API</strong></td><td>提供链式操作处理集合数据，支持并行处理</td><td><code>list.stream().filter(x -&gt; x &gt; 0).collect(Collectors.toList())</code></td></tr><tr><td><strong>Optional 类</strong></td><td>封装可能为 <code>null</code> 的对象，减少空指针异常</td><td><code>Optional.ofNullable(value).orElse(&quot;default&quot;)</code></td></tr><tr><td><strong>方法引用</strong></td><td>简化 Lambda 表达式，直接引用现有方法</td><td><code>System.out::println</code> 等价于 <code>x -&gt; System.out.println(x)</code></td></tr><tr><td><strong>接口的默认方法与静态方法</strong></td><td>接口可定义默认实现和静态方法，增强扩展性</td><td><code>interface A &#123; default void print() &#123; System.out.println(&quot;默认方法&quot;); &#125; &#125;</code></td></tr><tr><td><strong>并行数组排序</strong></td><td>使用多线程加速数组排序</td><td><code>Arrays.parallelSort(array)</code></td></tr><tr><td><strong>重复注解</strong></td><td>允许同一位置多次使用相同注解</td><td><code>@Repeatable</code> 注解配合容器注解使用</td></tr><tr><td><strong>类型注解</strong></td><td>注解可应用于更多位置（如泛型、异常等）</td><td><code>List&lt;@NonNull String&gt; list</code></td></tr><tr><td><strong>CompletableFuture</strong></td><td>增强异步编程能力，支持链式调用和组合操作</td><td><code>CompletableFuture.supplyAsync(() -&gt; &quot;result&quot;).thenAccept(System.out::println)</code></td></tr></tbody></table><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="构造器方法"><a href="#构造器方法" class="headerlink" title="构造器方法"></a>构造器方法</h3><ul><li>Optional.of(T t) : 创建一个 Optional 实例，t 必须非空</li><li>Optional.empty() : 创建一个空的 Optional 实例</li><li>Optional.ofNullable(T t)：t 可以为 null</li></ul><h3 id="获取类方法"><a href="#获取类方法" class="headerlink" title="获取类方法"></a>获取类方法</h3><ul><li>T get(): 如果调用对象包含值不为 null，返回该值，否则抛异常</li><li>T orElse(T other) ：如果有值则将其返回，否则返回指定的 other 对象</li><li>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果有值则将其返回，否则返回由 Supplier 接口实现提供的对象。</li><li>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果有值则将其返回，否则抛出由 Supplie</li></ul><h3 id="判断类方法"><a href="#判断类方法" class="headerlink" title="判断类方法"></a>判断类方法</h3><ul><li>boolean isPresent() : 判断是否包含对象</li><li>void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行 Consumer 接口的实现代码，并且该值会作为参数传给它。</li><li>void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction) :如果有值，就执行 Consumer 接口的实现代码，并且该值会作为参数传给它,否则执行 Runnable 接口的实现代码。</li></ul><h3 id="使用-Optional-的最佳实践"><a href="#使用-Optional-的最佳实践" class="headerlink" title="使用 Optional 的最佳实践"></a><strong>使用 Optional 的最佳实践</strong></h3><ol><li><strong>推荐在方法返回值中使用 <code>Optional</code></strong><ul><li>明确告诉调用方返回值可能不存在。</li><li>例如：<code>Optional&lt;User&gt; findById(Long id)</code>。</li></ul></li><li><strong>不要将 <code>Optional</code> 用于实体类的字段</strong><ul><li><code>Optional</code> 是一个容器类，不适合用于序列化和持久化场景。</li></ul></li><li><strong>避免直接使用 <code>get()</code></strong><ul><li>直接调用 <code>get()</code> 方法会引发异常，应该优先使用 <code>orElse()</code> 或 <code>ifPresent()</code> 等安全方法。</li></ul></li><li><strong>不要滥用 <code>Optional</code></strong><ul><li>对于简单的 <code>null</code> 检查，可能无需引入 <code>Optional</code>。使用它的场景应该是明确表示“值可能不存在”的语义。</li></ul></li></ol><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="怎么把一个对象从一个jvm转移到另一个jvm"><a href="#怎么把一个对象从一个jvm转移到另一个jvm" class="headerlink" title="#怎么把一个对象从一个jvm转移到另一个jvm?"></a><a href="https://xiaolincoding.com/interview/java.html#%E6%80%8E%E4%B9%88%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BB%8E%E4%B8%80%E4%B8%AAjvm%E8%BD%AC%E7%A7%BB%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AAjvm">#</a>怎么把一个对象从一个jvm转移到另一个jvm?</h3><ul><li><strong>使用序列化和反序列化</strong>：将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 ObjectOutputStream 和 ObjectInputStream 来实现。</li><li><strong>使用消息传递机制</strong>：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化。</li><li><strong>使用远程方法调用（RPC）</strong>：可以使用远程方法调用框架，如 gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法。</li><li><strong>使用共享数据库或缓存</strong>：将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景。</li></ul><h2 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="Java怎么实现网络IO高并发编程？"><a href="#Java怎么实现网络IO高并发编程？" class="headerlink" title="Java怎么实现网络IO高并发编程？"></a><strong>Java怎么实现网络IO高并发编程？</strong></h3><p>可以用 Java NIO ，是一种同步非阻塞的I&#x2F;O模型，也是I&#x2F;O多路复用的基础。</p><p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据， 如果使用BIO要想要并发处理多个客户端的i&#x2F;o，那么会使用多线程模式，一个线程专门处理一个客户端 io，这种模式随着客户端越来越多，所需要创建的线程也越来越多，会急剧消耗系统的性能。</p><p><img src="/./../img/image-20240820112641716.png" alt="image-20240820112641716"></p><p>NIO 是基于I&#x2F;O多路复用实现的，它可以只用一个线程处理多个客户端I&#x2F;O，如果你需要同时管理成千上万的连接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些。</p><p><img src="/./../img/image-20240820112656259.png" alt="image-20240820112656259"></p><h3 id="BIO、NIO、AIO区别是什么？"><a href="#BIO、NIO、AIO区别是什么？" class="headerlink" title="BIO、NIO、AIO区别是什么？"></a>BIO、NIO、AIO区别是什么？</h3><ul><li>BIO（blocking IO）：就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。优点是代码比较简单、直观；缺点是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li><li>NIO（non-blocking IO） ：Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li><li>AIO（Asynchronous IO） ：是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"><a href="#有一个学生类，想按照分数排序，再按学号排序，应该怎么做？" class="headerlink" title="#有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"></a><a href="https://xiaolincoding.com/interview/java.html#%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%A6%E7%94%9F%E7%B1%BB-%E6%83%B3%E6%8C%89%E7%85%A7%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F-%E5%86%8D%E6%8C%89%E5%AD%A6%E5%8F%B7%E6%8E%92%E5%BA%8F-%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A">#</a>有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</h3><p>可以使用Comparable接口来实现按照分数排序，再按照学号排序。首先在学生类中实现Comparable接口，并重写compareTo方法，然后在compareTo方法中实现按照分数排序和按照学号排序的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br><br>    <span class="hljs-comment">// 构造方法和其他属性、方法省略</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student other)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.score != other.score) &#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(other.score, <span class="hljs-built_in">this</span>.score); <span class="hljs-comment">// 按照分数降序排序</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(<span class="hljs-built_in">this</span>.id, other.id); <span class="hljs-comment">// 如果分数相同，则按照学号升序排序</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在需要对学生列表进行排序的地方，使用Collections.sort()方法对学生列表进行排序即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">List&lt;Student&gt; students = new ArrayList&lt;&gt;();<br>// 添加学生对象到列表中<br>Collections.sort(students);<br></code></pre></td></tr></table></figure><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>40Java、基础</title>
    <link href="/2025/11/21/40Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/11/21/40Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h3 id="说一下Java的特点"><a href="#说一下Java的特点" class="headerlink" title="说一下Java的特点"></a>说一下Java的特点</h3><p>主要有以下的特点：</p><ul><li><strong>平台无关性</strong>：Java的“编写一次，运行无处不在”哲学是其最大的特点之一。Java编译器将源代码编译成字节码（bytecode），该字节码可以在任何安装了Java虚拟机（JVM）的系统上运行。</li><li><strong>面向对象</strong>：Java是一门严格的面向对象编程语言，几乎一切都是对象。面向对象编程（OOP）特性使得代码更易于维护和重用，包括类（class）、对象（object）、继承（inheritance）、多态（polymorphism）、抽象（abstraction）和封装（encapsulation）。</li><li><strong>内存管理</strong>：Java有自己的垃圾回收机制，自动管理内存和回收不再使用的对象。这样，开发者不需要手动管理内存，从而减少内存泄漏和其他内存相关的问题</li></ul><p>劣势:</p><p>(1)性能: 虽然靠JVM优化了很多性能,但相比C++,Rust这种原生编译语言,还是有一些性能开销.</p><p>(2)启动时间长: 在微服务场景下, 启动可能不如Go快.</p><p>(3)语法繁杂: 样板代码多,在没有lambda表达式之前更麻烦,  有了之后相比Python还是不够简洁.</p><p>(4)内存消耗: JVM本身占内存,对资源有限的环境不太友好</p><p>（6)开发效率低: 相比于动态语言如Python, Java需要更多代码,编译过程也可能拖慢开发节奏.</p><h3 id="JVM、JDK、JRE三者关系？"><a href="#JVM、JDK、JRE三者关系？" class="headerlink" title="JVM、JDK、JRE三者关系？"></a>JVM、JDK、JRE三者关系？</h3><p>JVM是Java虚拟机，是Java程序运行的环境。</p><p>JDK是Java开发工具包，是开发Java程序所需的工具集合。它包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。</p><p>JRE是Java运行时环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。JRE不包含开发工具，</p><h3 id="为什么Java解释和编译都有？"><a href="#为什么Java解释和编译都有？" class="headerlink" title="为什么Java解释和编译都有？"></a>为什么Java解释和编译都有？</h3><p><strong>编译性</strong>：</p><ul><li>Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。</li></ul><p><strong>解释性：</strong></p><ul><li>JVM中一个方法调用计数器，当累计计数大于一定值的时候，就使用JIT进行编译生成机器码文件。否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。</li></ul><p>所以Java既是编译型也是解释性语言，默认采用的是解释器和编译器混合的模式。</p><h3 id="编译型语言和解释型语言的区别？"><a href="#编译型语言和解释型语言的区别？" class="headerlink" title="** 编译型语言和解释型语言的区别？**"></a>** 编译型语言和解释型语言的区别？**</h3><p>编译型语言和解释型语言的区别在于：</p><ul><li>编译型语言：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。</li><li>解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。</li></ul><h3 id="八种基本的数据类型"><a href="#八种基本的数据类型" class="headerlink" title="八种基本的数据类型"></a>八种基本的数据类型</h3><p>Java支持数据类型分为两类： 基本数据类型和引用数据类型。</p><p>基本数据类型共有8种，可以分为三类：</p><ul><li>数值型：整数类型（byte、short、int、long）和浮点类型（float（4字节）、double）</li><li>字符型：char（一般2字节）</li><li>布尔型：boolean</li></ul><h3 id="数据类型转换方式你知道哪些？"><a href="#数据类型转换方式你知道哪些？" class="headerlink" title="数据类型转换方式你知道哪些？"></a>数据类型转换方式你知道哪些？</h3><ul><li>自动类型转换（隐式转换）：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将<code>int</code>转换为<code>long</code>、将<code>float</code>转换为<code>double</code>等。</li><li>强制类型转换（显式转换）：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将<code>long</code>转换为<code>int</code>、将<code>double</code>转换为<code>int</code>等。语法为：目标类型 变量名 &#x3D; (目标类型) 源类型。</li><li>字符串转换：Java提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型<code>int</code>，可以使用<code>Integer.parseInt()</code>方法；将字符串转换为浮点型<code>double</code>，可以使用<code>Double.parseDouble()</code>方法等。</li><li>数值之间的转换：Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如<code>Character</code>类、<code>Integer</code>类等提供了相应的转换方法。</li></ul><h3 id="装箱和拆箱是什么？"><a href="#装箱和拆箱是什么？" class="headerlink" title="装箱和拆箱是什么？"></a>装箱和拆箱是什么？</h3><p>装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程。</p><p>自动装箱主要发生在两种情况，一种是赋值时，另一种是在方法调用的时候。</p><blockquote><p>赋值时</p></blockquote><p>这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。</p><blockquote><p>方法调用时</p></blockquote><p>当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。</p><h3 id="Integer相比int有什么优点？"><a href="#Integer相比int有什么优点？" class="headerlink" title="Integer相比int有什么优点？"></a>Integer相比int有什么优点？</h3><p>int是Java中的原始数据类型，而Integer是int的包装类。</p><p>Integer和 int 的区别：</p><ul><li>基本类型和引用类型：首先，int是一种基本数据类型，而Integer是一种引用类型。基本数据类型是Java中最基本的数据类型，它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。这意味着，使用int来存储一个整数时，不需要任何额外的内存分配，而使用Integer时，必须为对象分配内存。在性能方面，基本数据类型的操作通常比相应的引用类型快。</li><li>包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本类型数据，变量对应的内存块直接存储数据本身。</li><li>自动装箱和拆箱：其次，Integer作为int的包装类，它可以实现自动装箱和拆箱。</li><li>空指针异常：另外，int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。</li></ul><p>不管是读写效率，还是存储效率，基本类型都比包装类高效。</p><h3 id="说一下-integer的缓存"><a href="#说一下-integer的缓存" class="headerlink" title="说一下 integer的缓存"></a>说一下 integer的缓存</h3><p>Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。</p><p>默认情况下，这个范围是-128至127。当通过Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><p>(1)语法形式:</p><p>成员变量 -&gt; 属于类,可以被public,static,private等修饰符所修饰</p><p>局部变量  -&gt; 在代码块或方法中定义的变量或者方法的参数,不能被访问控制修饰符以及static修饰</p><p>局部变量和成员变量都能被final所修饰</p><p>(2)存储方式:</p><p>局部变量 -&gt; 栈内存</p><p>成员变量 -&gt; 若被static修饰,则该变量是类变量,存储于元空间或永久代中,若没有用static修饰,则存储于堆内存中的,与前者用对象头关联.</p><p>(3)生命周期:</p><p>局部变量 -&gt; 随方法的调用而产生,随方法调用结束而消亡</p><p>成员变量-&gt; 随对象创建而存在,随对象被回收而消亡</p><p>(4)默认值:</p><p>局部变量 -&gt; 不会自动赋值,因此需要在使用前手动赋值</p><p>成员变量 -&gt; 没有final修饰时,会自动以类型的默认值来赋值.有final修饰时,必须显式赋值.</p><p>为什么成员变量有默认值?</p><p>成员变量存储在堆内存中,这些内存区域在分配前可能被其它数据占用过,若没有默认值机制,新创建的成员变量会直接复用这些残留的随机数据.</p><p>成员变量在运行时可以借助反射等方法赋值,但局部变量不行</p><h2 id="静态变量有什么用"><a href="#静态变量有什么用" class="headerlink" title="静态变量有什么用"></a>静态变量有什么用</h2><p>(1)什么是静态变量:</p><p>静态变量是被static关键字修饰的变量,可以被类的所有实例共享,无论一个类创建了多少个对象,它们都共享一份静态变量.</p><p>(2)静态变量如何访问:</p><p>通常是通过类名访问,也可以通过对象名访问(不推荐)</p><p>(3)静态变量一般会被final修饰成常量,这样做的好处</p><p>可见性保证</p><pre><code class="hljs">用final修饰后会加上写屏障,执行完写操作后将工作内存同步到主存,进而保证可见性.</code></pre><p>防止误修改</p><p>  用final修饰的静态变量,可以确保这些变量的值在初始化后不会被修改.</p><p>性能优化</p><p>  static final修饰的成员变量在类加载的准备阶段赋值(确定)</p><p>静态变量的成员变量的访问不需要创建实例对象</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p><img src="/./../img/image-20251124135141773.png" alt="image-20251124135141773"></p><p><img src="/./../img/image-20251124203200249.png" alt="image-20251124203200249"></p><h3 id="面向对象的设计原则你知道有哪些吗"><a href="#面向对象的设计原则你知道有哪些吗" class="headerlink" title="面向对象的设计原则你知道有哪些吗"></a>面向对象的设计原则你知道有哪些吗</h3><p>面向对象编程中的六大原则：</p><ul><li><strong>单一职责原则（SRP）</strong>：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。</li><li><strong>开放封闭原则（OCP）</strong>：软件实体应该对扩展开放，对修改封闭。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。</li><li><strong>里氏替换原则（LSP）</strong>：子类对象应该能够替换掉所有父类对象。例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。</li><li><strong>接口隔离原则（ISP）</strong>：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。</li><li><strong>依赖倒置原则（DIP）</strong>：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例子：如果一个公司类包含部门类，应该考虑使用合成&#x2F;聚合关系，而不是将公司类继承自部门类。</li><li><strong>最少知识原则 (Law of Demeter)</strong>：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互</li></ul><h3 id="重载与重写有什么区别？"><a href="#重载与重写有什么区别？" class="headerlink" title="重载与重写有什么区别？"></a>重载与重写有什么区别？</h3><p>重载是指在同一个类中定义多个同名方法，而重写是指子类重新定义父类中的方法。</p><h3 id="抽象类和普通类区别？"><a href="#抽象类和普通类区别？" class="headerlink" title="抽象类和普通类区别？"></a>抽象类和普通类区别？</h3><ul><li>实例化：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。</li><li>方法实现：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现。</li><li>继承：一个类可以继承一个普通类，而且可以继承多个接口；而一个类只能继承一个抽象类，但可以同时实现多个接口。</li><li>实现限制：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用。</li></ul><h3 id="Java抽象类和接口的区别是什么？"><a href="#Java抽象类和接口的区别是什么？" class="headerlink" title="Java抽象类和接口的区别是什么？"></a>Java抽象类和接口的区别是什么？</h3><p><strong>两者的特点：</strong></p><ul><li>抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。</li><li>接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。适用于定义类的能力或功能。</li></ul><p><strong>两者的区别：</strong></p><ul><li>实现方式：实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li><li>方法方式：接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</li><li>访问修饰符：接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</li><li>变量：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态常量）。</li></ul><h3 id="抽象类能加final修饰吗？"><a href="#抽象类能加final修饰吗？" class="headerlink" title="抽象类能加final修饰吗？"></a>抽象类能加final修饰吗？</h3><p><strong>不能</strong>，Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。</p><h3 id="接口里面可以定义哪些方法？"><a href="#接口里面可以定义哪些方法？" class="headerlink" title="接口里面可以定义哪些方法？"></a>接口里面可以定义哪些方法？</h3><ul><li><strong>抽象方法</strong></li></ul><p>抽象方法是接口的核心部分，所有实现接口的类都必须实现这些方法。抽象方法默认是 public 和 abstract，这些修饰符可以省略。</p><ul><li><strong>默认方法</strong></li></ul><p>默认方法是在 Java 8 中引入的，允许接口提供具体实现。实现类可以选择重写默认方法。</p><ul><li><strong>静态方法</strong></li></ul><p>静态方法也是在 Java 8 中引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象。</p><ul><li><strong>私有方法</strong></li></ul><p>私有方法是在 Java 9 中引入的，用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用。</p><h3 id="解释Java中的静态变量和静态方法"><a href="#解释Java中的静态变量和静态方法" class="headerlink" title="解释Java中的静态变量和静态方法"></a>解释Java中的静态变量和静态方法</h3><p>在Java中，静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联。它们在内存中只存在一份，可以被类的所有实例共享。</p><blockquote><p>静态变量</p></blockquote><p>静态变量（也称为类变量）是在类中使用<code>static</code>关键字声明的变量。它们属于类而不是任何具体的对象。主要的特点：</p><ul><li><strong>共享性</strong>：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。</li><li><strong>初始化</strong>：静态变量在类被加载时初始化，只会对其进行一次分配内存。</li><li><strong>访问方式</strong>：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 静态变量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">()</span> &#123;<br>        staticVar++; <span class="hljs-comment">// 每创建一个对象，静态变量自增</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStaticVar</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Static Var: &quot;</span> + staticVar);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-type">MyClass</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br><span class="hljs-type">MyClass</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>MyClass.printStaticVar(); <span class="hljs-comment">// 输出 Static Var: 2</span><br></code></pre></td></tr></table></figure><blockquote><p>静态方法</p></blockquote><p>静态方法是在类中使用<code>static</code>关键字声明的方法。类似于静态变量，静态方法也属于类，而不是任何具体的对象。主要的特点：</p><ul><li><strong>无实例依赖</strong>：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例。</li><li><strong>访问静态成员</strong>：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。</li><li><strong>多态性</strong>：静态方法不支持重写（Override），但可以被隐藏（Hide）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrementCount</span><span class="hljs-params">()</span> &#123;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayCount</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Count: &quot;</span> + count);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>MyClass.incrementCount(); <span class="hljs-comment">// 调用静态方法</span><br>MyClass.displayCount();   <span class="hljs-comment">// 输出 Count: 1</span><br></code></pre></td></tr></table></figure><blockquote><p>使用场景</p></blockquote><ul><li><strong>静态变量</strong>：常用于需要在所有对象间共享的数据，如计数器、常量等。</li><li><strong>静态方法</strong>：常用于助手方法（utility methods）、获取类级别的信息或者是没有依赖于实例的数据处理。</li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="Java-中-final-作用是什么？"><a href="#Java-中-final-作用是什么？" class="headerlink" title="#Java 中 final 作用是什么？"></a><a href="https://xiaolincoding.com/interview/java.html#java-%E4%B8%AD-final-%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">#</a>Java 中 final 作用是什么？</h3><p><code>final</code>关键字主要有以下三个方面的作用：用于修饰类、方法和变量。</p><ul><li>修饰类：当<code>final</code>修饰一个类时，表示这个类不能被继承，是类继承体系中的最终形态。例如，Java 中的<code>String</code>类就是用<code>final</code>修饰的，这保证了<code>String</code>类的不可变性和安全性，防止其他类通过继承来改变<code>String</code>类的行为和特性。</li><li>修饰方法：用<code>final</code>修饰的方法不能在子类中被重写。比如，<code>java.lang.Object</code>类中的<code>getClass</code>方法就是<code>final</code>的，因为这个方法的行为是由 Java 虚拟机底层实现来保证的，不应该被子类修改。</li><li>修饰变量：当<code>final</code>修饰基本数据类型的变量时，该变量一旦被赋值就不能再改变。例如，<code>final int num = 10;</code>，这里的<code>num</code>就是一个常量，不能再对其进行重新赋值操作，否则会导致编译错误。</li></ul><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><h3 id="深拷贝和浅拷贝的区别？"><a href="#深拷贝和浅拷贝的区别？" class="headerlink" title="#深拷贝和浅拷贝的区别？"></a><a href="https://xiaolincoding.com/interview/java.html#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB">#</a>深拷贝和浅拷贝的区别？</h3><p><img src="/./../img/1720683675376-c5af6668-4538-479f-84e8-42d4143ab101.webp" alt="img"></p><ul><li>浅拷贝是指只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说，浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。</li><li>深拷贝是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。</li></ul><h3 id="实现深拷贝的三种方法是什么？"><a href="#实现深拷贝的三种方法是什么？" class="headerlink" title="#实现深拷贝的三种方法是什么？"></a><a href="https://xiaolincoding.com/interview/java.html#%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88">#</a>实现深拷贝的三种方法是什么？</h3><p>在 Java 中，实现对象深拷贝的方法有以下几种主要方式：</p><blockquote><p>实现 Cloneable 接口并重写 clone() 方法</p></blockquote><p>这种方法要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。</p><blockquote><p>使用序列化和反序列化</p></blockquote><p>通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。</p><blockquote><p>手动递归复制</p></blockquote><p>针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h3 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="#什么是泛型？"></a><a href="https://xiaolincoding.com/interview/java.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B">#</a>什么是泛型？</h3><p>泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。</p><p>泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常。</p><blockquote><p>为什么需要泛型？</p></blockquote><ul><li><strong>适用于多种数据类型执行相同的代码</strong></li></ul><p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T a, T b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));<br>    <span class="hljs-keyword">return</span> a.doubleValue() + b.doubleValue();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>泛型中的类型在使用时指定，不需要强制类型转换</strong>（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs csharp">import java.util.concurrent.locks.Condition;<br>import java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dogger</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> remaining = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> turn = <span class="hljs-number">0</span>; <span class="hljs-comment">// 0=旺财,1=二哈,2=柯基</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final Condition[] conditions = <span class="hljs-keyword">new</span> Condition[<span class="hljs-number">3</span>];<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            conditions[i] = <span class="hljs-keyword">lock</span>.newCondition();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>) throws InterruptedException</span> &#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; eat(<span class="hljs-string">&quot;旺财&quot;</span>, <span class="hljs-number">0</span>));<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; eat(<span class="hljs-string">&quot;二哈&quot;</span>, <span class="hljs-number">1</span>));<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; eat(<span class="hljs-string">&quot;柯基&quot;</span>, <span class="hljs-number">2</span>));<br><br>        t1.start(); t2.start(); t3.start();<br>        t1.<span class="hljs-keyword">join</span>(); t2.<span class="hljs-keyword">join</span>(); t3.<span class="hljs-keyword">join</span>();<br><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;香肠分完啦！三条小狗开心地摇尾巴~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>(<span class="hljs-params">String name, <span class="hljs-built_in">int</span> id</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> eaten = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (remaining &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// ✅ 关键1：等待自己的轮次，同时检查香肠是否还有</span><br>                <span class="hljs-keyword">while</span> (turn != id &amp;&amp; remaining &gt; <span class="hljs-number">0</span>) &#123;<br>                    conditions[id].<span class="hljs-keyword">await</span>();<br>                &#125;<br><br>                <span class="hljs-comment">// ✅ 关键2：香肠可能已被吃光（被唤醒后必须二次检查）</span><br>                <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-comment">// ✅ 关键3：吃香肠</span><br>                remaining--;<br>                eaten++;<br>                System.<span class="hljs-keyword">out</span>.printf(<span class="hljs-string">&quot;%s叼走1根香肠，现在还剩%d根%n&quot;</span>, name, remaining);<br><br>                <span class="hljs-comment">// ✅ 关键4：香肠分完时必须更新turn并唤醒所有！</span><br>                <span class="hljs-keyword">if</span> (remaining == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 更新turn到无效值（-1），表示游戏结束</span><br>                    turn = <span class="hljs-number">-1</span>;<br>                    <span class="hljs-keyword">for</span> (Condition c : conditions) c.signalAll();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 正常轮转</span><br>                    turn = (turn + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>;<br>                    conditions[turn].signal();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.printf(<span class="hljs-string">&quot;%s一共吃了%d根，舔舔嘴巴说：香肠真香！%n&quot;</span>, name, eaten);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>33redis场景题</title>
    <link href="/2025/11/20/33redis%E5%9C%BA%E6%99%AF%E9%A2%98%E7%9B%AE/"/>
    <url>/2025/11/20/33redis%E5%9C%BA%E6%99%AF%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="redis应用场景是什么？"><a href="#redis应用场景是什么？" class="headerlink" title="redis应用场景是什么？"></a>redis应用场景是什么？</h1><p>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>，常用于<strong>缓存，消息队列、分布式锁等场景</strong>。</p><ul><li><strong>缓存</strong>: Redis最常见的用途就是作为缓存系统。通过将热门数据存储在内存中，可以极大地提高访问速度，减轻数据库负载，这对于需要快速响应时间的应用程序非常重要。</li><li><strong>排行榜</strong>: Redis的有序集合结构非常适合用于实现排行榜和排名系统，可以方便地进行数据排序和排名。</li><li><strong>分布式锁</strong>: Redis的特性可以用来实现分布式锁，确保多个进程或服务之间的数据操作的原子性和一致性。</li><li><strong>计数器</strong> 由于Redis的原子操作和高性能，它非常适合用于实现计数器和统计数据的存储，如网站访问量统计、点赞数统计等。</li><li><strong>消息队列</strong>: Redis的发布订阅功能使其成为一个轻量级的消息队列，它可以用来实现发布和订阅模式，以便实时处理消息。</li></ul><table><thead><tr><th>误区</th><th>正确理解</th><th>为什么</th></tr></thead><tbody><tr><td>“Redis 是多线程”</td><td>❌ <strong>错误！</strong> 命令执行是单线程</td><td>Redis 官方文档明确： ‘Redis 是单线程的’</td></tr><tr><td>“多线程 I&#x2F;O 会乱序”</td><td>❌ <strong>错误！</strong> 顺序执行</td><td>I&#x2F;O 线程只处理 I&#x2F;O，命令执行仍在主线程</td></tr><tr><td>“单线程无法高并发”</td><td>❌ <strong>错误！</strong> 实测 10 万 QPS</td><td>事件循环 + 非阻塞 I&#x2F;O 使单线程高效</td></tr><tr><td>“Redis 6.0 用了多线程命令”</td><td>❌ <strong>错误！</strong> 仅 I&#x2F;O 多线程</td><td>命令执行仍是单线程（<code>redis-cli</code> 测试可验证）</td></tr></tbody></table><h1 id="Redis的大Key问题是什么？"><a href="#Redis的大Key问题是什么？" class="headerlink" title="Redis的大Key问题是什么？"></a>Redis的大Key问题是什么？</h1><p>Redis大key问题指的是某个key对应的value值所占的内存空间比较大（数据量过多），导致Redis的性能下降、内存不足、数据不均衡以及主从同步延迟等问题。</p><p>到底多大的数据量才算是大key？</p><p>没有固定的判别标准，通常认为字符串类型的key对应的value值占用空间大于1M，或者集合类型的k元素数量超过1万个，就算是大key。</p><p>Redis大key问题的定义及评判准则并非一成不变，而应根据Redis的实际运用以及业务需求来综合评估。</p><p>例如，在高并发且低延迟的场景中，仅10kb可能就已构成大key；然而在低并发、高容量的环境下，大key的界限可能在100kb。因此，在设计与运用Redis时，要依据业务需求与性能指标来确立合理的大key阈值。</p><h3 id="大Key问题的缺点？"><a href="#大Key问题的缺点？" class="headerlink" title="大Key问题的缺点？"></a>大Key问题的缺点？</h3><ul><li>内存占用过高。大Key占用过多的内存空间，可能导致可用内存不足，从而触发内存淘汰策略。在极端情况下，可能导致内存耗尽，Redis实例崩溃，影响系统的稳定性。</li><li>性能下降。大Key会占用大量内存空间，导致内存碎片增加，进而影响Redis的性能。对于大Key的操作，如读取、写入、删除等，都会消耗更多的CPU时间和内存资源，进一步降低系统性能。</li><li>阻塞其他操作。某些对大Key的操作可能会导致Redis实例阻塞。例如，使用DEL命令删除一个大Key时，可能会导致Redis实例在一段时间内无法响应其他客户端请求，从而影响系统的响应时间和吞吐量。</li><li>网络拥塞。每次获取大key产生的网络流量较大，可能造成机器或局域网的带宽被打满，同时波及其他服务。例如：一个大key占用空间是1MB，每秒访问1000次，就有1000MB的流量。</li><li>主从同步延迟。当Redis实例配置了主从同步时，大Key可能导致主从同步延迟。由于大Key占用较多内存，同步过程中需要传输大量数据，这会导致主从之间的网络传输延迟增加，进而影响数据一致性。</li><li>数据倾斜。在Redis集群模式中，某个数据分片的内存使用率远超其他数据分片，无法使数据分片的内存资源达到均衡。</li></ul><h4 id="如何发现-bigkey？"><a href="#如何发现-bigkey？" class="headerlink" title="[如何发现 bigkey？]"></a>[如何发现 bigkey？]</h4><p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p><p><strong>2、使用 Redis 自带的 SCAN 命令</strong></p><p><strong>3、借助开源工具分析 RDB 文件。</strong></p><h3 id="Redis大key如何解决？"><a href="#Redis大key如何解决？" class="headerlink" title="Redis大key如何解决？"></a>Redis大key如何解决？</h3><ul><li>对大Key进行拆分。例如将含有数万成员的一个HASH Key拆分为多个HASH Key，并确保每个Key的成员数量在合理范围。</li><li>对大Key进行清理。将不适用Redis能力的数据存至其它存储，并在Redis中删除此类数据。注意，要使用异步删除。</li><li>监控Redis的内存水位。可以通过监控系统设置合理的Redis内存报警阈值进行提醒，</li><li>对过期数据进行定期清。堆积大量过期数据会造成大Key的产生，例如在HASH数据类型中以增量的形式不断写入大量数据而忽略了数据的时效性。可以通过定时任务的方式对失效数据进行清理。</li></ul><h3 id="什么是热key？"><a href="#什么是热key？" class="headerlink" title="什么是热key？"></a>什么是热key？</h3><p>通常以其接收到的Key被请求频率来判定，例如：</p><ul><li>QPS集中在特定的Key：Redis实例的总QPS（每秒查询率）为10,000，而其中一个Key的每秒访问量达到了7,000。</li><li>带宽使用率集中在特定的Key：对一个拥有上千个成员且总大小为1 MB的HASH Key每秒发送大量的<strong>HGETALL</strong>操作请求。</li><li>CPU使用时间占比集中在特定的Key：对一个拥有数万个成员的Key（ZSET类型）每秒发送大量的<strong>ZRANGE</strong>操作请求。</li></ul><h3 id="如何解决热key问题？"><a href="#如何解决热key问题？" class="headerlink" title="如何解决热key问题？"></a>如何解决热key问题？</h3><ul><li>在Redis集群架构中对热Key进行复制。在Redis集群架构中，由于热Key的迁移粒度问题，无法将请求分散至其他数据分片，导致单个数据分片的压力无法下降。此时，可以将对应热Key进行复制并迁移至其他数据分片，例如将热Key foo复制出3个内容完全一样的Key并名为foo2、foo3、foo4，将这三个Key迁移到其他数据分片来解决单个数据分片的热Key压力。</li><li>使用读写分离架构。如果热Key的产生来自于读请求，您可以将实例改造成读写分离架构来降低每个数据分片的读请求压力，甚至可以不断地增加从节点。但是读写分离架构在增加业务代码复杂度的同时，也会增加Redis集群架构复杂度。不仅要为多个从节点提供转发层（如Proxy，LVS等）来实现负载均衡，还要考虑从节点数量显著增加后带来故障率增加的问题。Redis集群架构变更会为监控、运维、故障处理带来了更大的挑战。</li></ul><h1 id="如何设计一个缓存策略，可以动态缓存热点数据呢？"><a href="#如何设计一个缓存策略，可以动态缓存热点数据呢？" class="headerlink" title="如何设计一个缓存策略，可以动态缓存热点数据呢？"></a>如何设计一个缓存策略，可以动态缓存热点数据呢？</h1><p>由于数据存储受限，系统并不是将所有数据都需要存放到缓存中的，而<strong>只是将其中一部分热点数据缓存起来</strong>，所以我们要设计一个热点数据动态缓存的策略。</p><p>热点数据动态缓存的策略总体思路：<strong>通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据</strong>。</p><p>以电商平台场景中的例子，现在要求只缓存用户经常访问的 Top 1000 的商品。具体细节如下：</p><ul><li>先通过缓存系统做一个排序队列（比如存放 1000 个商品），系统会根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前；</li><li>同时系统会定期过滤掉队列中排名最后的 200 个商品，然后再从数据库中随机读取出 200 个商品加入队列中；</li><li>这样当请求每次到达的时候，会先从队列中获取商品 ID，如果命中，就根据 ID 再从另一个缓存数据结构中读取实际的商品信息，并返回。</li></ul><p>在 Redis 中可以用 zadd 方法和 zrange 方法来完成排序队列和获取 200 个商品的操作。</p><h3 id="如何保证-redis-和-mysql-数据缓存一致性问题？"><a href="#如何保证-redis-和-mysql-数据缓存一致性问题？" class="headerlink" title="如何保证 redis 和 mysql 数据缓存一致性问题？"></a>如何保证 redis 和 mysql 数据缓存一致性问题？</h3><p>对于读数据，我会选择旁路缓存策略，如果 cache 不命中，会从 db 加载数据到 cache。对于写数据，我会选择更新 db 后，再删除缓存。</p><h1 id="布隆过滤器原理介绍一下"><a href="#布隆过滤器原理介绍一下" class="headerlink" title="布隆过滤器原理介绍一下"></a>布隆过滤器原理介绍一下</h1><p>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p><p>布隆过滤器会通过 3 个操作完成标记：</p><ul><li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li><li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li><li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li></ul><p>举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。</p><p><img src="/./../img/1719903580960-2490c9c0-616b-4b11-a290-4891c2d7511a.png" alt="img"></p><p><strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p><p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p><p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。</p><p>(2)优缺点空间小且查询高效:相比于传统的数据结构,布隆过滤器在存储大量元素时,占用的空间小得多,且查询极快(O(k))</p><p>k为哈希函数的个数存在误判:底层是哈希函数,由于不同元素也有一定概率哈希映射到相同位置,因此会存在误判</p><p>无法删除元素:因为布隆过滤器的位数组中某个位置被置为1,很难判断这个1是由哪个或哪些元素的哈希映射导致的,所以在经典的布隆过滤器中,是不支持删除元素操作的.</p><p>(3)扩容与误判率降低布隆过滤器误判率,需要哈希函数个数与位数组长度协同调整</p><p>单增哈希函数,空间剩余值超过阈值误判率会反弹.</p><p>单扩容数组,虽能降误判,但空间利用率大幅下降,内存浪费严重</p><p>唯有k≈ln2*(m&#x2F;n)才能在控制误判和维持空间效率实现平衡</p><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>在 <code>redis.conf</code> 文件中，我们可以使用 <code>slowlog-log-slower-than</code> 参数设置耗时命令的阈值，并使用 <code>slowlog-max-len</code> 参数设置耗时命令的最大记录条数。</p><p>获取慢查询日志的内容很简单，直接使用 <code>SLOWLOG GET</code> 命令即可。</p><p>慢查询日志中的每个条目都由以下六个值组成：</p><ol><li><strong>唯一 ID</strong>: 日志条目的唯一标识符。</li><li><strong>时间戳 (Timestamp)</strong>: 命令执行完成时的 Unix 时间戳。</li><li><strong>耗时 (Duration)</strong>: 命令执行所花费的时间，单位是<strong>微秒</strong>。</li><li><strong>命令及参数 (Command)</strong>: 执行的具体命令及其参数数组。</li><li><strong>客户端信息 (Client IP:Port)</strong>: 执行命令的客户端地址和端口。</li><li><strong>客户端名称 (Client Name)</strong>: 如果客户端设置了名称 (CLIENT SETNAME)。</li></ol><h1 id="对Redis中的缓存雪崩-缓存击穿-缓存穿透有了解吗-怎么解决"><a href="#对Redis中的缓存雪崩-缓存击穿-缓存穿透有了解吗-怎么解决" class="headerlink" title="对Redis中的缓存雪崩,缓存击穿,缓存穿透有了解吗,怎么解决"></a><strong>对Redis中的缓存雪崩,缓存击穿,缓存穿透有了解吗,怎么解决</strong></h1><p><img src="/./../img/image-20251120233155787.png" alt="image-20251120233155787"></p><h2 id="缓存穿透和缓存击穿有什么区别？"><a href="#缓存穿透和缓存击穿有什么区别？" class="headerlink" title="[缓存穿透和缓存击穿有什么区别？]"></a>[缓存穿透和缓存击穿有什么区别？]</h2><p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p><h1 id="redis的lua脚本"><a href="#redis的lua脚本" class="headerlink" title="redis的lua脚本"></a>redis的lua脚本</h1><p>Redis对Lua脚本的处理由命令执行器与Lua解释器协同完成</p><p>1)Lua解释器:Redis内置,由Lua解释器进行语法校验,通过调用redis.call()接口将Lua函数调用映射为Redis内部命令 </p><p>2)命令执行器:处理原生Redis命令</p><p>3)一个Lua脚本可视为命令执行器的原子执行单元</p><p>(1)脚本加载与语法解析Redis将Lua脚本交给Lua解释器Lua解释器先做适语法校验,确保脚本无语法错误</p><p>(2)命令映射与执行(协同)Lua解释器逐行执行脚本,当执行到redis.call()时Lua解释器暂停脚本执行,将Lua函数映射为Redis命令转发给Redis命令执行器,并将结果返回给Lua解释器Lua解释器恢复执行,用返回值进行&#x3D;&#x3D;判断(</p><p>3)原子性保障Redis执行Lua脚本时,会进入单线程原子模式无论脚本包含多少redis.call调用多少次命令执行器,Redis会阻塞所有其它客户端命令, 直到脚本完全执行完毕,保证了原子性</p><p>缺陷：</p><ul><li>如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。</li><li>Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 <strong>hash slot（哈希槽）</strong> 上。</li></ul><h1 id="redis阻塞"><a href="#redis阻塞" class="headerlink" title="redis阻塞"></a>redis阻塞</h1><p>1.默认情况下，Redis 默认配置会使用 <code>bgsave</code> 命令。如果手动使用 <code>save</code> 命令生成 RDB 快照文件的话，就会阻塞主线程。</p><ol start="2"><li></li></ol><ul><li><code>ZRANGE</code>&#x2F;<code>ZREVRANGE</code>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li><li><code>ZREMRANGEBYRANK</code>&#x2F;<code>ZREMRANGEBYSCORE</code>：移除 Sorted Set 中指定排名范围&#x2F;指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li></ul><p>3.aof<strong>为什么是在执行完命令之后记录日志呢？</strong></p><ul><li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>在命令执行完之后再记录，不会阻塞当前的命令执行\</li></ul><p>当后台线程（ <code>aof_fsync</code> 线程）调用 <code>fsync</code> 函数同步 AOF 文件时，需要等待，直到写入完成。当磁盘压力太大的时候，会导致 <code>fsync</code> 操作发生阻塞，主线程调用 <code>write</code> 函数时也会被阻塞。<code>fsync</code> 完成后，主线程执行 <code>write</code> 才能成功返回。</p><p>4.阻塞就是出现在</p><p>当子线程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。</p><p>的过程中，将缓冲区中新数据写到新文件的过程中会产生<strong>阻塞</strong>。</p><p>5.删除操作的本质是要释放键值对占用的内存空间。</p><p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，<strong>操作系统需要把释放掉的内存块插入一个空闲内存块的链表</strong>，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会<strong>阻塞</strong>当前释放内存的应用程序。</p><p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p><p>删除大 key 时建议采用分批次删除和异步删除的方式进行</p><p>6.Redis 集群可以进行节点的动态扩容缩容，这一过程目前还处于半自动状态，需要人工介入。</p><p>在扩缩容的时候，需要进行数据迁移。而 Redis 为了保证迁移的一致性，迁移所有操作都是同步操作。</p><p>执行迁移时，两端的 Redis 均会进入时长不等的阻塞状态，对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会触发集群内的故障转移，造成不必要的切换。</p><p>7.清空数据库和上面 bigkey 删除也是同样道理，<code>flushdb</code>、<code>flushall</code> 也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点</p><p>8.连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。</p><p>9。CPU竞争等硬件问题</p><h1 id="ZSCAN"><a href="#ZSCAN" class="headerlink" title="ZSCAN"></a>ZSCAN</h1><h2 id="Cursor分页-vs-ZRANGE：5大核心优势"><a href="#Cursor分页-vs-ZRANGE：5大核心优势" class="headerlink" title="Cursor分页 vs ZRANGE：5大核心优势"></a>Cursor分页 vs ZRANGE：5大核心优势</h2><table><thead><tr><th>维度</th><th>ZRANGE（深分页）</th><th>ZSCAN（Cursor）</th><th>为什么Cursor更优</th></tr></thead><tbody><tr><td><strong>1. 性能</strong></td><td>offset&#x3D;100万时，需扫描100万行</td><td><strong>始终O(1)时间</strong></td><td><strong>Cursor不依赖offset</strong>，每次只返回固定数量数据</td></tr><tr><td><strong>2. 内存占用</strong></td><td>一次性返回所有数据，内存占用高</td><td><strong>增量返回</strong>，内存占用低</td><td><strong>适合大数据量</strong>（如1000万+记录）</td></tr><tr><td><strong>3. 数据一致性</strong></td><td>无法处理遍历过程中的数据变化</td><td><strong>正确处理变化</strong>（新增&#x2F;删除）</td><td><strong>遍历过程中，新增数据不会被遗漏</strong></td></tr><tr><td><strong>4. 适用场景</strong></td><td>仅适合小offset分页</td><td><strong>完美适合深分页</strong></td><td><strong>Cursor是深分页的’救命稻草’</strong></td></tr><tr><td><strong>5. 代码复杂度</strong></td><td>简单：<code>ZRANGE key offset size</code></td><td>稍复杂：需维护游标</td><td><strong>优化后，代码更简洁</strong></td></tr></tbody></table><h3 id="Q：为什么ZSCAN比ZRANGE更适合深分页？"><a href="#Q：为什么ZSCAN比ZRANGE更适合深分页？" class="headerlink" title="Q：为什么ZSCAN比ZRANGE更适合深分页？"></a>Q：为什么ZSCAN比ZRANGE更适合深分页？</h3><p><strong>A</strong>：</p><blockquote><p>“ZSCAN通过<strong>增量迭代</strong>方式遍历数据，<strong>不依赖offset</strong>，因此<strong>查询时间与offset无关</strong>。<br> 而ZRANGE使用<code>LIMIT offset, size</code>，当offset很大时，<strong>MySQL会扫描offset行</strong>，导致性能随offset指数级下降。<br> <strong>—— ZSCAN是深分页的’救命稻草’，ZRANGE是’定时炸弹’！”</strong> 💣</p></blockquote><h3 id="Q：ZSCAN在遍历过程中，如果数据变化会怎样？"><a href="#Q：ZSCAN在遍历过程中，如果数据变化会怎样？" class="headerlink" title="Q：ZSCAN在遍历过程中，如果数据变化会怎样？"></a>Q：ZSCAN在遍历过程中，如果数据变化会怎样？</h3><p><strong>A</strong>：</p><blockquote><p>“ZSCAN<strong>能正确处理数据变化</strong>：</p><ol><li><strong>新增数据</strong>：如果新增数据的score在当前游标之后，会被包含在后续遍历中</li><li><strong>删除数据</strong>：如果删除的数据在已遍历范围内，会被跳过</li><li><strong>数据变化</strong>：ZSCAN<strong>不会重复返回或遗漏数据</strong><br><strong>—— 这是ZSCAN的核心优势，也是它适合高并发场景的原因！”</strong> ✅</li></ol></blockquote><h1 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h1><p>脑裂问题的原因与影响</p><p>脑裂通常由网络分区、哨兵误判或主从切换异常引起。其影响包括：</p><ul><li><strong>数据不一致</strong>：不同客户端连接到不同主节点，写入的数据可能冲突。</li><li><strong>数据丢失</strong>：旧主节点恢复后，其数据可能被覆盖。</li><li><strong>请求异常</strong>：部分客户端连接旧主节点，导致查询失败。</li></ul><p>解决脑裂的配置与优化</p><p>Sentinel 模式下的优化</p><ul><li><strong>配置 quorum 和 down-after-milliseconds</strong>：</li></ul><p>sentinel monitor mymaster 192.168.1.100 6379 2</p><p>sentinel down-after-milliseconds mymaster 5000</p><ul><li><strong>设置 min-replicas-to-write 和 min-replicas-max-lag</strong>：</li></ul><p>min-replicas-to-write 2</p><p>min-replicas-max-lag 10</p><ul><li><strong>启用 protected-mode</strong>：</li></ul><p>protected-mode yes</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><p>redis的配置文件中，存在两个参数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">min-slaves-to-write 3<br>min-slaves-max-lag 10<br></code></pre></td></tr></table></figure><p><strong>第一个参数表示连接到master的最少slave数量</strong><br><strong>第二个参数表示slave连接到master的最大延迟时间</strong><br>按照上面的配置，要求至少3个slave节点，且数据复制和同步的延迟不能超过10秒，否则的话master就会拒绝写请求，配置了这两个参数之后，如果发生集群脑裂，原先的master节点接收到客户端的写入请求会拒绝，就可以减少数据同步之后的数据丢失。</p><p>注意：较新版本的redis.conf文件中的参数变成了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">min-replicas-to-write 3<br>min-replicas-max-lag 10<br></code></pre></td></tr></table></figure><p>redis中的异步复制情况下的数据丢失问题也能使用这两个参数</p><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>32淘汰和集群</title>
    <link href="/2025/11/19/32%E6%B7%98%E6%B1%B0%E5%92%8C%E9%9B%86%E7%BE%A4/"/>
    <url>/2025/11/19/32%E6%B7%98%E6%B1%B0%E5%92%8C%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="缓存淘汰和过期删除"><a href="#缓存淘汰和过期删除" class="headerlink" title="缓存淘汰和过期删除"></a>缓存淘汰和过期删除</h2><h3 id="过期删除策略和内存淘汰策略有什么区别？"><a href="#过期删除策略和内存淘汰策略有什么区别？" class="headerlink" title="过期删除策略和内存淘汰策略有什么区别？"></a>过期删除策略和内存淘汰策略有什么区别？</h3><p>区别：</p><ul><li>内存淘汰策略是在内存满了的时候，redis 会触发内存淘汰策略，来淘汰一些不必要的内存资源，以腾出空间，来保存新的内容</li><li>过期键删除策略是将已过期的键值对进行删除，Redis 采用的删除策略是惰性删除+定期删除。</li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p><img src="/./../img/image-20251120154027582.png" alt="image-20251120154027582"></p><h2 id="介绍一下Redis过期删除策略"><a href="#介绍一下Redis过期删除策略" class="headerlink" title="介绍一下Redis过期删除策略"></a><strong>介绍一下Redis过期删除策略</strong></h2><p>Redis采用惰性删除+定期删除的组合策略,核心目标是在合理消耗CPU资源和避免内存浪费后之间找到最优平衡</p><p>(1)惰性删除</p><p>流程步骤</p><p>键过期并不会立即删除,仅在访问&#x2F;修改该键前,通过db.c文件中的expiredIfNeeded函数检查是否过期</p><p>若已经过期则根据lazyfree_lay_expire(Redis4.0+)配置,选择同步删除或异步删除,并返回null给客户端</p><p>优缺点</p><p>避免在大量键同时过期时,占用过多CPU资源而拖慢Redis的正常使用.惰性删除能分散压力</p><p>若过期键长期不被访问,仍会占用内存,这就依赖于定期删除了</p><p>(2)定期删除</p><p>每次从设置了过期时间的键中随机抽取20个,删除其中过期的键</p><p>若过期键占比大于25%,则重复抽查直到小于等于25%,等待下一次执行</p><p>由redis.config中的hz配置中控制执行间隔,默认100ms执行一次</p><p><img src="/./../img/1755608176574-48655767-e379-45dc-af22-16f66d923ff4.webp" alt="image.png"></p><h2 id="Redis缓存失效会不会立即删除-为什么"><a href="#Redis缓存失效会不会立即删除-为什么" class="headerlink" title="Redis缓存失效会不会立即删除,为什么?"></a>Redis缓存失效会不会立即删除,为什么?</h2><p>不会,Redis的缓存删除策略是惰性删除+定期删除混合使用为了</p><p><strong>防止缓存短时间大量失效而造成的批量删除场景,会占用大量CPU资源进而影响Redis的响应时间和吞吐量,</strong></p><h3 id="LRU-算法和-LFU-算法有什么区别？"><a href="#LRU-算法和-LFU-算法有什么区别？" class="headerlink" title="LRU 算法和 LFU 算法有什么区别？"></a>LRU 算法和 LFU 算法有什么区别？</h3><blockquote><p>什么是 LRU 算法？</p></blockquote><p><strong>LRU</strong> 全称是 Least Recently Used 翻译为<strong>最近最少使用</strong>，会选择淘汰最近最少使用的数据。</p><p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p><p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p><ul><li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li><li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li></ul><blockquote><p>Redis 是如何实现 LRU 算法的？</p></blockquote><p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更</p><h3 id="如何设计一个缓存策略，可以动态缓存热点数据呢？"><a href="#如何设计一个缓存策略，可以动态缓存热点数据呢？" class="headerlink" title="如何设计一个缓存策略，可以动态缓存热点数据呢？"></a>如何设计一个缓存策略，可以动态缓存热点数据呢？</h3><p>由于数据存储受限，系统并不是将所有数据都需要存放到缓存中的，而<strong>只是将其中一部分热点数据缓存起来</strong>，所以我们要设计一个热点数据动态缓存的策略。</p><p>热点数据动态缓存的策略总体思路：<strong>通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据</strong>。</p><p>以电商平台场景中的例子，现在要求只缓存用户经常访问的 Top 1000 的商品。具体细节如下：</p><ul><li>先通过缓存系统做一个排序队列（比如存放 1000 个商品），系统会根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前；</li><li>同时系统会定期过滤掉队列中排名最后的 200 个商品，然后再从数据库中随机读取出 200 个商品加入队列中；</li><li>这样当请求每次到达的时候，会先从队列中获取商品 ID，如果命中，就根据 ID 再从另一个缓存数据结构中读取实际的商品信息，并返回。</li></ul><p>在 Redis 中可以用 zadd 方法和 zrange 方法来完成排序队列和获取 200 个商品的操作。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h1 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h1><h3 id="Redis主从同步中的增量和完全同步怎么实现？"><a href="#Redis主从同步中的增量和完全同步怎么实现？" class="headerlink" title="#Redis主从同步中的增量和完全同步怎么实现？"></a><a href="https://xiaolincoding.com/interview/redis.html#redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%AD%E7%9A%84%E5%A2%9E%E9%87%8F%E5%92%8C%E5%AE%8C%E5%85%A8%E5%90%8C%E6%AD%A5%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0">#</a>Redis主从同步中的增量和完全同步怎么实现？</h3><blockquote><p>完全同步</p></blockquote><p>完全同步发生在以下几种情况：</p><ul><li><strong>初次同步</strong>：当一个从服务器（slave）首次连接到主服务器（master）时，会进行一次完全同步。</li><li><strong>从服务器数据丢失</strong>：如果从服务器数据由于某种原因（如断电）丢失，它会请求进行完全同步。</li><li><strong>主服务器数据发生变化</strong>：如果从服务器长时间未与主服务器同步，导致数据差异太大，也可能触发完全同步。</li></ul><blockquote><p>增量同步</p></blockquote><p>触发条件</p><p>Slave断线重连同步且断线期间repl_backlog仍正常保存Slave断开时offset之后的命令未被覆盖</p><p>流程拆解</p><p>身份校验:Slave重连后发psync replid offset,Master验证replid一致且repl_backlog中offset之后的命令未被覆盖.</p><p>增量命令</p><p>推送从repl_backlog中定位到Slave提供的offset,提取该位置之后的所有命令,通过TCP连接以流的形式持续推送给Slave,同时更新Slave的offset记录</p><p>Slave端接收命令按顺序执行,每执行完一批命令就向Master反馈最新的offset,直到offset版本与Master的一致</p><h2 id="介绍一下repl-backlog和offset"><a href="#介绍一下repl-backlog和offset" class="headerlink" title="介绍一下repl_backlog和offset"></a>介绍一下repl_backlog和offset</h2><p>(1)repl_backlog</p><p>本质上是固定大小的环形缓冲区,默认大小是1MB</p><p>主要用于记录主节点接收到的写命令可以应用于增量同步和全量同步时的数据增量</p><p>(2)offsetoffset</p><p>是一个偏移量,用于关联repl_backlog中写命令的位置</p><p>主节点维护着一个master_repl_offset,从节点维护一个slave_repl_offset都记录自己当前关联在repl_backlog中的版本</p><p>主节点和从节点版本的差距不能超过一个repl_backlog的差距</p><h3 id="redis主从和集群可以保证数据一致性吗-？"><a href="#redis主从和集群可以保证数据一致性吗-？" class="headerlink" title="redis主从和集群可以保证数据一致性吗 ？"></a>redis主从和集群可以保证数据一致性吗 ？</h3><p>redis 主从和集群在CAP理论都属于AP模型，即在面临网络分区时选择保证可用性和分区容忍性，而牺牲了强一致性。这意味着在网络分区的情况下，Redis主从复制和集群可以继续提供服务并保持可用，但可能会出现部分节点之间的数据不一致</p><p><img src="/./../img/1755622631933-39eeac25-ba87-45a2-9757-0843e29bc4d2.webp" alt="image.png"></p><h3 id="哨兵机制原理是什么？"><a href="#哨兵机制原理是什么？" class="headerlink" title="哨兵机制原理是什么？"></a>哨兵机制原理是什么？</h3><p><strong>哨兵（*<em>*</em>*Sentinel**<em>*</em>）机制</strong>，它的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p><p>哨兵节点主要负责三件事情：<strong>监控、选主、通知</strong>。</p><h3 id="哨兵机制的选主节点的算法介绍一下"><a href="#哨兵机制的选主节点的算法介绍一下" class="headerlink" title="哨兵机制的选主节点的算法介绍一下"></a>哨兵机制的选主节点的算法介绍一下</h3><p>当redis集群的主节点故障时，Sentinel集群将从剩余的从节点中选举一个新的主节点，有以下步骤：</p><ol><li><p>故障节点主观下线</p><p>每一个Sentinel节点会定时对redis集群的所有节点发心跳包检测节点是否正常。如果一个节点在down-after-milliseconds时间内没有回复Sentinel节点的心跳包，则该redis节点被该Sentinel节点主观下线。</p></li><li><p>故障节点客观下线</p><p>该Sentinel节点会询问其他Sentinel节点，如果Sentinel集群中超过quorum数量的Sentinel节点认为该redis节点主观下线，则该redis客观下线。</p></li><li><p>Sentinel集群选举Leade</p><p>一个Sentinel节点确认redis集群的主节点主观下线后，会请求其他Sentinel节点要求将自己选举为Leader。被请求的Sentinel节点如果没有同意过其他Sentinel节点的选举请求，则同意该请求(选举票数+1)，否则不同意。</p><p>4.Sentinel Leader决定新主节点</p></li></ol><p>当Sentinel集群选举出Sentinel Leader后，由Sentinel Leader从redis从节点中选择一个redis节点作为主节点：</p><ol><li>过滤故障的节点</li><li>选择优先级slave-priority最大的从节点作为主节点，如不存在则继续</li><li>选择复制偏移量（数据写入量的字节，记录写了多少数据。主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步）最大的从节点作为主节点，如不存在则继续</li><li>选择runid（redis每次启动的时候生成随机的runid作为redis的标识）最小的从节点作为主节点</li></ol><h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><h2 id="什么是集群"><a href="#什么是集群" class="headerlink" title="什么是集群"></a>什么是集群</h2><p>Redis分片集群是Redis官方提供的分布式解决方案，通过将数据分散到多个节点，解决了单机Redis在内存容量、计算能力和可用性方面的限制。该模式采用去中心化架构，无需依赖外部协调组件如ZooKeeper或Sentinel（虽然可以配合使用）。</p><h2 id="核心机制解析"><a href="#核心机制解析" class="headerlink" title="核心机制解析"></a>核心机制解析</h2><h3 id="1-哈希槽机制"><a href="#1-哈希槽机制" class="headerlink" title="1. 哈希槽机制"></a>1. 哈希槽机制</h3><ul><li>Redis Cluster使用<strong>16384个固定哈希槽</strong>作为数据分布的映射处理</li><li><strong>一个切片集群共有 16384 个哈希槽</strong>，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：<ul><li>根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值。</li><li>再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</li></ul></li><li>键到槽的映射：<code>slot = CRC16(key) % 16384</code></li><li><strong>16384这个数字的选择很精妙</strong>：足够小以保证节点间心跳包不会过大（每个包携带位图表示槽分配），又足够大以支持最多1000个节点的集群规模</li></ul><p>只有当16384个槽全部分配完毕,Redis Cluster才会进入正常工作状态.否则会报错</p><p>平均分配:使用cluster create命令创建集群时,Redis自动平均分配</p><p>手动分配:灵活可控,性能强的节点可以分配更多槽</p><h3 id="2-高可用设计"><a href="#2-高可用设计" class="headerlink" title="2. 高可用设计"></a>2. 高可用设计</h3><ul><li><p><strong>主从架构</strong>：每个主节点至少有一个从节点，用于数据备份和故障转移</p></li><li><p>去中心化通信：通过Gossip协议实现节点间高效、可靠的信息交换</p><p>协议内容节点状态:</p><p>节点在线情况,角色</p><p>哈希槽归属:明确哪些节点负责哪些哈希槽</p><p>主从映射:记录Slave对应哪个Master</p><ul><li>节点定期随机选择其他节点交换信息</li><li>Redis Cluster节点通信不依赖单一中心组件,每个节点都能主动发起信息交换,没有核心的指挥中心,避免中心节点故障导致的整个集群通信瘫痪,不过也有状态同步的微小延迟.</li></ul></li></ul><h3 id="3-故障转移机制"><a href="#3-故障转移机制" class="headerlink" title="3. 故障转移机制"></a>3. 故障转移机制</h3><ul><li>节点互相监控，当多数主节点认为某节点不可达时，标记为<strong>客观下线</strong>(PFAIL→FAIL)</li><li>从节点通过类Raft投票机制选举新主，优先考虑：<ol><li>数据复制偏移量(offset)最大的从节点</li><li>运行ID字典序最小的节点</li></ol></li><li>整个过程通常在几秒内完成，大幅降低服务中断时间</li></ul><h3 id="4-客户端交互"><a href="#4-客户端交互" class="headerlink" title="4. 客户端交互"></a>4. 客户端交互</h3><ul><li>客户端维护槽到节点的映射缓存</li><li>当请求错误节点时，返回<strong>MOVED重定向</strong>（永久重定向）或<strong>ASK重定向</strong>（临时重定向，用于槽迁移中）</li><li>智能客户端会自动更新本地缓存，优化后续请求路由</li></ul><h2 id="优势分析"><a href="#优势分析" class="headerlink" title="优势分析"></a>优势分析</h2><ol><li><strong>线性扩展能力</strong>：通过增加节点，几乎线性提升集群容量和吞吐量</li><li><strong>高可用保障</strong>：内置故障检测和自动转移，无需额外组件</li><li><strong>去中心化设计</strong>：无单点故障，避免了传统中心化协调器的瓶颈</li><li><strong>灵活的数据分布</strong>：可根据节点性能分配不同数量的哈希槽</li><li><strong>客户端缓存优化</strong>：减少重定向开销，提高访问效率</li><li><strong>平滑扩容&#x2F;缩容</strong>：支持在线迁移哈希槽，服务不中断</li></ol><h2 id="局限与挑战"><a href="#局限与挑战" class="headerlink" title="局限与挑战"></a>局限与挑战</h2><ol><li><strong>跨槽操作受限</strong>：<ul><li>无法执行跨多个哈希槽的事务</li><li>多键操作（如MGET）要求所有键在同一个槽</li><li>可通过<strong>哈希标签</strong>（例如<code>&#123;user1000&#125;.profile</code>和<code>&#123;user1000&#125;.orders</code>共享相同哈希标签）解决部分场景</li></ul></li><li><strong>复杂性代价</strong>：<ul><li>集群部署、监控、故障诊断比单机模式复杂</li><li>需要专门的运维知识和工具支持</li></ul></li><li><strong>数据均衡挑战</strong>：<ul><li>热点数据可能集中在少数槽，导致负载不均</li><li>需要手动干预重新分配槽或使用哈希标签优化</li></ul></li><li><strong>网络分区风险</strong>：<ul><li>在严重网络分区情况下，可能面临脑裂问题</li><li>需要合理配置<code>cluster-node-timeout</code>等参数平衡可用性和一致性</li></ul></li></ol><p>✅ 一句话核心结论</p><blockquote><p>**”脑裂 &#x3D; 网络分区导致集群分裂，多个节点同时自称主节点 → *<em>数据混乱！*</em> 解决方案：*<em>用多数派原则（Quorum）+ 合理超时*</em>，让 Redis Sentinel&#x2F;Cluster 自动避免脑裂。”**</p></blockquote><h2 id="Redis-如何解决脑裂？（3-个关键配置）"><a href="#Redis-如何解决脑裂？（3-个关键配置）" class="headerlink" title="Redis 如何解决脑裂？（3 个关键配置）"></a>Redis 如何解决脑裂？（3 个关键配置）</h2><h3 id="✅-方案-1：Redis-Sentinel-的-Quorum（法定人数）（核心！）"><a href="#✅-方案-1：Redis-Sentinel-的-Quorum（法定人数）（核心！）" class="headerlink" title="✅ 方案 1：Redis Sentinel 的 Quorum（法定人数）（核心！）"></a>✅ 方案 1：Redis Sentinel 的 <strong>Quorum（法定人数）</strong>（核心！）</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment"># sentinel.conf 配置示例</span><br>sentinel<span class="hljs-built_in"> monitor </span>mymaster 10.0.0.1 6379 2  <span class="hljs-comment"># quorum=2（需2个Sentinel同意）</span><br>sentinel down-after-milliseconds mymaster 30000  <span class="hljs-comment"># 网络延迟阈值（ms）</span><br>sentinel failover-timeout mymaster 180000  <span class="hljs-comment"># 故障转移超时</span><br></code></pre></td></tr></table></figure><ul><li><p>原理：</p><blockquote><p>“故障转移 <strong>必须获得多数 Sentinel 同意</strong>（如 3 个 Sentinel 中需 2 个同意）→ 网络分区时，少数派 Sentinel 无法触发选举 → <strong>避免脑裂</strong>。”</p></blockquote></li></ul><blockquote><p>💡 <strong>为什么有效</strong>？</p><ul><li>网络分区后，Sentinel 分成两组：A组（2个）和 B组（1个）</li><li>A组能触发选举（因 quorum&#x3D;2），B组不能 → <strong>只有 A组 生成新 Master</strong></li><li>原 Master（在 B组）无法被选举 → <strong>不会产生第二个 Master</strong></li></ul></blockquote><hr><h3 id="✅-方案-2：Redis-Cluster-的-cluster-require-full-coverage（核心！）"><a href="#✅-方案-2：Redis-Cluster-的-cluster-require-full-coverage（核心！）" class="headerlink" title="✅ 方案 2：Redis Cluster 的 cluster-require-full-coverage（核心！）"></a>✅ 方案 2：Redis Cluster 的 <strong><code>cluster-require-full-coverage</code></strong>（核心！）</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-comment"># redis.conf 配置</span><br>cluster-<span class="hljs-built_in">require</span>-full-coverage <span class="hljs-literal">no</span>  <span class="hljs-comment"># 默认值：no（可关闭）</span><br><span class="hljs-comment"># 改为：</span><br>cluster-<span class="hljs-built_in">require</span>-full-coverage <span class="hljs-literal">yes</span>  <span class="hljs-comment"># 强制要求集群完整</span><br></code></pre></td></tr></table></figure><ul><li><p>原理：</p><blockquote><p>“当 <strong>节点数 &lt; 总节点数的一半</strong> 时，<strong>集群拒绝服务</strong>（不提供写操作）→ 防止小集群继续工作导致脑裂。”</p></blockquote></li></ul><blockquote><p>💡 <strong>为什么有效</strong>？</p><ul><li>假设集群有 5 个节点，网络分区成 2+3 两组</li><li>2 个节点组无法达到 5&#x2F;2&#x3D;3 节点的法定要求 → <strong>自动拒绝服务</strong></li><li>3 个节点组正常工作 → <strong>只有一个 Master</strong>（无脑裂）</li></ul></blockquote><blockquote><p>✅ <strong>Redis 官方建议</strong>：<br> <em>“在生产环境必须开启 <code>cluster-require-full-coverage yes</code>！”</em></p></blockquote><hr><h3 id="✅-方案-3：合理设置超时时间（避免误判）"><a href="#✅-方案-3：合理设置超时时间（避免误判）" class="headerlink" title="✅ 方案 3：合理设置超时时间（避免误判）"></a>✅ 方案 3：<strong>合理设置超时时间</strong>（避免误判）</h3><table><thead><tr><th>配置项</th><th>推荐值</th><th>作用</th></tr></thead><tbody><tr><td><code>down-after-milliseconds</code></td><td>30000（30秒）</td><td>网络延迟超过此值才判宕机</td></tr><tr><td><code>failover-timeout</code></td><td>180000（3分钟）</td><td>故障转移超时，避免反复切换</td></tr></tbody></table><blockquote><p>💡 <strong>为什么重要</strong>？</p><ul><li>短超时（如 5秒）→ 网络抖动触发误判 → <strong>脑裂风险↑</strong></li><li>长超时（如 30秒）→ 等待网络恢复 → <strong>减少误判</strong><br><em>（实测：30秒是网络抖动的典型恢复时间）</em></li></ul></blockquote><table><thead><tr><th>误区</th><th>事实</th><th>为什么</th></tr></thead><tbody><tr><td>“Redis 会自动解决脑裂”</td><td>❌ <strong>错误！</strong> 需手动配置 <code>quorum</code>&#x2F;<code>cluster-require-full-coverage</code></td><td>Redis 本身不默认开启，需主动配置</td></tr><tr><td>“脑裂只发生在 Sentinel”</td><td>❌ <strong>错误！</strong> 也发生在 Redis Cluster</td><td>两种模式都可能脑裂</td></tr><tr><td>“关掉 Sentinel 就能避免脑裂”</td><td>❌ <strong>错误！</strong> 无 Sentinel 时脑裂更严重</td><td>无故障转移机制，数据混乱更彻底</td></tr><tr><td>“设置 <code>quorum=1</code> 最安全”</td><td>❌ <strong>错误！</strong> <code>quorum=1</code> 会放大脑裂风险</td><td>1 个 Sentinel 就触发选举 → 网络抖动即脑裂</td></tr></tbody></table><h1 id="红锁"><a href="#红锁" class="headerlink" title="红锁"></a>红锁</h1><ul><li><strong>Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性</strong>。如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</li></ul><blockquote><p>Redis 如何解决集群情况下分布式锁的可靠性？</p></blockquote><p>为了保证集群环境下分布式锁的可靠性，Redis 官方已经设计了一个分布式锁算法 Redlock（红锁）。</p><p>它是基于<strong>多个 Redis 节点</strong>的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。官方推荐是至少部署 5 个 Redis 节点，而且都是主节点，它们之间没有任何关系，都是一个个孤立的节点。</p><p>Redlock 算法的基本思路，<strong>是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败</strong>。</p><p>这样一来，即使有某个 Redis 节点发生故障，因为锁的数据在其他节点上也有保存，所以客户端仍然可以正常地进行锁操作，锁的数据也不会丢失。</p><p>Redlock 算法加锁三个过程：</p><ul><li><p>第一步是，客户端获取当前时间（t1）。</p></li><li><p>第二步是，客户端按顺序依次向 N 个 Redis 节点执行加锁操作：</p><ul><li>加锁操作使用 SET 命令，带上 NX，EX&#x2F;PX 选项，以及带上客户端的唯一标识。</li><li>如果某个 Redis 节点发生故障了，为了保证在这种情况下，Redlock 算法能够继续运行，我们需要给「加锁操作」设置一个超时时间（不是对「锁」设置超时时间，而是对「加锁操作」设置超时时间），加锁操作的超时时间需要远远地小于锁的过期时间，一般也就是设置为几十毫秒。</li></ul></li><li><p>第三步是，一旦客户端从超过半数（大于等于 N&#x2F;2+1）的 Redis 节点上成功获取到了锁，就再次获取当前时间（t2），然后计算计算整个加锁过程的总耗时（t2-t1）。如果 t2-t1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败。</p><h2 id="加锁成功"><a href="#加锁成功" class="headerlink" title="加锁成功"></a>加锁成功</h2></li></ul><p>可以看到，加锁成功要同时满足两个条件**（<em>简述：如果有超过半数的 Redis 节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功</em>）：**</p><ul><li>条件一：客户端从超过半数（大于等于 N&#x2F;2+1）的 Redis 节点上成功获取到了锁；</li><li>条件二：客户端从大多数节点获取锁的总耗时（t2-t1）小于锁设置的过期时间。</li></ul><p>加锁成功后，客户端需要重新计算这把锁的有效时间，计算的结果是「锁最初设置的过期时间」减去「客户端从大多数节点获取锁的总耗时（t2-t1）」。如果计算的结果已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。</p><p>加锁失败后，客户端向<strong>所有 Redis 节点发起释放锁的操作</strong>，释放锁的操作和在单节点上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。</p><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>31redis事务和日志</title>
    <link href="/2025/11/18/31redis%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%97%A5%E5%BF%97/"/>
    <url>/2025/11/18/31redis%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis事务保证原子性吗,如何实现Redis原子性 (1)Redis事务保证原子性吗Redis事务不像MySQL那样的关系型数据库事务那样拥有事务回滚操作当Redis事务的所有命令都成功执行后才能保证原子性,若某一命令失败,则下一命令仍会继续执行.(2)Redis如何实现原子性背景引入Redis内核是单线程,按发送顺序执行,天然地命令串行,不会又并发安全问题.Redis能保证同一客户端地命令严格串行,但不同的客户端会命令会交叉执行,无法保证同一客户端的一组命令连续执行,容易出现问题.事务能保证同一客户端的一组命令连续执行,不会被其它客户端打断Lua脚本解决可以将多个操作写到一个lua脚本中,Redis会把整个lua脚本作为一个整体执行既能实现事务的核心需求”不可打断性”,又可以通过逻辑控制(if)实现条件判断来决定后续的命令是否执行,更可以解决事务的频繁网络IO问题且只仅需一次网络IO由于Lua脚本是逐行检查并执行,若中间代码出现语法错误导致不执行,那么之前的命令不回滚,而事务在EXEC时统一校验语法,  有错误则全不执行,但对于类型匹配问题校验时是通过的,事务仍会通过.1)事务没有逻辑控制,要么全不执行(语法错误),要么能执行的全执行,失败的仅自身不生效,注定它无法完成库存校验-&gt;库存扣减-&gt;订单生成这样的组合性原子操作,只能通过lua脚本2)但Lua脚本也无法实现命令执行失败的回滚操作,因为Redis追求轻量高效,没有Undo Log(MySQL通过该技术记录数据修改前的状态,回滚时可反向执行操作),若为回滚设计命令日志,会大量增加内存开销和执行复杂度.3)可以在业务层设置一个Redis延迟队列来进行兜底,先预估业务执行时间,然后创建临时标记同时将延迟任务入列,接着开启一个守护线程来阻塞等待消费,消费时通过查询数据来判断命令是否正确执行,若未执行则触发兜底操作.</p><h2 id="事务不支持-ACID-的完整实现"><a href="#事务不支持-ACID-的完整实现" class="headerlink" title="事务不支持 ACID 的完整实现"></a>事务不支持 ACID 的完整实现</h2><table><thead><tr><th>ACID 属性</th><th>Redis 事务支持</th><th>为什么？</th></tr></thead><tbody><tr><td><strong>A (Atomicity)</strong></td><td>❌ <strong>不支持</strong></td><td>事务中命令失败时，<strong>已执行的命令不会回滚</strong>（例如 <code>SET</code> 成功后 <code>INCR</code> 失败，<code>SET</code> 的修改保留）</td></tr><tr><td><strong>C (Consistency)</strong></td><td>❌ <strong>不支持</strong></td><td>事务不保证数据一致性（如 <code>INCR</code> 依赖 <code>SET</code> 的值，但事务中可能被其他客户端修改）</td></tr><tr><td><strong>I (Isolation)</strong></td><td>✅ <strong>支持</strong></td><td>事务命令 <strong>串行执行</strong>（其他客户端无法在事务执行期间插入命令），实现类似串行化隔离</td></tr><tr><td><strong>D (Durability)</strong></td><td>❌ <strong>不支持</strong></td><td>事务本身<strong>不涉及持久化</strong>，持久性由 AOF&#x2F;RDB 保证</td></tr></tbody></table><blockquote><p>💡 <strong>面试官深度问</strong>：为什么 Redis 不支持原子性？ <strong>答</strong>：<br> “Redis 采用 <strong>单线程模型</strong>，事务命令在 <code>EXEC</code> 时<strong>顺序执行</strong>，但<strong>没有回滚机制</strong>。设计哲学是 <strong>‘快速执行，不保证事务完整性’</strong> —— 与数据库不同，Redis 优先保证高吞吐量，牺牲了事务的原子性。<br> <em>例如：<code>MULTI; SET a 1; INCR a; EXEC</code>，如果 <code>INCR</code> 失败，<code>SET a 1</code> 的结果已生效。”</em>（LUA中途出现语法错误）</p></blockquote><h1 id="aof和rdb"><a href="#aof和rdb" class="headerlink" title="aof和rdb"></a>aof和rdb</h1><h3 id="Redis有哪2种持久化方式？分别的优缺点是什么？"><a href="#Redis有哪2种持久化方式？分别的优缺点是什么？" class="headerlink" title="Redis有哪2种持久化方式？分别的优缺点是什么？"></a>Redis有哪2种持久化方式？分别的优缺点是什么？</h3><h4 id="aof"><a href="#aof" class="headerlink" title="aof"></a>aof</h4><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。Redis 共有三种数据持久化的方式：</p><ul><li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li><li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li>混合模式</li></ul><blockquote><p>AOF 日志是如何实现的？</p></blockquote><p>客户端发送写命令（如 SET name Tom）；<br>Redis 执行命令并将原生命令转换为 文本协议格式（RESP）；<br>命令被追加到 AOF 缓冲区（aof_buf）；<br>根据配置的同步策略（appendfsync），缓冲区内容写入并同步到磁盘文件 appendonly.aof；<br>（后台或手动触发）AOF 重写（rewrite）：压缩历史命令，生成更精简的 AOF 文件；<br>Redis 重启时加载 AOF 文件，顺序执行命令恢复数据。</p><p>aof的3 个写回策略的优缺点总结成了一张表格：</p><p><img src="/./../img/1719110103571-b6bd31d1-7955-4e57-aee5-ae95302183b9.webp" alt="img"></p><blockquote><p>RDB 快照是如何实现的呢？</p></blockquote><p>因为 AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，<strong>需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢</strong>。为了解决这个问题，Redis 增加了 RDB 快照。</p><h4 id="rdb"><a href="#rdb" class="headerlink" title="rdb"></a>rdb</h4><p>所以，RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p><ul><li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li><li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><img src="./../img/image-20251120115350554.png" alt="image-20251120115350554" style="zoom: 80%;" /><img src="./../img/image-20251120115422043.png" alt="image-20251120115422043" style="zoom:80%;" /><p>(1)AOF优点数据完整性:AOF数据完整性更高,因为它每隔一小段时间就会追加到文件末尾,即使Redis服务宕机,也只会丢失最后一次追加前的数据平衡策略:AOF支持多种同步策略,可以调整数据安全与性能的平衡重写机制:触发阈值或手动重写AOF文件,减小文件体积并加快恢复速度文件修复:AOF还提供了redis-check-aof工具来修复损坏的文件</p><p>缺点磁盘空间占用:因为记录每一个写操作,AOF文件比RDB文件更大磁盘IO:频繁进行磁盘IO操作,可能会拖慢Redis写入性能宕机恢复:即使重写,AOF的恢复速度通常也慢于RDB.</p><p>(2)RDB优点RDB基于快照形式保存某一时刻的数据状态并进行二进制压缩,文件体积下且恢复速度快RDB是在主进程之外通过fork子进程异步生成快照,对Redis核心业务的性能影响小</p><p>缺点数据完整性较低:两次快照期间若发生宕机会造成数据的大量丢失,这在高并发环境下是难以容忍的在快照形成期间,若有写请求会触发写时复制,极端情况内存占用提升一倍</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>只要满足<strong>配置自动快照策略</strong>，就会自动执行 BGSAVE。</p><p>主从全量复制（全同步）<br>当从节点首次连接主节点或主从数据严重不一致时，主节点会执行一次 RDB 快照，并将 RDB 文件发送给从节点用于初始化。此时即使未启用 SAVE 规则，也会触发 RDB 生成。<br>执行 SHUTDOWN 命令<br>若启用了 RDB（默认开启），Redis 在正常关闭（非 crash）时会执行一次 RDB 持久化以保存最新状态再退出。</p><h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>✅ <strong>步骤 1：触发重写条件（自动&#x2F;手动）</strong></p><table><thead><tr><th>触发方式</th><th>配置参数</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><strong>自动触发</strong></td><td><code>auto-aof-rewrite-min-size 64mb</code> <code>auto-aof-rewrite-percentage 100</code></td><td>AOF &gt; 64MB 且 比上次重写后大 100%</td><td>例如：上次重写后 AOF&#x3D;50MB，当前&#x3D;100MB → 触发</td></tr><tr><td><strong>手动触发</strong></td><td><code>BGREWRITEAOF</code></td><td><code>redis-cli BGREWRITEAOF</code></td><td>无延迟，立即执行</td></tr></tbody></table><blockquote><p>💡 <strong>为什么这样设计</strong>？<br> 避免频繁重写（如 AOF 1MB 时重写无意义），只在文件膨胀到<strong>合理阈值</strong>时触发。</p></blockquote><p>✅ <strong>步骤 2：fork 子进程（关键！）</strong></p><ul><li><strong>操作</strong>：Redis 主进程 <code>fork()</code> 一个子进程（类似 RDB 快照）</li><li>为什么用子进程？<ul><li><strong>不阻塞主线程</strong>：子进程遍历内存时，主线程继续处理请求</li><li><strong>内存快照</strong>：子进程获得<strong>当前内存数据的副本</strong>（fork 时的快照）</li></ul></li><li><strong>代价</strong>：<code>fork()</code> 耗时（与内存大小正相关，1GB 内存约 10ms）</li></ul><blockquote><p>💡 <strong>面试官深度问</strong>：为什么不用主线程重写？ <strong>答</strong>：<br> “主线程重写会<strong>阻塞所有客户端请求</strong>！例如遍历 100 万 key 需 100ms，用户会感知卡顿。<br> <strong>子进程方案保证 Redis 高可用</strong>——这是 Redis 为性能牺牲的工程智慧。”</p></blockquote><p>✅ <strong>步骤 3：子进程生成新 AOF 文件（核心！）</strong></p><ul><li>操作：子进程遍历当前内存中的所有 key，为每个 key 生成最少命令</li><li>关键优化：<ul><li><strong>只保留最新值</strong>：<code>SET key 1</code> → <code>SET key 2</code> → <strong>只保留 <code>SET key 2</code></strong></li><li><strong>合并命令</strong>：<code>HSET user:1000 name Alice</code> + <code>HSET user:1000 age 25</code> → <strong>保留两条命令</strong>（无法合并）</li><li><strong>跳过过期 key</strong>：不生成已过期 key 的命令</li></ul></li></ul><blockquote><p>💡 <strong>为什么能压缩</strong>？<br> 例如：</p><ul><li>原 AOF：<code>SET a 1</code> <code>SET a 2</code> <code>SET a 3</code> … <code>SET a 1000</code></li><li>重写后：<code>SET a 1000</code>（仅 1 条命令！）<br><strong>压缩率 99.9%+</strong>（小数据集压缩率 90%+，大数据集 95%+）</li></ul></blockquote><p>✅ <strong>步骤 4：主进程处理重写缓冲区（数据安全！）</strong></p><ul><li><strong>问题</strong>：子进程重写期间，主线程继续处理新命令（如 <code>SET a 1001</code>）</li><li>解决方案：<ul><li>主线程将新命令<strong>追加到 <code>aof_rewrite_buffer</code></strong>（内存缓冲区）</li><li>重写完成后，<strong>将 <code>aof_rewrite_buffer</code> 追加到新 AOF 文件</strong></li></ul></li><li>为什么安全？<ul><li>重写期间的命令被<strong>完整记录</strong>，不会丢失</li><li>新 AOF 文件 &#x3D; <strong>重写文件 + 重写期间的新命令</strong></li></ul></li></ul><blockquote><p>💡 <strong>面试官终极问</strong>：如果重写过程中 Redis 崩溃，数据会丢失吗？ <strong>答</strong>：<br> “<strong>不会丢失</strong>！因为：</p><ol><li>重写文件保存了<strong>当前数据</strong></li><li>重写缓冲区保存了<strong>重写期间的增量</strong></li><li>恢复时，Redis 先加载新 AOF 文件，再重放缓冲区命令<br><em>（这是 Redis 持久性的核心保障！）”</em></li></ol></blockquote><h3 id="Q1：为什么-Redis-不像-MySQL-一样先写日志再执行命令？"><a href="#Q1：为什么-Redis-不像-MySQL-一样先写日志再执行命令？" class="headerlink" title="Q1：为什么 Redis 不像 MySQL 一样先写日志再执行命令？"></a>Q1：为什么 Redis 不像 MySQL 一样先写日志再执行命令？</h3><p><strong>答</strong>：</p><blockquote><p>“因为 <strong>Redis 的定位是 ‘内存缓存’，不是 ‘数据库’</strong>：</p><ul><li>MySQL 为 ACID 事务设计，<strong>必须先写日志</strong>（强一致性）</li><li>Redis 为 <strong>高吞吐量</strong> 设计，<strong>先执行命令再写日志</strong>（性能优先）<br><em>（Redis 官方文档： ‘Redis 是内存数据库，速度是第一优先级’）”</em></li></ul></blockquote><hr><h3 id="Q2：如果我用-everysec-配置，崩溃时丢失-1-秒数据，怎么避免？"><a href="#Q2：如果我用-everysec-配置，崩溃时丢失-1-秒数据，怎么避免？" class="headerlink" title="Q2：如果我用 everysec 配置，崩溃时丢失 1 秒数据，怎么避免？"></a>Q2：如果我用 <code>everysec</code> 配置，崩溃时丢失 1 秒数据，怎么避免？</h3><p><strong>答</strong>：</p><blockquote><p>“<strong>有三种方案</strong>：</p><ol><li><strong>升级配置</strong>：用 <code>appendfsync always</code>（但 QPS 会暴跌）</li><li><strong>业务补偿</strong>：在应用层记录关键操作（如订单状态）</li><li><strong>混合持久化</strong>：Redis 4.0+ 支持 <strong>AOF + RDB 混合</strong>（默认 RDB 为主，AOF 为辅）<br><em>（最佳实践：99% 场景用默认 <code>everysec</code>，仅关键业务用 <code>always</code>）”</em></li></ol></blockquote><h1 id="如何进行恢复"><a href="#如何进行恢复" class="headerlink" title="如何进行恢复"></a>如何进行恢复</h1><p>Redis 启动时如何选择 RDB 还是 AOF？</p><p>如果 同时开启了 RDB 和 AOF：<br>优先使用 AOF 恢复（因为 AOF 数据更新）；<br>加载 appendonly.aof 并执行所有命令。AOF恢复从磁盘中加载AOF文件到Redis进程的内存缓冲区；逐行解析AOF文件中的命令,将字节流还原成一条一条Redis命令；按顺序在内存中重新执行命令.</p><p>如果只启用了 AOF：加载 AOF；<br>如果只启用了 RDB：加载 dump.rdb；RDB恢复流程检测RDB文件,若未开启AOF且配置开启RDB(默认),指定路径下扫描是否存在RDB文件,自动加载该文件按Redis定义的RDB二进制协议解析文件,先确保文件未损坏再还原数据.<br>如果都未开启：启动空数据库。</p><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>208-Trie树</title>
    <link href="/2025/11/17/%E5%8A%9B%E6%89%A3208Trie%E6%A0%91/"/>
    <url>/2025/11/17/%E5%8A%9B%E6%89%A3208Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        <span class="hljs-type">boolean</span> end =<span class="hljs-literal">false</span>;<br>        Node []son =<span class="hljs-keyword">new</span> Node[<span class="hljs-number">26</span>];<br>    &#125;<br>    Node root =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">String</span> <span class="hljs-type">word</span>)</span> </span>&#123;<br>        Node curr =root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> arr:<span class="hljs-type">word</span>.<span class="hljs-built_in">toCharArray</span>())&#123;<br>            arr -=<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(curr.son[arr] == null)&#123;<br>                curr.son[arr] =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>            &#125;<br>            curr = curr.son[arr];<br>        &#125;   <br>        curr.end =<span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">String</span> <span class="hljs-type">word</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getTrie</span>(<span class="hljs-type">word</span>)==<span class="hljs-number">2</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-type">String</span> prefix)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getTrie</span>(prefix)!=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getTrie</span><span class="hljs-params">(<span class="hljs-type">String</span> <span class="hljs-type">word</span>)</span></span>&#123;<br>        Node arr =root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> now:<span class="hljs-type">word</span>.<span class="hljs-built_in">toCharArray</span>())&#123;<br>            now-=<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(arr.son[now]==null)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            arr = arr.son[now];<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr.end == <span class="hljs-literal">true</span>?<span class="hljs-number">2</span>:<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie obj = new Trie();</span><br><span class="hljs-comment"> * obj.insert(word);</span><br><span class="hljs-comment"> * boolean param_2 = obj.search(word);</span><br><span class="hljs-comment"> * boolean param_3 = obj.startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>30redis基础</title>
    <link href="/2025/11/17/30redis%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/11/17/30redis%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h2><p>(1)纯内存操作这是最最主要的原因Redis数据读写操作发生在内存中,访问速度是纳秒级别,而数据库频繁读写磁盘的速度是毫秒级别,两者相差多个数量级.</p><p>(2)高效的IO模型Redis使用单线程事件循环配合IO多路复用技术,让单线程可以同时处理多个网络连接上的IO事件,避免了多线程模型中的上下文切换和锁竞争问题.</p><p>事件循环:无限循环,不断轮询并处理就绪的事件,直到Redis服务停止,整个循环会处理两类事件:文件事件(建立TCP,客户端读写)和时间事件(定时任务),先IO后定时,循环往复.</p><p>(3)优化的内部数据结构Redis提供多种数据类型,内部采用高度优化的编码方式Redis会根据数据大小和类型动态选择最合适的内部编码,以在性能和空间效率之间取得最佳平衡.</p><p>(4)简洁高效的通信协议Redis使用自己设计的RESP协议该协议实现简单,解析性能好,且是二进制安全的客户端和服务端之间的序列化&#x2F;反序列开销很小,有助于提升整体的交互速度.</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因</p><p> Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会<strong>额外创建 6 个线程</strong>（<em>这里的线程数不包括主线程</em>）：</p><ul><li>Redis-server ： Redis的主线程，主要负责执行命令；</li><li>bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；</li><li>通过 <code>bio_close_file</code> 后台线程来释放 AOF &#x2F; RDB 等过程中产生的临时文件资源。</li><li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（AOF 文件）。</li><li>通过 <code>bio_lazy_free</code> 后台线程释放大对象（已删除）占用的内存空间.</li><li>io_thd_1、io_thd_2、io_thd_3：三个 I&#x2F;O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I&#x2F;O 多线程，用来分担 Redis 网络 I&#x2F;O 的压力。</li></ul><p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 &gt; 1，需要修改 redis 配置文件 <code>redis.conf</code>：</p><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p><p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h2 id="为什么用Redis而不用本地缓存呢"><a href="#为什么用Redis而不用本地缓存呢" class="headerlink" title="为什么用Redis而不用本地缓存呢"></a>为什么用Redis而不用本地缓存呢</h2><p><strong>本地缓存</strong>是指将数据存储在本地应用程序或服务器上，通常用于加速数据访问和提高响应速度。</p><p>(1)数据一致性</p><p>Redis -&gt; 数据一致</p><p>本地缓存 -&gt; 多服务器同时部署时存在数据不一致问题</p><p>(2)内存限制</p><p>Redis -&gt; 独立部署,内存空间更大</p><p>本地缓存 -&gt; 受限于单台服务器内存</p><p>(3)数据丢失风险</p><p>Redis -&gt; 可持久化,数据不易丢失</p><p>本地缓存 -&gt; 服务器宕机数据丢失</p><p>(4)管理维护</p><p>Redis -&gt; 集中管理, 提供丰富的管理工具</p><p>本地缓存 -&gt; 分散,管理不便</p><p>(5)拓展功能丰富</p><p>Redis -&gt; 功能丰富,支持多种数据结构以功能</p><p>本地缓存 -&gt; 功能有限,通常只支持简单的键值对存储.</p><h1 id="键值对数据库是怎么实现的？"><a href="#键值对数据库是怎么实现的？" class="headerlink" title="键值对数据库是怎么实现的？"></a>键值对数据库是怎么实现的？</h1><p>在开始讲数据结构之前，先给介绍下 Redis 是怎样实现键值对（key-value）数据库的。</p><p>Redis 的键值对中的 key 就是字符串对象，而 <strong>value 可以是字符串对象，也可以是集合数据类型的对象</strong>，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。</p><p>举个例子，我这里列出几种 Redis 新增键值对的命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt; SET name &quot;xiaolincoding&quot;<br>OK<br><br>&gt; HSET person name &quot;xiaolincoding&quot; age 18<br>0<br><br>&gt; RPUSH stu &quot;xiaolin&quot; &quot;xiaomei&quot;<br>(integer) 4<br></code></pre></td></tr></table></figure><p>这些命令代表着：</p><ul><li>第一条命令：name 是一个<strong>字符串键</strong>，因为键的<strong>值是一个字符串对象</strong>；</li><li>第二条命令：person 是一个<strong>哈希表键</strong>，因为键的<strong>值是一个包含两个键值对的哈希表对象</strong>；</li><li>第三条命令：stu 是一个<strong>列表键</strong>，因为键的<strong>值是一个包含两个元素的列表对象</strong>；</li></ul><p>这些键值对是如何保存在 Redis 中的呢？</p><p>Redis 是使用了一个「哈希表」保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p><p>Redis 的哈希桶是怎么保存键值对数据的呢？</p><p>哈希桶存放的是指向键值对数据的指针（dictEntry*），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void * key 和 void * value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void * value 指针找到。</p><h1 id="redis底层数据"><a href="#redis底层数据" class="headerlink" title="redis底层数据"></a>redis底层数据</h1><p>简单讲一下Redis的数据类型及应用场景</p><p>(1)数据类型String可存储字符串,整数,浮点数,支持直接读写,自增自减等</p><p>Hash存储键值对的无序散列表,可单独对某个键值对进行增删改查</p><p>List基于双向链表实现的有序数据结构,链表每个节点存储一个字符串,支持双端插入&#x2F;删除数据</p><p>Set存储不重复元素的无序集合,元素均为字符串,支持交集,并集,差集等</p><p>Zset在Set基础上为每个元素关联一个分数(score),通过分数对元素进行有序排序.</p><p>(2)应用场景基础类型</p><p>String -&gt; 缓存对象,常规计数,分布式锁,共享session信息等</p><p>List -&gt; 消息队列(生产者需要自行实现全局唯一ID)</p><p>Hash -&gt; 缓存对象,购物车等</p><p>Set -&gt; 聚合计算场景,比如点赞,共同关注,抽奖活动等</p><p>ZSet -&gt; 排序场景,如排行榜拓展类型</p><p>BitMap -&gt; 二进制状态统计场景,如用户登录状态,连续见到的用户总数</p><p>HyperLogLog-&gt;UV统计,用概率换空间</p><p>GEO-&gt; 地理位置存储</p><p>stream -&gt; 消息队列,自动生成全局唯一消息ID,支持以消费组形式消费.（难以解决堆积和丢失问题）</p><h2 id="String-是使用什么存储的-为什么不用-c-语言中的字符串"><a href="#String-是使用什么存储的-为什么不用-c-语言中的字符串" class="headerlink" title="String 是使用什么存储的?为什么不用 c 语言中的字符串?"></a><strong>String 是使用什么存储的?为什么不用 c 语言中的字符串?</strong></h2><p>Redis 的 String 字符串是用 SDS 数据结构存储的。</p><p>下图就是 Redis 5.0 的 SDS 的数据结构：</p><p><img src="/./../img/image-20240725232549832.png" alt="image-20240725232549832"></p><p>结构中的每个成员变量分别介绍下：</p><ul><li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</li><li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li><li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。</li></ul><table><thead><tr><th>类型</th><th>字节</th><th>位</th></tr></thead><tbody><tr><td>sdshdr5</td><td>&lt; 1</td><td>&lt;8</td></tr><tr><td>sdshdr8</td><td>1</td><td>8</td></tr><tr><td>sdshdr16</td><td>2</td><td>16</td></tr><tr><td>sdshdr32</td><td>4</td><td>32</td></tr><tr><td>sdshdr64</td><td>8</td><td>64</td></tr></tbody></table><ul><li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li></ul><p>比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p><p>SDS 相比于 C 语言中的字符串有如下提升：</p><ol><li><strong>可以避免缓冲区溢出</strong>：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li><li><strong>获取字符串长度的复杂度较低</strong>：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li><li><strong>减少内存分配次数</strong>：为了避免修改（增加&#x2F;减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li><li><strong>二进制安全</strong>：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li></ol><h2 id="List-类型的底层数据结构"><a href="#List-类型的底层数据结构" class="headerlink" title="List 类型的底层数据结构"></a>List 类型的底层数据结构</h2><p>是由<strong>双向链表或压缩列表</strong>实现的：</p><ul><li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>（7.0Listpack）</p><h2 id="Hash-类型的底层数据"><a href="#Hash-类型的底层数据" class="headerlink" title="Hash 类型的底层数据"></a>Hash 类型的底层数据</h2><p>结构是由<strong>压缩列表或哈希表</strong>实现的：</p><ul><li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li><li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p><p><strong>信息流展示</strong></p><ul><li>举例：最新文章、最新动态。</li><li>相关命令：<code>LPUSH</code>、<code>LRANGE</code>。</li></ul><h2 id="Set底层"><a href="#Set底层" class="headerlink" title="Set底层"></a>Set底层</h2><p>当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p><p><img src="/./../img/1755344031729-caab8f72-4605-475d-847a-95fe2a16cd19.webp" alt="image.png"></p><h2 id="Zset底层"><a href="#Zset底层" class="headerlink" title="Zset底层"></a>Zset底层</h2><p>Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。</p><p>*<em>Zset 的底层是 *<em>跳表（skiplist）+ 字典（dict）*</em>，但小 Zset 用压缩列表（ziplist）（listpack）节省内存</em>*</p><p><strong>“跳表负责有序遍历，字典负责快速查找”</strong> —— 两者互补，避免了纯跳表的 O(log N) 查找缺陷。</p><h3 id="Redis-的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者-B-树？"><a href="#Redis-的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者-B-树？" class="headerlink" title="Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+ 树？"></a>Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+ 树？</h3><table><thead><tr><th>维度</th><th>红黑树</th><th>跳表</th><th>为什么 Redis 选跳表</th></tr></thead><tbody><tr><td><strong>实现复杂度</strong></td><td>❌ 高（需处理旋转、颜色平衡）</td><td>✅ 低（仅需随机层数+指针）</td><td>Redis 代码库追求简洁，红黑树代码量是跳表的 <strong>3倍</strong>（实测：Redis ZSet 代码 150行 vs 红黑树 450+行）</td></tr><tr><td><strong>内存占用</strong></td><td>❌ 高（每个节点需额外存储颜色、父指针）</td><td>✅ 低（仅需 <code>value</code> + <code>forward</code> 指针）</td><td>跳表节点结构更紧凑，<strong>内存节省 20%+</strong>（Redis 10 万 ZSet 元素实测）</td></tr><tr><td><strong>性能</strong></td><td>⚠️ 最坏 O(log n)，但常数因子高</td><td>✅ 平均 O(log n)，常数因子低</td><td><strong>Redis 是单线程</strong>，跳表的随机性避免了红黑树的平衡开销，<strong>实际性能几乎一致</strong></td></tr></tbody></table><h3 id="Zset-的两种实现方式（精准条件）"><a href="#Zset-的两种实现方式（精准条件）" class="headerlink" title="Zset 的两种实现方式（精准条件）"></a>Zset 的两种实现方式（精准条件）</h3><table><thead><tr><th>条件</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>元素数量</td><td>≤ <code>zset-max-ziplist-entries</code></td><td><strong>128</strong></td></tr><tr><td>成员长度</td><td>≤ <code>zset-max-ziplist-value</code></td><td><strong>64 字节</strong></td></tr><tr><td>分数长度</td><td>≤ <code>zset-max-ziplist-value</code></td><td><strong>64 字节</strong></td></tr></tbody></table><p>为什么用 ziplist？</p><ul><li><strong>内存占用</strong>：压缩列表是连续内存块，无指针开销（比跳表节省 30%+ 内存）</li><li><strong>适用场景</strong>：小规模 Zset（如用户标签、小范围排序）</li></ul><p>为什么 Zset 的 ziplist 不用普通压缩列表？ <strong>答</strong>：Zset 的 ziplist <strong>专门设计</strong>，将成员和分数交替存储（<code>member, score, member, score</code>），避免了普通 ziplist 的遍历问题。</p><p>✅ <strong>跳表（skiplist）+ 字典实现</strong>（大 Zset 主流）</p><p><strong>为什么需要字典？</strong><br> <strong>“跳表只能按分数排序，但无法快速查成员！”</strong><br> 例如：<code>ZRANGEBYSCORE</code> 用跳表，<code>ZSCORE</code> 用字典 → O(1) 查找。</p><h2 id="Hash底层"><a href="#Hash底层" class="headerlink" title="Hash底层"></a><strong>Hash底层</strong></h2><h2 id="Hash的存储机制：两种实现方式"><a href="#Hash的存储机制：两种实现方式" class="headerlink" title="Hash的存储机制：两种实现方式"></a>Hash的存储机制：两种实现方式</h2><h3 id="1-压缩列表（ziplist）实现（内存优化）"><a href="#1-压缩列表（ziplist）实现（内存优化）" class="headerlink" title="1. 压缩列表（ziplist）实现（内存优化）"></a>1. 压缩列表（ziplist）实现（内存优化）</h3><p>当Hash满足以下条件时，Redis会使用**压缩列表（ziplist）**存储：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">hash</span>-<span class="hljs-built_in">max</span>-ziplist-entries <span class="hljs-number">512</span>  <span class="hljs-comment"># 元素数量阈值（默认512）</span><br><span class="hljs-built_in">hash</span>-<span class="hljs-built_in">max</span>-ziplist-value <span class="hljs-number">64</span>     <span class="hljs-comment"># 单个键/值长度阈值（默认64字节）</span><br></code></pre></td></tr></table></figure><h4 id="为什么用ziplist？"><a href="#为什么用ziplist？" class="headerlink" title="为什么用ziplist？"></a>为什么用ziplist？</h4><ul><li><strong>内存占用低</strong>：压缩列表是连续内存块，没有指针开销</li><li><strong>适用场景</strong>：小Hash（元素少+键值小）</li></ul><h4 id="ziplist结构（简要）"><a href="#ziplist结构（简要）" class="headerlink" title="ziplist结构（简要）"></a>ziplist结构（简要）</h4><ul><li><code>entry</code>包含：<code>prevlen</code>（前节点长度）、<code>encoding</code>（类型+长度）、<code>data</code>（实际数据）</li></ul><hr><h3 id="2-哈希表（hashtable）实现（性能优先）"><a href="#2-哈希表（hashtable）实现（性能优先）" class="headerlink" title="2. 哈希表（hashtable）实现（性能优先）"></a>2. 哈希表（hashtable）实现（性能优先）</h3><p>当Hash超过上述阈值时，Redis会<strong>自动转换为哈希表</strong>实现。</p><h4 id="哈希表核心机制"><a href="#哈希表核心机制" class="headerlink" title="哈希表核心机制"></a>哈希表核心机制</h4><ol><li><strong>哈希函数</strong>：使用MurmurHash2算法（高效、低冲突）</li><li><strong>冲突解决</strong>：链地址法（每个桶维护一个链表）</li><li>动态扩容：<ul><li>当<code>used / size &gt; 0.7</code>时扩容（负载因子）</li><li>扩容为当前大小的2倍（如4→8→16→32…）</li><li><strong>增量式rehash</strong>：将数据逐步从ht[0]迁移到ht[1]</li></ul></li></ol><p><img src="/./../img/1baff6929e63428ab4ce6ead35657953.jpeg" alt="img"></p><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dict</span>&#123;<br><br><br><br>    dictType *type;<br><br><br><br>    <span class="hljs-type">void</span> *privdata;<br><br><br><br>    dictht ht[<span class="hljs-number">2</span>];<br><br><br><br>    <span class="hljs-type">long</span> rehashidx;<br><br><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> iterators;<br><br>&#125; dict;<br></code></pre></td></tr></table></figure><p>​    **ht[2]：**表示在一个Dict结构中，包含有两个dictht的结构，也就是我们说的两张哈希表。</p><p>​    **rehashidx：**是dict在rehash时的偏移索引，具体如何工作在后边的rehash过程中会详细讲。</p><h4 id="dictht"><a href="#dictht" class="headerlink" title="dictht"></a>dictht</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictht</span>&#123;<br>    dictEntry **table;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br><br>&#125;dictht<br><br></code></pre></td></tr></table></figure><p>​     ****table：<strong>指向实际hash存储。存储可以看做是一个数组，所以是*table表示。（源码中的</strong>table是一个二级指针，也就是指向dictEntry*的指针）。</p><p>​    **size：**哈希表的大小。实际就是dictEntry有多少元素空间。</p><p>​    **sizemask：**哈希表大小的掩码表示，总是等于size-1.这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面，索引计算规则是index&#x3D;hash&amp;sizemask，前提是size的大小是二次方幂，这一点与JAVA哈希表底层计算索引是一样的原理。</p><p>​    **used：**表示已经使用的节点数量。通过这个字段可以很方便地查询到目前dict元素总量。</p><h3 id="Q1：为什么Redis的Hash在底层用字典（dict）而不是直接用哈希表？"><a href="#Q1：为什么Redis的Hash在底层用字典（dict）而不是直接用哈希表？" class="headerlink" title="Q1：为什么Redis的Hash在底层用字典（dict）而不是直接用哈希表？"></a>Q1：为什么Redis的Hash在底层用字典（dict）而不是直接用哈希表？</h3><p><strong>答</strong>：字典（dict）是Redis对哈希表的<strong>封装</strong>，提供了以下关键能力：</p><ul><li>两个哈希表实现增量式rehash</li><li>类型特性函数（dictType）支持多种数据类型</li><li>迭代器支持</li><li>通过<code>privdata</code>传递私有数据</li></ul><blockquote><p>💡 <strong>加分点</strong>：可以补充”Redis的字典是高度可定制的，可以用于实现String、Hash、Set等不同数据结构。”</p></blockquote><hr><h3 id="Q2：Redis的Hash在什么情况下会从ziplist转换为hashtable？"><a href="#Q2：Redis的Hash在什么情况下会从ziplist转换为hashtable？" class="headerlink" title="Q2：Redis的Hash在什么情况下会从ziplist转换为hashtable？"></a>Q2：Redis的Hash在什么情况下会从ziplist转换为hashtable？</h3><p><strong>答</strong>：当满足以下任一条件时：</p><ol><li><code>hash-max-ziplist-entries</code>：Hash中元素数量超过阈值（默认512）</li><li><code>hash-max-ziplist-value</code>：某个字段名或值的长度超过阈值（默认64字节）</li></ol><blockquote><p>💡 <strong>面试官会追问</strong>：为什么设置这两个阈值？ <strong>答</strong>：为了在<strong>内存效率</strong>和<strong>操作性能</strong>之间取得平衡：</p><ul><li>小Hash：用ziplist节省内存</li><li>大Hash：用hashtable保证操作速度</li></ul></blockquote><hr><h3 id="Q3：Redis的哈希表扩容时，为什么是2倍扩容？"><a href="#Q3：Redis的哈希表扩容时，为什么是2倍扩容？" class="headerlink" title="Q3：Redis的哈希表扩容时，为什么是2倍扩容？"></a>Q3：Redis的哈希表扩容时，为什么是2倍扩容？</h3><p><strong>答</strong>：2倍扩容是<strong>经验法则</strong>：</p><ol><li>避免频繁扩容（如果扩容因子是1.5，会频繁触发扩容）</li><li>保证负载因子在合理范围（0.5-0.7）</li><li>简单且高效（2的幂次方，计算索引快）</li></ol><blockquote><p>💡 <strong>面试官会追问</strong>：为什么负载因子选0.7？ <strong>答</strong>：根据哈希表理论，负载因子在0.7左右时，链表长度平均为1.5-2，平衡了内存利用率和查询性能。</p></blockquote><p>“Redis的Hash底层用字典（dict）实现，字典基于哈希表+链地址法；小Hash用ziplist节省内存，大Hash用hashtable保证性能——通过两个哈希表实现增量式rehash，避免扩容卡顿，这是Redis性能与内存平衡的完美体现！”</p><h2 id="哈希表扩容"><a href="#哈希表扩容" class="headerlink" title="哈希表扩容"></a>哈希表扩容</h2><p>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p><ul><li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</li><li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li><li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li></ul><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>Redis 采用了<strong>渐进式 rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</p><p>举个例子，如果ht[0]中已经使用的节点数量为500，那么扩容时ht[1]被分配的空间是1024而不是1000。这么做是为了维护扩容后表的大小始终是2次方幂。</p><p>实现步骤</p><ol><li><strong>初始化新表与状态变量</strong> Redis 为 <em>ht[1]</em> 分配内存空间，并将 <em>rehashidx</em> 设置为 0，表示迁移开始。</li><li><strong>分批迁移数据</strong> 每次对字典执行增删改查操作时，除了完成用户请求，还会迁移 <em>ht[0]</em> 中 <em>rehashidx</em> 指向的哈希桶到 <em>ht[1]</em>。迁移完成后，<em>rehashidx</em> 加 1。</li><li><strong>主动迁移</strong> 为避免迁移因操作频率低而停滞，Redis 的定时任务会批量迁移多个哈希桶（如一次迁移 100 个）。</li><li><strong>读写操作适配双表</strong> 查询、删除、更新操作会先查找 <em>ht[1]</em>，再查找 <em>ht[0]</em>；新增操作只写入 <em>ht[1]</em>，避免旧表产生新数据。</li><li><strong>完成迁移</strong> 当 <em>rehashidx</em> 等于 <em>ht[0]</em> 的容量时，迁移完成。Redis 释放 <em>ht[0]</em> 的内存，将 <em>ht[1]</em> 赋值为 <em>ht[0]</em>，并重置 <em>ht[1]</em> 和 <em>rehashidx</em>。</li></ol><p>如果rehashidx刚好在一个已删除的空位置上，那么是直接返回还是尝试往下找？我们来看一下dictRehash函数的源码：</p><p>​    可以看到，答案是会继续往下去找，但是有个上限是n*10，即最多再找这么多次，n是传进来的参数，调用的时候实际值为1，即最多往后再找10个，这么做是防止因为连续碰到空位置导致主线程操作被阻塞。</p><h3 id="哈希表扩容的时候，有读请求怎么查？"><a href="#哈希表扩容的时候，有读请求怎么查？" class="headerlink" title="哈希表扩容的时候，有读请求怎么查？"></a>哈希表扩容的时候，有读请求怎么查？</h3><p>查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。</p><h2 id="介绍一下-Redis-中的-listpack"><a href="#介绍一下-Redis-中的-listpack" class="headerlink" title="介绍一下 Redis 中的 listpack"></a>介绍一下 Redis 中的 listpack</h2><p>quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。</p><p>因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。</p><p>于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p><p>我们先看看 listpack 结构：</p><p><img src="/./../img/1719035634188-584809ba-ea0b-48ff-a547-9ee4d1b4d365.png" alt="img"></p><p>listpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。</p><p>每个 listpack 节点结构如下：</p><p><img src="/./../img/1719035634415-c436d60e-58a7-4dfc-9e69-db8e2f96d19c.png" alt="img"></p><p>主要包含三个方面内容：</p><ul><li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li><li>data，实际存放的数据；</li><li>len，encoding+data的总长度；</li></ul><p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p><p><strong>Listpack 通过移除 <code>prevlen</code> 字段，让插入&#x2F;删除操作从 O(N) 变为 O(1)——它保留了 ziplist 的内存紧凑性，却彻底消灭了连锁更新，是 Redis 5.0 的最佳列表实现！</strong></p><h2 id="Listpack-vs-Ziplist：全面对比"><a href="#Listpack-vs-Ziplist：全面对比" class="headerlink" title="Listpack vs Ziplist：全面对比"></a>Listpack vs Ziplist：全面对比</h2><table><thead><tr><th>特性</th><th>Ziplist</th><th>Listpack</th><th>优势</th></tr></thead><tbody><tr><td><strong><code>prevlen</code> 字段</strong></td><td>✅ 存在</td><td>❌ <strong>不存在</strong></td><td>✅ <strong>彻底消除连锁更新</strong></td></tr><tr><td><strong>节点长度计算</strong></td><td>依赖 <code>prevlen</code></td><td>通过 <code>encoding</code></td><td>✅ 更高效</td></tr><tr><td><strong>插入&#x2F;删除复杂度</strong></td><td>O(N)</td><td><strong>O(1)</strong></td><td>✅ 大幅提升性能</td></tr><tr><td><strong>内存占用</strong></td><td>极低（小列表）</td><td><strong>略高但可忽略</strong></td><td>✅ 仍比普通链表节省 30%+</td></tr><tr><td><strong>最大元素数</strong></td><td>65535（需遍历）</td><td>255（用 <code>zsize</code> 计算）</td><td>✅ 无限制</td></tr><tr><td><strong>Redis 版本</strong></td><td>早期</td><td><strong>5.0+ 默认</strong></td><td>✅ 已成为标准</td></tr></tbody></table><h3 id="ziplist是怎么实现的？"><a href="#ziplist是怎么实现的？" class="headerlink" title="ziplist是怎么实现的？"></a>ziplist是怎么实现的？</h3><p>压缩列表是 Redis 为了节约内存而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组。</p><p><img src="/./../img/1720432496274-b95e1802-1ecd-4210-a987-733265534c64.png" alt="img"></p><p>压缩列表在表头有三个字段：</p><ul><li>*<strong>zlbytes*</strong>，记录整个压缩列表占用对内存字节数；</li><li>*<strong>zltail*</strong>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li><li>*<strong>zllen*</strong>，记录压缩列表包含的节点数量；</li><li>*<strong>zlend*</strong>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li></ul><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p><p>另外，压缩列表节点（entry）的构成如下：</p><p><img src="/./../img/1720432496229-46da5ac0-0e89-45cd-b1f8-151f7c6d4660.png" alt="img"></p><p>压缩列表节点包含三部分内容：</p><ul><li><strong>prevlen</strong>，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；</li><li><strong>encoding</strong>，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。</li><li><strong>data</strong>，记录了当前节点的实际数据，类型和长度都由 encoding 决定；</li></ul><p>当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</strong>。</p><p>为什么ziplist能节省内存？ <strong>答</strong>：通过动态编码（如整数直接存储，字符串用长度编码），避免了字符串的额外长度存储，内存占用比普通哈希表低30%+。</p><p>压缩列表的缺点是会发生连锁更新的问题，因此<strong>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong>。</p><p>所以说，<strong>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题</strong>。</p><p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p><h3 id="Redis为什么使用跳表而不是用B-树"><a href="#Redis为什么使用跳表而不是用B-树" class="headerlink" title="Redis为什么使用跳表而不是用B+树?"></a>Redis为什么使用跳表而不是用B+树?</h3><p>Redis 是内存数据库，<strong>跳表在实现简单性、写入性能、内存访问模式等方面的综合优势</strong>，使其成为更合适的选择。</p><table><thead><tr><th align="left">维度</th><th align="left">跳表优势</th><th align="left">B+ 树劣势</th></tr></thead><tbody><tr><td align="left"><strong>内存访问</strong></td><td align="left">符合CPU缓存局部性，指针跳转更高效</td><td align="left">节点结构复杂，缓存不友好</td></tr><tr><td align="left"><strong>实现复杂度</strong></td><td align="left">代码简洁，无复杂平衡操作</td><td align="left">节点分裂&#x2F;合并逻辑复杂，代码量大</td></tr><tr><td align="left"><strong>写入性能</strong></td><td align="left">插入&#x2F;删除仅需调整局部指针</td><td align="left">插入可能触发递归节点分裂，成本高</td></tr><tr><td align="left"><strong>内存占用</strong></td><td align="left">结构紧凑，无内部碎片</td><td align="left">节点预分配可能浪费内存</td></tr></tbody></table><ul><li><strong>锁竞争</strong>：在并发环境下，B+ 树的锁粒度较粗（如页锁），容易成为性能瓶颈。</li><li><strong>细粒度锁或无锁</strong>：跳表可以通过分段锁或无锁结构（如 CAS）实现高效并发。</li></ul><p>Redis 选择使用跳表<strong>锁竞争</strong>：在并发环境下，B+ 树的锁粒度较粗（如页锁），容易成为性能瓶颈。（Skip List）而不是 B+ 树来实现有序集合（Sorted Set）等数据结构，是经过多方面权衡后的结果。</p><h3 id="跳表是怎么实现的？"><a href="#跳表是怎么实现的？" class="headerlink" title="跳表是怎么实现的？"></a>跳表是怎么实现的？</h3><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p><p>那跳表长什么样呢？我这里举个例子，下图展示了一个层级为 3 的跳表。</p><p><img src="/./../img/1719804939236-89f12a47-b851-4d06-a5f3-399e1119db57.png" alt="img"></p><p>图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：</p><ul><li>L0 层级共有 5 个节点，分别是节点1、2、3、4、5；</li><li>L1 层级共有 3 个节点，分别是节点 2、3、5；</li><li>L2 层级只有 1 个节点，也就是节点 3 。</li></ul><p>如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。</p><p>可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。</p><p>那跳表节点是怎么实现多层级的呢？这就需要看「跳表节点」的数据结构了，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    <span class="hljs-comment">//Zset 对象的元素值</span><br>    sds ele;<br>    <span class="hljs-comment">//元素权重值</span><br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-comment">//后向指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br>  <br>    <span class="hljs-comment">//节点的level数组，保存每层上的前向指针和跨度</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;<br>    &#125; level[];<br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><p>Zset 对象要同时保存「元素」和「元素的权重」，对应到跳表节点结构里就是 sds 类型的 ele 变量和 double 类型的 score 变量。每个跳表节点都有一个后向指针（struct zskiplistNode *backward），指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</p><p>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的<strong>zskiplistLevel 结构体类型的 level 数组</strong>。</p><p>level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。</p><p>比如，下面这张图，展示了各个节点的跨度。</p><p><img src="/./../img/1719804939577-56390d43-28b7-4d20-accf-55c79a53142e.png" alt="img"></p><p>第一眼看到跨度的时候，以为是遍历操作有关，实际上并没有任何关系，遍历操作只需要用前向指针（struct zskiplistNode *forward）就可以完成了。</p><p>Redis <strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p><p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p><p>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</p><p>虽然我前面讲解跳表的时候，图中的跳表的「头节点」都是 3 层高，但是其实<strong>如果层高最大限制是 64，那么在创建跳表「头节点」的时候，就会直接创建 64 层高的头节点</strong>。</p><h1 id="数据结构场景"><a href="#数据结构场景" class="headerlink" title="数据结构场景"></a>数据结构场景</h1><ul><li>在绝大多数情况下，<strong>String</strong> 更适合存储对象数据，尤其是当对象结构简单且整体读写是主要操作时。</li><li>如果你需要频繁操作对象的部分字段或节省内存，<strong>Hash</strong> 可能是更好的选择。</li></ul><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p><ul><li>用户 id 为 key</li><li>商品 id 为 field，商品数量为 value</li></ul><p><code>Set</code> 的常见应用场景如下：</p><ul><li>存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code> 更适合一些）、文章点赞、动态点赞等等。</li><li>需要获取多个数据源交集、并集和差集的场景：共同好友（交集）、共同粉丝（交集）、共同关注（交集）、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集）等等。</li><li>需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。</li></ul><h3 id="使用-Set-实现抽奖系统怎么做？"><a href="#使用-Set-实现抽奖系统怎么做？" class="headerlink" title="[使用 Set 实现抽奖系统怎么做？]"></a>[使用 Set 实现抽奖系统怎么做？]</h3><p>如果想要使用 <code>Set</code> 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：</p><ul><li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li><li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li><li><code>SRANDMEMBER key count</code>：随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li></ul><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24分库分表和冷热分离</title>
    <link href="/2025/11/16/24%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/"/>
    <url>/2025/11/16/24%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="第01章-高性能架构模式"><a href="#第01章-高性能架构模式" class="headerlink" title="第01章 高性能架构模式"></a>第01章 高性能架构模式</h1><p>互联网业务兴起之后，海量用户加上海量数据的特点，单个数据库服务器已经难以满足业务需要，必须考虑数据库集群的方式来提升性能。</p><p>高性能数据库集群的：</p><p>1、第一种方式是**“读写分离”**</p><p>2、第二种方式是**“数据库分片”**。</p><p><a href="https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E8%A1%A8">读写分离和分库分表详解 | JavaGuide</a></p><h2 id="1-读写分离架构"><a href="#1-读写分离架构" class="headerlink" title="1 读写分离架构"></a>1 读写分离架构</h2><p><strong>读写分离原理：</strong> 读写分离的基本原理是将数据库读写操作分散到不同的节点上，下面是其基本架构图：</p><p><strong>读写分离的基本实现：</strong></p><ul><li><p>主库负责处理事务性的增删改操作，从库负责处理查询操作，能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。</p></li><li><p>读写分离是根据 SQL 语义的分析，将读操作和写操作分别路由至主库与从库。</p></li><li><p>通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。</p></li><li><p>使用多主多从的方式，不但能够提升系统的吞吐量，还能够提升系统的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。</p></li></ul><p><strong>下图展示了根据业务需要，将用户表的写操作和读操路由到不同的数据库的方案：</strong></p><h2 id="2-数据库分片架构"><a href="#2-数据库分片架构" class="headerlink" title="2 数据库分片架构"></a>2 数据库分片架构</h2><p><strong>读写分离的问题：</strong></p><p>读写分离分散了数据库读写操作的压力，但没有分散存储压力，为了满足业务数据存储的需求，就需要<strong>将存储分散到多台数据库服务器上</strong>。</p><p><strong>数据分片：</strong></p><p>将存放在单一数据库中的数据分散地存放至多个数据库或表中，以达到提升性能瓶颈以及可用性的效果。 数据分片的有效手段是对关系型数据库进行<strong>分库和分表</strong>。数据分片的拆分方式又分为<strong>垂直分片和水平分片</strong>。</p><h3 id="2-1-垂直分片"><a href="#2-1-垂直分片" class="headerlink" title="2.1 垂直分片"></a>2.1 垂直分片</h3><p><strong>垂直分库：</strong></p><p>按照业务拆分的方式称为垂直分片，又称为纵向拆分，它的核心理念是<strong>专库专用</strong>。 在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是按照业务<strong>将表进行归类，分布到不同的数据库</strong>中，从而将压力分散至不同的数据库。</p><p>垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分之后，<strong>表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理。</strong></p><p><strong>垂直分表：</strong></p><p><strong>垂直分表适合将表中某些不常用的列，或者是占了大量空间的列拆分出去。</strong></p><p>假设我们是一个婚恋网站，用户在筛选其他用户的时候，主要是用 age 和 sex 两个字段进行查询，而 nickname 和 description 两个字段主要用于展示，一般不会在业务查询中用到。description 本身又比较长，因此我们可以将这两个字段独立到另外一张表中，这样在查询 age 和 sex 时，就能带来一定的性能提升。</p><p>垂直分表引入的复杂性主要体现在表操作的数量要增加。例如，原来只要一次查询就可以获取 name、age、sex、nickname、description，现在需要两次查询，一次查询获取 name、age、sex，另外一次查询获取 nickname、description。</p><h3 id="2-2-水平分片"><a href="#2-2-水平分片" class="headerlink" title="2.2 水平分片"></a>2.2 水平分片</h3><p>水平分片又称为横向拆分。 相对于垂直分片，它不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将<strong>数据</strong>分散至多个库或表中**，**每个分片仅包含数据的一部分。 例如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表），如下图所示。</p><blockquote><p><strong>阿里巴巴Java开发手册：</strong><br>【推荐】单表行数超过 <strong>500 万行</strong>或者单表容量<strong>超过 2GB</strong>，才推荐进行分库分表。<br>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></blockquote><h2 id="3-实现方式"><a href="#3-实现方式" class="headerlink" title="3 实现方式"></a>3 实现方式</h2><p>Apache ShardingSphere（程序级别和中间件级别）</p><p>MyCat（数据库中间件）</p><h1 id="第02章-ShardingSphere"><a href="#第02章-ShardingSphere" class="headerlink" title="第02章 ShardingSphere"></a>第02章 ShardingSphere</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>官网：<a href="https://shardingsphere.apache.org/index_zh.html">https://shardingsphere.apache.org/index_zh.html</a></p><p>文档：<a href="https://shardingsphere.apache.org/document/5.1.1/cn/overview/" title="https:&#x2F;&#x2F;shardingsphere.apache.org&#x2F;document&#x2F;5.1.1&#x2F;cn&#x2F;overview&#x2F;">https://shardingsphere.apache.org/document/5.1.1/cn/overview/</a></p><p>Apache ShardingSphere 由 JDBC、Proxy 和 Sidecar（规划中）这 3 款既能够独立部署，又支持混合部署配合使用的产品组成。</p><h2 id="2、ShardingSphere-JDBC"><a href="#2、ShardingSphere-JDBC" class="headerlink" title="2、ShardingSphere-JDBC"></a>2、ShardingSphere-JDBC</h2><p><strong>程序代码封装</strong></p><p>定位为轻量级 Java 框架，<strong>在 Java 的 JDBC 层提供的额外服务</strong>。 它使用客户端直连数据库，<strong>以 jar 包形式提供服务</strong>，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p><h2 id="3、ShardingSphere-Proxy"><a href="#3、ShardingSphere-Proxy" class="headerlink" title="3、ShardingSphere-Proxy"></a>3、ShardingSphere-Proxy</h2><p><strong>中间件封装</strong></p><p>定位为透明化的<strong>数据库代理端</strong>，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持。 目前提供 MySQL 和 PostgreSQL版本，它可以使用任何兼容 MySQL&#x2F;PostgreSQL 协议的访问客户端（如：MySQL Command Client, MySQL Workbench, Navicat 等）操作数据，对 DBA 更加友好。</p><h1 id="第03章-MySQL主从同步"><a href="#第03章-MySQL主从同步" class="headerlink" title="第03章 MySQL主从同步"></a>第03章 MySQL主从同步</h1><h2 id="一、Binlog基础"><a href="#一、Binlog基础" class="headerlink" title="一、Binlog基础"></a>一、Binlog基础</h2><h3 id="1-什么是Binlog"><a href="#1-什么是Binlog" class="headerlink" title="1. 什么是Binlog"></a>1. 什么是Binlog</h3><p>Binlog（Binary Log）是MySQL Server层生成的二进制日志，<strong>记录了数据库中所有对数据的修改操作</strong>，包括INSERT、UPDATE、DELETE等DML操作，以及CREATE、ALTER等DDL操作。MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件，</p><p>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志，用于备份恢复、主从复制；</p><h3 id="2-Binlog的三种格式"><a href="#2-Binlog的三种格式" class="headerlink" title="2. Binlog的三种格式"></a>2. Binlog的三种格式</h3><table><thead><tr><th>格式</th><th>说明</th><th>适用场景</th><th>优缺点</th></tr></thead><tbody><tr><td><strong>STATEMENT</strong></td><td>记录执行的SQL语句</td><td>简单操作、不涉及函数</td><td>优点：日志文件小；缺点：某些函数可能导致主从不一致</td></tr><tr><td><strong>ROW</strong></td><td>记录数据行的变化（修改前后的值）</td><td>涉及函数、存储过程、非确定性操作</td><td>优点：数据一致性好；缺点：日志文件大</td></tr><tr><td><strong>MIXED</strong></td><td>自动选择STATEMENT或ROW</td><td>大多数场景</td><td>优点：灵活；缺点：复杂</td></tr></tbody></table><h3 id="3-Binlog的关键作用"><a href="#3-Binlog的关键作用" class="headerlink" title="3. Binlog的关键作用"></a>3. Binlog的关键作用</h3><ul><li><strong>数据备份与恢复</strong>：通过binlog可以将数据库恢复到特定时间点</li><li><strong>主从复制</strong>：主服务器将binlog同步到从服务器，实现数据一致性</li><li><strong>数据审计</strong>：提供数据库操作历史的详尽记录</li><li><strong>数据同步</strong>：支持多级复制、级联复制等架构</li></ul><h2 id="二、MySQL主从复制原理"><a href="#二、MySQL主从复制原理" class="headerlink" title="二、MySQL主从复制原理"></a>二、MySQL主从复制原理</h2><h3 id="1-核心原理"><a href="#1-核心原理" class="headerlink" title="1. 核心原理"></a>1. 核心原理</h3><p>主从复制是基于<strong>二进制日志</strong>的机制，实现数据从主服务器（Master）到从服务器（Slave）的同步。整个过程依赖于”三个线程”和”两种日志”：</p><p><strong>三个线程</strong>：</p><ol><li><strong>Binlog Dump线程</strong>（主服务器）：负责读取主服务器的binlog并发送给从服务器</li><li><strong>I&#x2F;O Thread</strong>（从服务器）：从主服务器获取binlog并写入中继日志（relay log）</li><li><strong>SQL Thread</strong>（从服务器）：执行relay log中的操作，实现数据同步</li></ol><p><strong>两种日志</strong>：</p><ol><li><strong>binlog</strong>（主服务器）：真实业务操作的”事实记录”</li><li><strong>relay log</strong>（从服务器）：从服务器本地的缓存日志，用来重放</li></ol><blockquote><p>📌 <strong>关键点</strong>：主库commit &#x3D; binlog写成功。这意味着binlog是主库事务成功的唯一证据。</p></blockquote><h2 id="1、MySQL主从同步原理"><a href="#1、MySQL主从同步原理" class="headerlink" title="1、MySQL主从同步原理"></a>1、MySQL主从同步原理</h2><p><img src="/./../img/image-20251116203009108.png" alt="image-20251116203009108"></p><p><strong>基本原理：</strong></p><p>slave会从master读取binlog来进行数据同步</p><p>MySQL的二进制日志（Binary Log，简称Binlog）是MySQL数据库引擎提供的一种记录数据库变更的日志文件。它记录了对MySQL数据库进行的所有写操作，包括插入、更新、删除等，但不包括查询操作</p><p><strong>具体步骤：</strong></p><ul><li><p>step1：master将数据改变记录到二进制日志（binary log）中。</p></li><li><p>step2：当slave上执行 start slave 命令之后，slave会创建一个IO 线程用来连接master，请求master中的binlog。</p></li><li><p>step3：当slave连接master时，master会创建一个 log dump 线程，用于发送 binlog 的内容。在读取 binlog 的内容的操作中，会对主节点上的 binlog 加锁，当读取完成并发送给从服务器后解锁。</p></li><li><p>step4：IO 线程接收主节点 binlog dump 进程发来的更新之后，保存到 中继日志（relay log） 中。</p></li><li><p>step5：slave的SQL线程，读取relay log日志，并解析成具体操作，从而实现主从操作一致，最终数据一致。</p></li></ul><h2 id="2-一主多从配置"><a href="#2-一主多从配置" class="headerlink" title="2 一主多从配置"></a>2 一主多从配置</h2><p>服务器规划：使用docker方式创建，主从服务器IP一致，端口号不一致 三个服务器都有相同的数据库db_user</p><ul><li>主服务器：容器名<code>fy-mysql-master</code>，端口<code>3309</code></li><li>从服务器：容器名<code>fy-mysql-slave1</code>，端口<code>3307</code></li><li>从服务器：容器名<code>fy-mysql-slave2</code>，端口<code>3308</code></li></ul><p><strong>注意：</strong> 如果此时防火墙是开启的，<code>则先关闭防火墙，并重启docker</code>，否则后续安装的MySQL无法启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#关闭docker</span><br>systemctl stop docker<br><span class="hljs-comment">#关闭防火墙</span><br>systemctl stop firewalld<br><span class="hljs-comment">#启动docker</span><br>systemctl start docker<br></code></pre></td></tr></table></figure><h3 id="2-1-准备主服务器-已完成"><a href="#2-1-准备主服务器-已完成" class="headerlink" title="2.1 准备主服务器(已完成)"></a>2.1 准备主服务器(已完成)</h3><ul><li><p><strong>step1：在docker中创建并启动MySQL主服务器：</strong><code>端口3309</code></p><p>就用之前搭建好的fy-mysql8</p></li><li><p><strong>step2：创建MySQL主服务器配置文件：</strong></p></li></ul><p>默认情况下MySQL的binlog日志是自动开启的，可以通过如下配置定义一些可选配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/lib/docker/volumes/mysql8_conf/_data/<br></code></pre></td></tr></table></figure><p>配置如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[mysqld]<br>server-id=1<br>log-bin=mysql-bin<br>binlog-ignore-db=mysql<br>binlog-ignore-db=infomation_schema<br>binlog-ignore-db=performance_schema<br>binlog-ignore-db=sys<br><br>binlog_format=ROW<br></code></pre></td></tr></table></figure><p>重启MySQL容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker restart fy-mysql8<br></code></pre></td></tr></table></figure><p>binlog格式说明：</p><ul><li><p>binlog_format&#x3D;STATEMENT：日志记录的是主机数据库的<code>写指令</code>，性能高，但是now()之类的函数以及获取系统参数的操作会出现主从数据不同步的问题。</p></li><li><p>binlog_format&#x3D;ROW（默认）：日志记录的是主机数据库的<code>写后的数据</code>，批量操作时性能较差，解决now()或者  user()或者  @@hostname 等操作在主从机器上不一致的问题。</p></li><li><p>binlog_format&#x3D;MIXED：是以上两种level的混合使用，有函数用ROW，没函数用STATEMENT，但是无法识别系统变量</p></li><li><p><strong>step3：主机中查询master状态：</strong></p></li></ul><p>执行完此步骤后<code>不要再操作主服务器MYSQL</code>，防止主服务器状态值变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#进入容器：env LANG=C.UTF-8 避免容器中显示中文乱码<br>docker exec -it fy-mysql8  /bin/bash<br><br>#进入容器内的mysql命令行<br>mysql -uroot -p1234<br>#修改默认密码校验方式<br>ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;1234&#x27;;<br>flush privileges;<br><br># 查询master阶段的状态<br>SHOW MASTER STATUS;<br></code></pre></td></tr></table></figure><p>记下<code>File</code>和<code>Position</code>的值。执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化。</p><h3 id="2-2-准备从服务器"><a href="#2-2-准备从服务器" class="headerlink" title="2.2 准备从服务器"></a>2.2 准备从服务器</h3><p>可以配置多台从机slave1、slave2…，这里以配置slave1为例</p><ul><li><strong>step1：在docker中创建并启动MySQL从服务器：</strong><code>端口3307</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 3307 slave01  先把slave01的配置都配好之后,再进行slave02的配置</span><br>docker run -d \<br>-p 3307:3306 \<br>-v mysql02_conf:/etc/mysql/conf.d \<br>-v mysql02_data:/var/lib/mysql \<br>-e MYSQL_ROOT_PASSWORD=1234 \<br>--name slave01 \<br>mysql:8.0.30<br><span class="hljs-comment"># 3308 slave02  slave01配置之后,同样的流程进行slave02的配置</span><br>docker run -d \<br>-p 3308:3306 \<br>-v mysql03_conf:/etc/mysql/conf.d \<br>-v mysql03_data:/var/lib/mysql \<br>-e MYSQL_ROOT_PASSWORD=1234 \<br>--name slave02 \<br>mysql:8.0.30<br></code></pre></td></tr></table></figure><ul><li><strong>step2：创建MySQL从服务器配置文件：</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/lib/docker/volumes/mysql02_conf/_data/<br><span class="hljs-built_in">touch</span> my.cnf<br></code></pre></td></tr></table></figure><p>配置如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[mysqld]<br>server-id=2<br>relay-log=mysql-relay<br></code></pre></td></tr></table></figure><p>重启MySQL容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker restart slave01<br></code></pre></td></tr></table></figure><ul><li><strong>step3：在从机上配置主从关系：</strong></li></ul><p>在<strong>从机</strong>上执行以下SQL操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">进入容器：</span><br>docker exec -it slave01  /bin/bash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">进入容器内的mysql命令行</span><br>mysql -uroot -p1234<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">修改默认密码校验方式</span><br>ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;1234&#x27;;<br>flush privileges;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭从节点服务</span><br>stop slave;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置主节点</span><br>CHANGE MASTER TO MASTER_HOST=&#x27;192.168.10.22&#x27;,MASTER_USER=&#x27;root&#x27;,MASTER_PASSWORD=&#x27;1234&#x27;,MASTER_PORT=3309,MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,MASTER_LOG_POS=606;<br></code></pre></td></tr></table></figure><h3 id="2-3-启动主从同步"><a href="#2-3-启动主从同步" class="headerlink" title="2.3 启动主从同步"></a>2.3 启动主从同步</h3><p>启动从机的复制功能，执行SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> SLAVE;<br><br><span class="hljs-comment">-- 查看状态（不需要分号）</span><br><span class="hljs-keyword">SHOW</span> SLAVE STATUS\G<br></code></pre></td></tr></table></figure><p><strong>两个关键进程：</strong> 下面两个参数都是Yes，则说明主从配置成功！</p><h3 id="2-4-停止和重置"><a href="#2-4-停止和重置" class="headerlink" title="2.4 停止和重置"></a>2.4 停止和重置</h3><p>需要的时候，可以使用如下SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 在从机上执行。功能说明：停止I/O 线程和SQL线程的操作。</span><br>stop slave; <br><br><span class="hljs-comment">-- 在从机上执行。功能说明：用于删除SLAVE数据库的relaylog日志文件，并重新启用新的relaylog文件。</span><br>reset slave;<br><br><span class="hljs-comment">-- 在主机上执行。功能说明：删除所有的binglog日志文件，并将日志索引文件清空，重新开始所有新的日志文件。</span><br><span class="hljs-comment">-- 用于第一次进行搭建主从库时，进行主库binlog初始化工作；</span><br>reset master;<br></code></pre></td></tr></table></figure><h3 id="2-5-常见问题"><a href="#2-5-常见问题" class="headerlink" title="2.5 常见问题"></a><strong>2.5 常见问题</strong></h3><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>启动主从同步后，常见错误是<code>Slave_IO_Running： No 或者 Connecting</code> 的情况，此时查看下方的 <code>Last_IO_ERROR</code>错误日志，根据日志中显示</p><p>的错误信息在网上搜索解决方案即可</p><p><strong>典型的错误例如：</strong><code>Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: &#39;Client requested master to start replication from position &gt; file size&#39;</code></p><p><strong>解决方案：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 在从机停止slave</span><br>SLAVE STOP;<br><br><span class="hljs-comment">-- 在主机查看mater状态</span><br><span class="hljs-keyword">SHOW</span> MASTER STATUS;<br><br><span class="hljs-comment">-- 在主机刷新日志</span><br>FLUSH LOGS;<br><br><span class="hljs-comment">-- 再次在主机查看mater状态（会发现File和Position发生了变化）</span><br><br><span class="hljs-keyword">SHOW</span> MASTER STATUS;<br><br><span class="hljs-comment">-- 修改从机连接主机的SQL，并重新连接即可</span><br></code></pre></td></tr></table></figure><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>启动docker容器后提示 <code>WARNING: IPv4 forwarding is disabled. Networking will not work.</code></p><p>此错误，虽然不影响主从同步的搭建，但是如果想从远程客户端通过以下方式连接docker中的MySQL则没法连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\administrator&gt;mysql -h 192.168.10.22 -P 3306 -u root -p<br></code></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#修改配置文件：</span><br>vim /usr/lib/sysctl.d/00-system.conf<br><span class="hljs-comment">#追加</span><br>net.ipv4.ip_forward=1<br><span class="hljs-comment">#接着重启网络</span><br>systemctl restart network<br></code></pre></td></tr></table></figure><h3 id="2-6-测试实现主从同步"><a href="#2-6-测试实现主从同步" class="headerlink" title="2.6 测试实现主从同步"></a>2.6 测试实现主从同步</h3><p>在主机中执行以下SQL，在从机中查看数据库、表和数据是否已经被同步</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE db_user;<br>USE db_user;<br><span class="hljs-keyword">CREATE TABLE</span> t_user (<br> id <span class="hljs-type">BIGINT</span> AUTO_INCREMENT,<br> uname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>),<br> <span class="hljs-keyword">PRIMARY KEY</span> (id)<br>);<br><span class="hljs-keyword">INSERT INTO</span> t_user(uname) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;leifengyang&#x27;</span>);<br><span class="hljs-keyword">INSERT INTO</span> t_user(uname) <span class="hljs-keyword">VALUES</span>(@<span class="hljs-variable">@hostname</span>);<br></code></pre></td></tr></table></figure><h3 id="2-1-配置文件内容"><a href="#2-1-配置文件内容" class="headerlink" title="2.1 配置文件内容"></a>2.1 配置文件内容</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">shardingsphere:</span><br>    <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">names:</span> <span class="hljs-string">user,order0,order1</span><br>      <span class="hljs-attr">user:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>        <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>        <span class="hljs-attr">jdbcUrl:</span> <span class="hljs-string">jdbc:mysql://192.168.10.22:3301/db_user</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-number">1234</span><br>      <span class="hljs-attr">order0:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>        <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>        <span class="hljs-attr">jdbcUrl:</span> <span class="hljs-string">jdbc:mysql://192.168.10.22:3310/db_order</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-number">1234</span><br>      <span class="hljs-attr">order1:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>        <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>        <span class="hljs-attr">jdbcUrl:</span> <span class="hljs-string">jdbc:mysql://192.168.10.22:3311/db_order</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-number">1234</span><br>    <span class="hljs-attr">rules:</span><br>      <span class="hljs-attr">sharding:</span><br>        <span class="hljs-attr">tables:</span><br>          <span class="hljs-attr">t_user:</span><br>            <span class="hljs-attr">actualDataNodes:</span> <span class="hljs-string">user.t_user</span>  <span class="hljs-comment">#user是最上面数据源名称 必须一致</span><br>          <span class="hljs-attr">t_order:</span><br>            <span class="hljs-attr">actualDataNodes:</span> <span class="hljs-string">order0.t_order0,</span> <span class="hljs-string">order0.t_order1,order1.t_order0,order1.t_order1</span>    <span class="hljs-comment">#order0 order1是最上面数据源名称 必须一致</span><br>            <span class="hljs-attr">databaseStrategy:</span><br>              <span class="hljs-attr">standard:</span><br>                <span class="hljs-attr">shardingColumn:</span> <span class="hljs-string">user_id</span><br>                <span class="hljs-attr">shardingAlgorithmName:</span> <span class="hljs-string">order_bd_alg</span><br>            <span class="hljs-attr">tableStrategy:</span><br>              <span class="hljs-attr">standard:</span><br>                <span class="hljs-attr">sharding-column:</span> <span class="hljs-string">user_id</span><br>                <span class="hljs-attr">sharding-algorithm-name:</span> <span class="hljs-string">order_table_alg</span><br>        <span class="hljs-attr">sharding-algorithms:</span><br>          <span class="hljs-attr">order_bd_alg:</span><br>            <span class="hljs-attr">type:</span><br>              <span class="hljs-string">INLINE</span> <span class="hljs-comment">#分片算法一定要另起一行写</span><br>            <span class="hljs-attr">props:</span><br>              <span class="hljs-attr">algorithm-expression:</span> <span class="hljs-string">order$-&gt;&#123;user_id</span> <span class="hljs-string">%</span> <span class="hljs-number">2</span><span class="hljs-string">&#125;</span>  <span class="hljs-comment">#order是最上面数据源名称 必须一致</span><br>          <span class="hljs-attr">order_table_alg:</span><br>            <span class="hljs-attr">type:</span><br>              <span class="hljs-string">INLINE</span> <span class="hljs-comment">#分片算法一定要另起一行写</span><br>            <span class="hljs-attr">props:</span><br>              <span class="hljs-attr">algorithm-expression:</span> <span class="hljs-string">t_order$-&gt;&#123;user_id</span> <span class="hljs-string">%</span> <span class="hljs-number">2</span><span class="hljs-string">&#125;</span><br>    <span class="hljs-attr">props:</span> <span class="hljs-comment">#与rules对齐</span><br>      <span class="hljs-attr">sql-show:</span> <span class="hljs-literal">true</span><br><br></code></pre></td></tr></table></figure><p>为了防止订单号重复 需要先 修改Order实体类的主键策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@TableId(type = IdType.AUTO)//依赖数据库的主键自增策略</span><br><span class="hljs-meta">@TableId(type = IdType.ASSIGN_ID)</span><span class="hljs-comment">//分布式id</span><br></code></pre></td></tr></table></figure><p>测试：保留上面配置中的一个分片表节点分别进行测试，检查每个分片节点是否可用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 水平分片：插入数据测试</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsertOrder</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>    order.setOrderNo(<span class="hljs-string">&quot;leifengyang001&quot;</span>);<br>    order.setUserId(<span class="hljs-number">1L</span>);<br>    order.setAmount(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">100</span>));<br>    orderMapper.insert(order);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-行表达式"><a href="#2-3-行表达式" class="headerlink" title="2.3 行表达式"></a>2.3 行表达式</h3><p>优化上一步的分片表配置</p><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/features/sharding/concept/inline-expression/">https://shardingsphere.apache.org/document/5.1.1/cn/features/sharding/concept/inline-expression/</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">shardingsphere:</span><br><span class="hljs-attr">rules:</span><br>      <span class="hljs-attr">sharding:</span><br>        <span class="hljs-attr">tables:</span><br>          <span class="hljs-attr">t_user:</span><br>            <span class="hljs-attr">actual-data-nodes:</span> <span class="hljs-string">user.t_user</span><br>          <span class="hljs-attr">t_order:</span><br>            <span class="hljs-attr">actual-data-nodes:</span> <span class="hljs-string">order$&#123;0..1&#125;.t_order$&#123;0..1&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-分布式序列算法"><a href="#2-4-分布式序列算法" class="headerlink" title="2.4 分布式序列算法"></a>2.4 分布式序列算法</h3><p><strong>雪花算法：</strong></p><p><a href="https://shardingsphere.apache.org/document/5.1.1/cn/features/sharding/concept/key-generator/">https://shardingsphere.apache.org/document/5.1.1/cn/features/sharding/concept/key-generator/</a></p><p>水平分片需要关注全局序列，因为不能简单的使用基于数据库的主键自增。</p><p>分库分表以后表的主键字段就不能使用自增策略，因为可能出现重复数据。</p><p>分布式系统中的主键生成策略：</p><p>1、uuid</p><p>2、redis</p><p>3、雪花算法(shardingsphere：SnowflakeKeyGenerateAlgorithm)</p><p><a href="https://so.csdn.net/so/search?q=%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95&spm=1001.2101.3001.7020">雪花算法</a>是推特开源的分布式ID生成算法，用于在不同的机器上生成唯一的ID的算法。该算法生成一个64bit的数字作为分布式ID，保证这个ID自增</p><p>并且全局唯一。</p><p>生成的64位ID结构如下：</p><p>雪花算法是 64 位 的二进制，一共包含了四部分：</p><p>1、1位是符号位，也就是最高位，始终是0，没有任何意义，因为要是唯一计算机二进制补码中就是负数，0才是正数。</p><p>2、41位是时间戳，具体到毫秒，41位的二进制可以使用69年，如果时间计算基准年为1970年，那么到2039年就不能再用了，当前也可以指定一个基准年。</p><p>3、10位是机器标识，可以全部用作机器ID，也可以用来标识机房ID + 机器ID，10位最多可以表示1024台机器。</p><p>4、12位是计数序列号，也就是同一台机器上同一时间，理论上还可以同时生成不同的ID，12位的序列号能够区分出4096个ID。</p><p>这里有两种方案：一种是基于MyBatisPlus的id策略；一种是ShardingSphere-JDBC的全局序列配置。</p><p><code>基于MyBatisPlus的id策略：</code>将Order类的id设置成如下形式: 以上演示就是基于此种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableId(type = IdType.ASSIGN_ID)</span><br><span class="hljs-keyword">private</span> Long id;<br></code></pre></td></tr></table></figure><p><code>基于ShardingSphere-JDBC的全局序列配置</code>：和前面的MyBatisPlus的策略二选一</p><p>我们在下一个多表关联案例中演示即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>    <span class="hljs-attr">rules:</span><br>      <span class="hljs-attr">sharding:</span><br>        <span class="hljs-attr">tables:</span><br>          <span class="hljs-attr">t_order:</span><br>            <span class="hljs-attr">key-generate-strategy:</span><br>              <span class="hljs-attr">column:</span> <span class="hljs-string">id</span><br>              <span class="hljs-attr">key-generator-name:</span> <span class="hljs-string">alg_snowflake</span><br>        <span class="hljs-attr">key-generators:</span><br>          <span class="hljs-attr">alg_snowflake:</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">SNOWFLAKE</span><br>    <span class="hljs-attr">props:</span><br>      <span class="hljs-attr">sql-show:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>此时，需要将实体类中的id策略修改成以下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当配置了shardingsphere-jdbc的分布式序列时，自动使用shardingsphere-jdbc的分布式序列</span><br><span class="hljs-comment">//当没有配置shardingsphere-jdbc的分布式序列时，自动依赖数据库的主键自增策略</span><br><span class="hljs-meta">@TableId(type = IdType.AUTO)</span><br></code></pre></td></tr></table></figure><h3 id="如何避免主从延迟？"><a href="#如何避免主从延迟？" class="headerlink" title="[如何避免主从延迟？]"></a>[如何避免主从延迟？]</h3><p>读写分离对于提升数据库的并发非常有效，但是，同时也会引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 <strong>主从同步延迟</strong> 。</p><p>如果我们的业务场景无法容忍主从同步延迟的话，应该如何避免呢（注意：我这里说的是避免而不是减少延迟）？</p><p>这里提供两种我知道的方案（能力有限，欢迎补充），你可以根据自己的业务场景参考一下。</p><h4 id="强制将读请求路由到主库处理"><a href="#强制将读请求路由到主库处理" class="headerlink" title="[强制将读请求路由到主库处理]"></a>[强制将读请求路由到主库处理]</h4><p>既然你从库的数据过期了，那我就直接从主库读取嘛！这种方案虽然会增加主库的压力，但是，实现起来比较简单，也是我了解到的使用最多的一种方式。</p><p>比如 <code>Sharding-JDBC</code> 就是采用的这种方案。通过使用 Sharding-JDBC 的 <code>HintManager</code> 分片键值管理器，我们可以强制使用主库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HintManager</span> <span class="hljs-variable">hintManager</span> <span class="hljs-operator">=</span> HintManager.getInstance();<br>hintManager.setMasterRouteOnly();<br><span class="hljs-comment">// 继续JDBC操作</span><br></code></pre></td></tr></table></figure><p>对于这种方案，你可以将那些必须获取最新数据的读请求都交给主库处理。</p><h4 id="延迟读取"><a href="#延迟读取" class="headerlink" title="[延迟读取]"></a>[延迟读取]</h4><p>还有一些朋友肯定会想既然主从同步存在延迟，那我就在延迟之后读取啊，比如主从同步延迟 0.5s,那我就 1s 之后再读取数据。这样多方便啊！方便是方便，但是也很扯淡。</p><p>不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，你可以在完成写请求之后，避免立即进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。</p><h4 id="总结"><a href="#总结" class="headerlink" title="[总结]"></a>[总结]</h4><p>关于如何避免主从延迟，我们这里介绍了两种方案。实际上，延迟读取这种方案没办法完全避免主从延迟，只能说可以减少出现延迟的概率而已，实际项目中一般不会使用。</p><p>总的来说，要想不出现延迟问题，一般还是要强制将那些必须获取最新数据的读请求都交给主库处理。如果你的项目的大部分业务场景对数据准确性要求不是那么高的话，这种方案还是可以选择的。</p><h3 id="什么情况下会出现主从延迟？如何尽量减少延迟？"><a href="#什么情况下会出现主从延迟？如何尽量减少延迟？" class="headerlink" title="[什么情况下会出现主从延迟？如何尽量减少延迟？]"></a>[什么情况下会出现主从延迟？如何尽量减少延迟？]</h3><p>MySQL 主从同步延时是指从库的数据落后于主库的数据，这种情况可能由以下两个原因造成：</p><ol><li>从库 I&#x2F;O 线程接收 binlog 的速度跟不上主库写入 binlog 的速度，导致从库 relay log 的数据滞后于主库 binlog 的数据；</li><li>从库 SQL 线程执行 relay log 的速度跟不上从库 I&#x2F;O 线程接收 binlog 的速度，导致从库的数据滞后于从库 relay log 的数据。</li></ol><p>那什么情况下会出现出从延迟呢？这里列举几种常见的情况：</p><ol><li><strong>从库机器性能比主库差</strong>：从库接收 binlog 并写入 relay log 以及执行 SQL 语句的速度会比较慢（也就是 T2-T1 和 T3-T2 的值会较大），进而导致延迟。解决方法是选择与主库一样规格或更高规格的机器作为从库，或者对从库进行性能优化，比如调整参数、增加缓存、使用 SSD 等。</li><li><strong>从库处理的读请求过多</strong>：从库需要执行主库的所有写操作，同时还要响应读请求，如果读请求过多，会占用从库的 CPU、内存、网络等资源，影响从库的复制效率（也就是 T2-T1 和 T3-T2 的值会较大，和前一种情况类似）。解决方法是引入缓存（推荐）、使用一主多从的架构，将读请求分散到不同的从库，或者使用其他系统来提供查询的能力，比如将 binlog 接入到 Hadoop、Elasticsearch 等系统中。</li><li><strong>大事务</strong>：运行时间比较长，长时间未提交的事务就可以称为大事务。由于大事务执行时间长，并且从库上的大事务会比主库上的大事务花费更多的时间和资源，因此非常容易造成主从延迟。解决办法是避免大批量修改数据，尽量分批进行。类似的情况还有执行时间较长的慢 SQL ，实际项目遇到慢 SQL 应该进行优化。</li><li><strong>网络延迟</strong>：如果主从之间的网络传输速度慢，或者出现丢包、抖动等问题，那么就会影响 binlog 的传输效率，导致从库延迟。解决方法是优化网络环境，比如提升带宽、降低延迟、增加稳定性等。</li><li><strong>单线程复制</strong>：MySQL5.5 及之前，只支持单线程复制。为了优化复制性能，MySQL 5.6 引入了 <strong>多线程复制</strong>，MySQL 5.7 还进一步完善了多线程复制。</li><li><strong>复制模式</strong>：MySQL 默认的复制是异步的，必然会存在延迟问题。全同步复制不存在延迟问题，但性能太差了。半同步复制是一种折中方案，相对于异步复制，半同步复制提高了数据的安全性，减少了主从延迟（还是有一定程度的延迟）。MySQL 5.5 开始，MySQL 以插件的形式支持 <strong>semi-sync 半同步复制</strong>。并且，MySQL 5.7 引入了 <strong>增强半同步复制</strong> 。</li></ol><h3 id="常见的分片算法有哪些"><a href="#常见的分片算法有哪些" class="headerlink" title="常见的分片算法有哪些"></a>常见的分片算法有哪些</h3><p>分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。</p><p>常见的分片算法有：</p><ul><li><strong>哈希分片</strong>：求指定分片键的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。哈希分片可以使每个表的数据分布相对均匀，但对动态伸缩（例如新增一个表或者库）不友好。</li><li><strong>范围分片</strong>：按照特定的范围区间（比如时间区间、ID 区间）来分配数据，比如 将 <code>id</code> 为 <code>1~299999</code> 的记录分到第一个表， <code>300000~599999</code> 的分到第二个表。范围分片适合需要经常进行范围查找且数据分布均匀的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）。</li><li><strong>映射表分片</strong>：使用一个单独的表（称为映射表）来存储分片键和分片位置的对应关系。映射表分片策略可以支持任何类型的分片算法，如哈希分片、范围分片等。映射表分片策略是可以灵活地调整分片规则，不需要修改应用程序代码或重新分布数据。不过，这种方式需要维护额外的表，还增加了查询的开销和复杂度。</li><li><strong>一致性哈希分片</strong>：将哈希空间组织成一个环形结构，将分片键和节点（数据库或表）都映射到这个环上，然后根据顺时针的规则确定数据或请求应该分配到哪个节点上，解决了传统哈希对动态伸缩不友好的问题。</li><li><strong>地理位置分片</strong>：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置（如城市、地域）来分配数据。</li><li><strong>融合算法分片</strong>：灵活组合多种分片算法，比如将哈希分片和范围分片组合。</li></ul><h3 id="分库分表会带来什么问题呢-、"><a href="#分库分表会带来什么问题呢-、" class="headerlink" title="分库分表会带来什么问题呢)、"></a>分库分表会带来什么问题呢)、</h3><p>记住，你在公司做的任何技术决策，不光是要考虑这个技术能不能满足我们的要求，是否适合当前业务场景，还要重点考虑其带来的成本。</p><p>引入分库分表之后，会给系统带来什么挑战呢？</p><ul><li><strong>join 操作</strong>：同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。不过，很多大厂的资深 DBA 都是建议尽量不要使用 join 操作。因为 join 的效率低，并且会对分库分表造成影响。对于需要用到 join 操作的地方，可以采用多次查询业务层进行数据组装的方法。不过，这种方法需要考虑业务上多次查询的事务性的容忍度。</li><li><strong>事务问题</strong>：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。这个时候，我们就需要引入分布式事务了。关于分布式事务常见解决方案总结，网站上也有对应的总结：<a href="https://javaguide.cn/distributed-system/distributed-transaction.html">https://javaguide.cn/distributed-system/distributed-transaction.html</a> 。</li><li><strong>分布式 ID</strong>：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入分布式 ID 了。关于分布式 ID 的详细介绍&amp;实现方案总结，可以看我写的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-id.html">分布式 ID 介绍&amp;实现方案总结</a>。</li><li><strong>跨库聚合查询问题</strong>：分库分表会导致常规聚合查询操作，如 group by，order by 等变得异常复杂。这是因为这些操作需要在多个分片上进行数据汇总和排序，而不是在单个数据库上进行。为了实现这些操作，需要编写复杂的业务代码，或者使用中间件来协调分片间的通信和数据传输。这样会增加开发和维护的成本，以及影响查询的性能和可扩展性。</li><li>……</li></ul><p>另外，引入分库分表之后，一般需要 DBA 的参与，同时还需要更多的数据库服务器，这些都属于成本。</p><h2 id="什么是数据冷热分离？"><a href="#什么是数据冷热分离？" class="headerlink" title="[什么是数据冷热分离？]"></a>[什么是数据冷热分离？]</h2><p>数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。</p><h3 id="冷数据和热数据"><a href="#冷数据和热数据" class="headerlink" title="冷数据和热数据"></a><a href="https://javaguide.cn/high-performance/data-cold-hot-separation.html#%E5%86%B7%E6%95%B0%E6%8D%AE%E5%92%8C%E7%83%AD%E6%95%B0%E6%8D%AE">冷数据和热数据</a></h3><p>热数据是指经常被访问和修改且需要快速访问的数据，冷数据是指不经常访问，对当前项目价值较低，但需要长期保存的数据。</p><p>冷热数据到底如何区分呢？有两个常见的区分方法：</p><ol><li><strong>时间维度区分</strong>：按照数据的创建时间、更新时间、过期时间等，将一定时间段内的数据视为热数据，超过该时间段的数据视为冷数据。这种方法适用于数据的访问频率和时间有较强的相关性的场景。</li><li><strong>访问频率区分</strong>：将高频访问的数据视为热数据，低频访问的数据视为冷数据。适合访问频率和数据本身有较强的相关性的场景。</li></ol><p>几年前的数据并不一定都是冷数据，例如一些优质文章发表几年后依然有很多人访问，大部分普通用户新发表的文章却基本没什么人访问。这两种区分冷热数据的方法各有优劣，实际项目中，可以将两者结合使用。</p><h3 id="数据冷热分离的优缺点"><a href="#数据冷热分离的优缺点" class="headerlink" title="数据冷热分离的优缺点"></a><a href="https://javaguide.cn/high-performance/data-cold-hot-separation.html#%E6%95%B0%E6%8D%AE%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">数据冷热分离的优缺点</a></h3><ul><li>优点：热数据的查询性能得到优化（用户的绝大部分操作体验会更好）、节约成本（可以冷热数据的不同存储需求，选择对应的数据库类型和硬件配置，比如将热数据放在 SSD 上，将冷数据放在 HDD 上）</li><li>缺点：系统复杂性和风险增加（需要分离冷热数据，数据错误的风险增加）、统计效率低（统计的时候可能需要用到冷库的数据）。</li></ul><h2 id="冷数据如何迁移？"><a href="#冷数据如何迁移？" class="headerlink" title="冷数据如何迁移？"></a><a href="https://javaguide.cn/high-performance/data-cold-hot-separation.html#%E5%86%B7%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB">冷数据如何迁移？</a></h2><p>冷数据迁移方案：</p><ol><li>业务层代码实现：当有对数据进行写操作时，触发冷热分离的逻辑，判断数据是冷数据还是热数据，冷数据就入冷库，热数据就入热库。这种方案会影响性能且冷热数据的判断逻辑不太好确定，还需要修改业务层代码，因此一般不会使用。</li><li>任务调度：可以利用 xxl-job 或者其他分布式任务调度平台定时去扫描数据库，找出满足冷数据条件的数据，然后批量地将其复制到冷库中，并从热库中删除。这种方法修改的代码非常少，非常适合按照时间区分冷热数据的场景。</li><li>监听数据库的变更日志 binlog ：将满足冷数据条件的数据从 binlog 中提取出来，然后复制到冷库中，并从热库中删除。这种方法可以不用修改代码，但不适合按照时间维度区分冷热数据的场景。</li></ol><p>如果你的公司有 DBA 的话，也可以让 DBA 进行冷数据的人工迁移，一次迁移完成冷数据到冷库。然后，再搭配上面介绍的方案实现后续冷数据的迁移工作。</p><h2 id="冷数据如何存储？"><a href="#冷数据如何存储？" class="headerlink" title="冷数据如何存储？"></a><a href="https://javaguide.cn/high-performance/data-cold-hot-separation.html#%E5%86%B7%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8">冷数据如何存储？</a></h2><p>冷数据的存储要求主要是容量大，成本低，可靠性高，访问速度可以适当牺牲。</p><p>冷数据存储方案：</p><ul><li>中小厂：直接使用 MySQL&#x2F;PostgreSQL 即可（不改变数据库选型和项目当前使用的数据库保持一致），比如新增一张表来存储某个业务的冷数据或者使用单独的冷库来存放冷数据（涉及跨库查询，增加了系统复杂性和维护难度）</li><li>大厂：Hbase（常用）、RocksDB、Doris、Cassandra</li></ul><p>如果公司成本预算足的话，也可以直接上 TiDB 这种分布式关系型数据库，直接一步到位。</p><p><img src="/./../img/image-20251126004714274.png" alt="image-20251126004714274"></p><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25Mysql面经补充</title>
    <link href="/2025/11/16/25Mysql%E9%9D%A2%E7%BB%8F%E8%A1%A5%E5%85%85/"/>
    <url>/2025/11/16/25Mysql%E9%9D%A2%E7%BB%8F%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="B-树、B树和红黑树的全称如下："><a href="#B-树、B树和红黑树的全称如下：" class="headerlink" title="B+树、B树和红黑树的全称如下："></a>B+树、B树和红黑树的全称如下：</h1><ol><li><strong>B树</strong>：<ul><li>全称：<strong>Balance-tree</strong>（平衡多路查找树）</li><li>英文：B-tree</li><li>说明：B代表”Balance”（平衡），表示这种树能保持数据有序且高度平衡。B树是为磁盘存储系统设计的自平衡多路查找树。</li></ul></li><li><strong>B+树</strong>：<ul><li>全称：<strong>B-plus tree</strong>（B树的改进版）</li><li>英文：B+-tree</li><li>说明：B+树是B树的一种变形，主要特点是”索引-数据分离”，即非叶子节点只存储索引，叶子节点存储数据并按顺序链接，特别适合数据库索引。</li></ul></li><li><strong>红黑树</strong>：<ul><li><p>全称：<strong>Red-Black Tree</strong>（红黑树）</p></li><li><p>英文：Red-Black Tree</p></li><li><p>说明：红黑树是自平衡二叉查找树，每个节点有红色或黑色属性，通过颜色规则保持树的平衡。</p></li><li></li><li></li><li><h2 id="3层B-树可以存多少数据？"><a href="#3层B-树可以存多少数据？" class="headerlink" title="3层B+树可以存多少数据？"></a>3层B+树可以存多少数据？</h2><p>进入正题，前面说了，3层B+树大概可以存2000w条数据，这个是咋算出来的呢？</p><p>在Innodb存储引擎里面，咱们最小存储单元是页，而一个页的大小默认是16KB。</p><p>也即代表B+树的每个节点可以存16KB数据，这里我们假设我们的一行数据大小是1K，那么我们一个节点就可以存16行数据。注意：我们真正的数据都是存在叶子节点的，所以这里是指叶子节点可以存放16行数据。</p><p>我们前面也说了，非叶子节点存放的是主键值与指针，所以这里假设主键类型为bigint，占用8Byte，指针可以设置为占用6Byte，总共就为14Byte，这样就可以算出一个节点大概可以存放多少个指针了（指针指向下一层节点），大概为16KB&#x2F;14Byte&#x3D;1170个。</p><p>由此，可以推算出，2层B+树的话，可以存放1170<em>16&#x3D;18720行数据。3层B+树的话，可以存放1170</em>1170*16&#x3D;21902400行数据，也就差不多2000w条数据了。</p></li></ul></li></ol><h1 id="失效情况"><a href="#失效情况" class="headerlink" title="失效情况"></a>失效情况</h1><p><strong>最左前缀原则</strong>是MySQL在使用<strong>联合索引</strong>（复合索引）时的重要优化规则，要求查询条件必须从索引的<strong>最左列</strong>开始，并且连续匹配，才能高效利用索引。其底层依赖<strong>B+树</strong>的有序性：索引树首先按第一个字段排序，在此基础上再对第二个字段排序，依此类推</p><p><img src="/./../img/image-20251204194151987.png" alt="image-20251204194151987"></p><h1 id="覆盖索引解决深分页问题"><a href="#覆盖索引解决深分页问题" class="headerlink" title="覆盖索引解决深分页问题"></a>覆盖索引解决深分页问题</h1><p><img src="/./../img/image-20251204203625925.png" alt="image-20251204203625925"></p><p><img src="/./../img/image-20251204203920772.png" alt="image-20251204203920772"></p><h1 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a>ICP</h1><p><img src="/./../img/image-20251204204205404.png" alt="image-20251204204205404"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">find</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> s, <span class="hljs-title class_">String</span> ip, int n</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-title function_">isEmpty</span>()) &#123;<br>                ans.<span class="hljs-title function_">add</span>(ip);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            ip += <span class="hljs-string">&quot;.&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(s.<span class="hljs-title function_">length</span>(), <span class="hljs-number">4</span>); i++) &#123;<br>            <span class="hljs-title class_">String</span> u = s.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, i);<br>            <span class="hljs-comment">// 判断数字范围</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Integer</span>.<span class="hljs-built_in">parseInt</span>(u) &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 判断前导零</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; u.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-title function_">find</span>(s.<span class="hljs-title function_">substring</span>(i), ip + u, n + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">restoreIpAddresses</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> s</span>) &#123;<br>        <span class="hljs-title function_">find</span>(s, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="查询期间干了什么"><a href="#查询期间干了什么" class="headerlink" title="查询期间干了什么"></a>查询期间干了什么</h1><p>执行一条 SQL 查询语句，期间发生了什么？</p><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><h1 id="索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。"><a href="#索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。" class="headerlink" title="索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。"></a>索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong>。</h1><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul><h1 id="能用到后续的索引"><a href="#能用到后续的索引" class="headerlink" title="&gt;&#x3D;能用到后续的索引"></a>&gt;&#x3D;能用到后续的索引</h1><p>Q1: <code>select * from t_table where a &gt; 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p><p><strong>但是在符合 a &gt; 1 条件的二级索引记录的范围里，b 字段的值是无序的</strong>。</p><p>因此，<strong>Q1 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引</strong>。</p><p>Q2: <code>select * from t_table where a &gt;= 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p><p>虽然在符合 a&gt;&#x3D; 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，<strong>但是对于符合 a &#x3D; 1 的二级索引记录的范围里，b 字段的值是「有序」的</strong></p><p>所以，<strong>Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p><blockquote><p>Q3: <code>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>Q3 查询条件中 <code>a BETWEEN 2 AND 8</code> 的意思是查询 a 字段的值在 2 和 8 之间的记录。不同的数据库对 BETWEEN … AND 处理方式是有差异的。在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 &gt;&#x3D; and &#x3D;&lt;。而有的数据库则不包含 value1 和 value2 边界值（类似于 &gt; and &lt;）。</p><p>这里我们只讨论 MySQL。由于 MySQL 的 BETWEEN 包含 value1 和 value2 边界值，所以类似于 Q2 查询语句，因此 <strong>Q3 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p><p>综上所示，<strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，前面我也用了四个例子说明了</strong>。</p><h2 id="什么时候需要-不需要创建索引？"><a href="#什么时候需要-不需要创建索引？" class="headerlink" title="什么时候需要 &#x2F; 不需要创建索引？"></a>什么时候需要 &#x2F; 不需要创建索引？</h2><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护</li></ul><p>为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：</p><ul><li>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</li><li>第二个原因：行格式 (opens new window)](<a href="https://xiaolincoding.com/mysql/base/row_format.html#innodb-%E8%A1%8C%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B)%E4%B8%AD**%E8%87%B3%E5%B0%91%E4%BC%9A%E7%94%A8">https://xiaolincoding.com/mysql/base/row_format.html#innodb-行格式有哪些)中**至少会用</a> 1 字节空间存储 NULL 值列表**，如下图的紫色部分</li></ul><h1 id="深度分页（走索引，业务解决）"><a href="#深度分页（走索引，业务解决）" class="headerlink" title="深度分页（走索引，业务解决）"></a>深度分页（走索引，业务解决）</h1><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><strong>事务</strong> 是指在数据库中执行的一事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：</p><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节</li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><p>mvcc的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是隐藏字段，第二个是undolog日志,第三个是readView读视图,</p><p>隐藏字段是指:在mysql中给每个表都设置了隐藏字段,有一个是trx_id(事务id)，记录每一次操作的事务id，是自增的;另一个字段是roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址</p><p>undolog主要的作用是记录回滚日志，存储具体的老版本数据，在内部会形成一个版本链，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表，提供查询功能</p><p>readView是一个数据结构，解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是rc隔离级别，每一次执行快照读时生成ReadView，如果是rr隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用</p><p>❓ <strong>常见误解澄清</strong></p><p>误解1：<em>“Read View 能直接访问旧版本，为什么还要Undo Log？”</em></p><ul><li><p><strong>错误</strong>：Read View 本身不存储数据！它只是一个<strong>事务快照</strong>（内存中的数据结构）。</p></li><li><p>真相：Read View 通过DB_ROLL_PTR 去 Undo Log 中找数据。</p><blockquote><p>例如：<code>Read View</code> 说“版本ID&#x3D;100可见”，但必须调用 <code>DB_ROLL_PTR</code> 从Undo Log中取出ID&#x3D;100的版本。</p></blockquote></li></ul><p>误解2：<em>“Undo Log 保存了所有版本，Read View 为什么还要判断？”</em></p><ul><li><strong>错误</strong>：Undo Log 是“仓库”，但仓库里可能有未提交的版本（如T2的修改）。</li><li><strong>真相</strong>：Read View 的规则过滤了这些无效版本，确保事务只看到已提交的数据。</li></ul><h1 id="6-种会发生索引失效的情况："><a href="#6-种会发生索引失效的情况：" class="headerlink" title="6 种会发生索引失效的情况："></a>6 种会发生索引失效的情况：</h1><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。</li><li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><h4 id="日志分析工具mysqldumpslow"><a href="#日志分析工具mysqldumpslow" class="headerlink" title="日志分析工具mysqldumpslow"></a>日志分析工具<code>mysqldumpslow</code></h4><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具<code>mysqldumpslow</code>。比如有100条慢sql，如何快速找出出现频次最高的前5条。</p><blockquote><p>查看mysqldumpslow的帮助文档</p></blockquote><p>在Linux命令行窗口执行mysqldumpslow –help</p><p><img src="/./../img/kxxh5ypm55rvu_2ea8c86727b646e181bf3c6832b6b4f5.png" alt="image"></p><blockquote><p>常用命令案例</p></blockquote><p>日志文件地址：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;slow.log</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 得到返回记录集最多的10个SQL</span><br>mysqldumpslow -s r -t <span class="hljs-number">10</span> <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/mysql/</span>slow.log<br> <br><span class="hljs-comment"># 得到访问次数最多的10个SQL</span><br>mysqldumpslow -s c -t <span class="hljs-number">10</span> <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/mysql/</span>slow.log<br> <br><span class="hljs-comment"># 得到按照时间排序的前10条里面含有左连接的查询语句</span><br>mysqldumpslow -s t -t <span class="hljs-number">10</span> -g <span class="hljs-string">&quot;left join&quot;</span> <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/mysql/</span>slow.log<br><br><span class="hljs-comment"># 另外建议使用这些命令时结合|和more使用，否则出现爆屏的情况</span><br>mysqldumpslow -s r -t <span class="hljs-number">10</span> <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/mysql/</span>slow.log | more<br></code></pre></td></tr></table></figure><h1 id="主从同步原具体详细过程如下："><a href="#主从同步原具体详细过程如下：" class="headerlink" title="主从同步原具体详细过程如下："></a>主从同步原具体详细过程如下：</h1><ul><li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li><li>从库会创建一个专门的 I&#x2F;O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li><li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li></ul><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23Mysql事务和锁</title>
    <link href="/2025/11/16/23Mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/"/>
    <url>/2025/11/16/23Mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="3-MySQL锁"><a href="#3-MySQL锁" class="headerlink" title="3 MySQL锁"></a>3 MySQL锁</h1><p>事务的 <strong>隔离性</strong> 由这章讲述的 <strong>锁</strong> 来实现。</p><h2 id="3-1-锁概述"><a href="#3-1-锁概述" class="headerlink" title="3.1 锁概述"></a>3.1 锁概述</h2><p><strong>锁</strong>是计算机协调多个进程或者线程<strong>并发访问某一个资源</strong>的机制。我们就需要保证这个数据在任何时刻<strong>最多只有一个线程</strong>在访问，保证数据的完整性和一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，<strong>需要对并发操作进行控制</strong> ，因此产生了锁 。同时锁机制也为实现MySQL的各个隔离级别提供了保证。 <strong>锁冲突</strong> 也是影响数据库 <strong>并发访问性能</strong> 的一个重要因素。</p><h3 id="讲一下mysql里有哪些锁？"><a href="#讲一下mysql里有哪些锁？" class="headerlink" title="讲一下mysql里有哪些锁？"></a>讲一下mysql里有哪些锁？</h3><p>在 MySQL 里，根据加锁的范围，可以分为<strong>全局锁、表级锁和行锁</strong>三类。</p><p><img src="/./../img/1720433609532-38aec7fc-734e-4b35-a802-4e6ba3339ffa.png" alt="img"></p><ul><li><strong>全局锁</strong>：通过flush tables with read lock 语句会将整个数据库就处于只读状态了，这时其他线程执行以下操作，增删改或者表结构修改都会阻塞。全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</li><li><strong>表级锁</strong>：MySQL 里面表级别的锁有这几种：<ul><li>表锁：通过lock tables 语句可以对表加表锁，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</li><li>元数据锁：当我们对数据库表进行操作时，会自动给这个表加上 MDL，对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</li><li>意向锁：当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</li></ul></li><li><strong>行级锁</strong>：InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</li><li>记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的，满足读写互斥，写写互斥</li><li>间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</li><li>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><h2 id="3-2-并发事务带来的问题"><a href="#3-2-并发事务带来的问题" class="headerlink" title="3.2 并发事务带来的问题"></a>3.2 并发事务带来的问题</h2><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）:</strong> 也叫丢失更新。指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</li><li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的<font color='red'><strong>修改</strong></font>导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）<font color = 'red'><strong>插入或者删除</strong></font>了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p><strong>不可重复度和幻读区别：</strong></p><p>不可重复读的重点是<strong>修改</strong>，针对的数据是多行。幻读的重点在于<strong>新增或者删除</strong>，针对数据是多行。</p><h2 id="3-3-并发事务的解决方案"><a href="#3-3-并发事务的解决方案" class="headerlink" title="3.3 并发事务的解决方案"></a>3.3 并发事务的解决方案</h2><p>解决方案：对事务进行隔离</p><p>MySQL的四种隔离级别如下:</p><ul><li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。可以看到，在终端 B 事务执行新增操作时，会发生阻塞，锁超时后会抛出 <code>1205 - Lock wait timeout exceeded; try restarting transaction</code> 错误，避免了幻读。可以通过 <code>select * from performance_schema.data_locks;</code> 查看事务的锁信息，从 <code>supremum pseudo-record </code>获知，通过添加锁解决幻读问题。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@global</span>.transaction_isolation ;<br></code></pre></td></tr></table></figure><h2 id="3-4-并发事务访问情况说明"><a href="#3-4-并发事务访问情况说明" class="headerlink" title="3.4 并发事务访问情况说明"></a>3.4 并发事务访问情况说明</h2><p>并发事务访问相同记录的情况大致可以划分为3种：读-读情况、写-写情况、读-写</p><h3 id="3-4-1-读-读情况"><a href="#3-4-1-读-读情况" class="headerlink" title="3.4.1 读-读情况"></a>3.4.1 读-读情况</h3><p><strong>读-读</strong>情况，即并发事务相继<strong>读取相同的记录</strong> 。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p><h3 id="3-4-2-写-写情况"><a href="#3-4-2-写-写情况" class="headerlink" title="3.4.2 写-写情况"></a>3.4.2 写-写情况</h3><p>写-写 情况，即并发事务相继对相同的记录做出改动。 在这种情况下会发生 <strong>脏写(脏写读取、脏写覆盖)</strong> 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行 ，这个排队的过程其实是通过<strong>锁</strong>来实现的。这个所谓 的锁其实是一个 内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进 行关联的，如图所示：</p><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的<strong>锁结构</strong> ，当没有的时候 就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构 与之关联：</p><p>在锁结构中存在很多的信息，为了简化理解，只把两个比较重要的属性拿出来：</p><p>1、trx信息：代表这个锁结构是哪一个事务生成的</p><p>2、is_waiting: 代表当前事务是否在线等待</p><p>当事务T1改动了这条记录后，就生成了一个锁结构与该条记录关联，因为之前没有别的事务为这条记录加锁，所以is_waiting属性就是false，我们把这个场景就称之为获取锁成功，或者加锁成功。然后就可以继续进行操作了。</p><p><img src="/./../img/image-20251116111043986.png" alt="image-20251116111043986"></p><p>在事务T1提交之前，另外一个事务T2也想对该记录做更改，那么先看看有没有锁结构与该条记录关联，发现有一个锁结构与之关联，然后也生成了一个锁结构与这条记录关联，不过锁结构的is_waiting属性就是true，表示当前事务需要等待，我们把这个场景就称之为获取锁失败，或者加锁失败。如下图所示：</p><p>当事务T1提交之后，就会把该事务生成的<strong>锁结构释放掉</strong>，然后看看有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把<strong>事务T2对应的锁结构的is_waiting属性设置为false</strong>，然后把该事务对应的线程唤醒，让他继续执行，此时事务T2就算获取到了锁。</p><p>小结几种说法： </p><p>1、<strong>不加锁</strong> 意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。 </p><p>2、<strong>获取锁成功，或者加锁成功</strong> 意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务 可以继续执行操作。 </p><p>3、<strong>获取锁失败，或者加锁失败</strong>，或者没有获取到锁 意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting 属性为 true ，也就是事务 需要等待，不可以继续执行操作。</p><h3 id="3-4-3-读-写情况"><a href="#3-4-3-读-写情况" class="headerlink" title="3.4.3 读-写情况"></a>3.4.3 读-写情况</h3><p>读-写  ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、 不可重复读 、 幻读 的问题。</p><p>要想解决这些问题就需要使用到到事务的隔离级别，而事务的隔离性的实现原理有两种：</p><p>1、使用<strong>MVCC</strong>：读操作利用多版本并发控制（ MVCC ），写操作进行加锁 。</p><blockquote><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><p>1、在 READ COMMITTED 隔离级别下，一个事务在执行过程中<strong>每次</strong>执行SELECT操作时都会生成一 个<strong>ReadView</strong>，ReadView的存在本身就保证了 事务不可以读取到未提交的事务所做的更改 ，也就 是避免了脏读现象； </p><p>2、在 REPEATABLE READ 隔离级别下，一个事务在执行过程中只有 <strong>第一次</strong>执行SELECT操作 才会 生成一个<strong>ReadView</strong>，之后的SELECT操作都 复用 这个ReadView，这样也就避免了不可重复读的问题。但仍可能出现幻读问题</p></blockquote><p>2、读、写操作都采用 加锁 的方式。</p><p>小结对比发现： </p><p>1、采用 MVCC 方式的话， 读-写 操作彼此并不冲突， 性能更高 。 </p><p>2、采用 加锁 方式的话， 读-写 操作彼此需要 排队执行 ，影响性能。 </p><p>一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况 下，要求必须采用 加锁 的方式执行。</p><h2 id="3-5-锁的分类"><a href="#3-5-锁的分类" class="headerlink" title="3.5 锁的分类"></a>3.5 锁的分类</h2><p>从对数据操作的粒度分 ： </p><p>1） 表锁(手动加)：操作时，会锁定整个表。</p><p>2） 行锁(Innodb默认)：操作时，会锁定当前操作行。</p><p>3） 意向锁(自动加)：解决表锁和行锁之间的兼容性冲突，提高并发效率</p><p>从对数据操作的类型分：</p><p>1） 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p><p>2） 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。</p><p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列出了各存储引擎对锁的支持情况：</p><table><thead><tr><th>存储引擎</th><th>表级锁</th><th>行级锁</th><th>页面锁</th></tr></thead><tbody><tr><td>MyISAM</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>InnoDB</td><td>支持</td><td>支持</td><td>不支持</td></tr></tbody></table><p>MySQL这3种锁的特性可大致归纳如下 ：</p><table><thead><tr><th>锁类型</th><th>特点</th></tr></thead><tbody><tr><td>表级锁</td><td>偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</td></tr><tr><td>行级锁</td><td>偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</td></tr><tr><td>意向锁</td><td>意向锁是 <strong>表级锁</strong>，但不会真的阻塞其他行操作 当事务要加行锁时，InnoDB 会先在表上加意向锁，告诉系统我要对某些行加锁了 这样，当其他事务想申请表锁时，就能快速判断表里是否已经有人持有行锁，而不需要一行一行检查。</td></tr><tr><td>页面锁</td><td>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td></tr></tbody></table><p>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用。最后意向锁解决表锁和行锁之间的兼容性冲突，提高并发效率</p><h2 id="3-6-InnoDB行锁"><a href="#3-6-InnoDB行锁" class="headerlink" title="3.6 InnoDB行锁"></a>3.6 InnoDB行锁</h2><h3 id="3-6-1-加锁特点"><a href="#3-6-1-加锁特点" class="headerlink" title="3.6.1 加锁特点"></a>3.6.1 加锁特点</h3><p>InnoDB  实现了以下两种类型的行锁。</p><p>1、共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p><p>select for share</p><p>2、排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据进行读取和修改 select…for update。</p><p>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及到的数据集加排他锁（X)；</p><p>对于普通SELECT语句，InnoDB不会加任何锁；</p><h3 id="3-6-2-案例准备工作3-6-3-行锁基本演示"><a href="#3-6-2-案例准备工作3-6-3-行锁基本演示" class="headerlink" title="3.6.2 案例准备工作3.6.3 行锁基本演示"></a>3.6.2 案例准备工作3.6.3 行锁基本演示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set autocommit=0;<br></code></pre></td></tr></table></figure><h3 id="3-6-4-无索引行锁升级为表锁"><a href="#3-6-4-无索引行锁升级为表锁" class="headerlink" title="3.6.4 无索引行锁升级为表锁"></a>3.6.4 无索引行锁升级为表锁</h3><p>如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。</p><h3 id="3-6-6-意向锁"><a href="#3-6-6-意向锁" class="headerlink" title="3.6.6 意向锁"></a>3.6.6 意向锁</h3><p>意向锁是表级锁，共有两种：</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InnoDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p><p>意向锁之间是互相兼容的。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>IS 锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX 锁</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>S 锁</td><td>兼容</td><td>互斥</td></tr><tr><td>X 锁</td><td>互斥</td><td>互斥</td></tr></tbody></table><p>《MySQL 技术内幕 InnoDB 存储引擎》这本书对应的描述应该是笔误了。</p><p><img src="/./../img/image-20220511171419081.png" alt="img"></p><hr><p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：<a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">https://javaguide.cn/database/mysql/mysql-questions-01.html</a></p><p>总结</p><p><strong>行锁自动带意向锁</strong>：任何行锁操作都会在表上自动生成对应的意向锁（IX &#x2F; IS）。</p><p><strong>意向锁的作用</strong>：加速判断“能否加表级锁”。</p><ul><li>如果表上有 IX，那么后续再申请表级 X 锁，就会直接被阻塞。</li><li>这样 MySQL 不用去扫描整张表的每一行，看是不是有人加了行锁。</li></ul><p><strong>演示效果</strong>：</p><ul><li>Session 1、2 在不同的行上 <code>FOR UPDATE</code> 可以并发成功（因为意向锁不互斥）。</li><li>但只要有人持有行锁（带 IX），别人就无法直接加表级写锁。</li></ul><h3 id="3-6-6-间隙锁危害"><a href="#3-6-6-间隙锁危害" class="headerlink" title="3.6.6 间隙锁危害"></a>3.6.6 间隙锁危害</h3><p>当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 “间隙（GAP）” ， InnoDB也会对这个 “间隙” 加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁） 。</p><h3 id="自增锁有了解吗？"><a href="#自增锁有了解吗？" class="headerlink" title="[自增锁有了解吗？]"></a>[自增锁有了解吗？]</h3><blockquote><p>不太重要的一个知识点，简单了解即可。</p></blockquote><p>关系型数据库设计表的时候，通常会有一列作为自增主键。InnoDB 中的自增主键会涉及一种比较特殊的表级锁— <strong>自增锁（AUTO-INC Locks）</strong> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> `sequence_id` (<br>  `id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT,<br>  `stub` <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `stub` (`stub`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;<br></code></pre></td></tr></table></figure><p>更准确点来说，不仅仅是自增主键，<code>AUTO_INCREMENT</code>的列都会涉及到自增锁，毕竟非主键也可以设置自增长。</p><p>如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能会被阻塞住。这里的阻塞行为只是自增锁行为的其中一种，可以理解为自增锁就是一个接口，其具体的实现有多种。具体的配置项为 <code>innodb_autoinc_lock_mode</code> （MySQL 5.1.22 引入），可以选择的值如下：</p><table><thead><tr><th align="left">innodb_autoinc_lock_mode</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">传统模式</td></tr><tr><td align="left">1</td><td align="left">连续模式（MySQL 8.0 之前默认）</td></tr><tr><td align="left">2</td><td align="left">交错模式(MySQL 8.0 之后默认)</td></tr></tbody></table><p>交错模式下，所有的“INSERT-LIKE”语句（所有的插入语句，包括：<code>INSERT</code>、<code>REPLACE</code>、<code>INSERT…SELECT</code>、<code>REPLACE…SELECT</code>、<code>LOAD DATA</code>等）都不使用表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行，速度更快，扩展性也更好。</p><p>不过，如果你的 MySQL 数据库有主从同步需求并且 Binlog 存储格式为 Statement 的话，不要将 InnoDB 自增锁模式设置为交叉模式，不然会有数据不一致性问题。这是因为并发情况下插入语句的执行顺序就无法得到保障。</p><blockquote><p>如果 MySQL 采用的格式为 Statement ，那么 MySQL 的主从同步实际上同步的就是一条一条的 SQL 语句。</p></blockquote><h3 id="3-6-7-总结"><a href="#3-6-7-总结" class="headerlink" title="3.6.7 总结"></a>3.6.7 总结</h3><p>InnoDB 存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了一定的性能损耗，可能比表锁开销更高，但整体并发处理能力远高于 MyISAM 的表锁。当系统并发量较高时，InnoDB 的整体性能表现通常会更好。</p><p>不过，InnoDB 的行级锁也有脆弱的一面，如果使用不当，性能不仅不会优于 MyISAM，甚至可能更差。</p><p>另外需要注意的是，InnoDB 在行锁和表锁之间引入了 <strong>意向锁</strong>。意向锁是一种表级锁，用来标识事务即将在表中某些行上加行锁，从而避免在加行锁时与其他事务的表级锁产生冲突。它并不会真正阻塞具体的行访问，但能显著提升锁的检测效率。</p><p><strong>优化建议：</strong></p><ol><li>尽可能让所有数据检索都能通过索引来完成，避免无索引导致行锁退化为表锁。</li><li>合理设计索引，尽量缩小锁的范围。</li><li>尽可能减少索引条件范围，避免过多间隙锁的产生。</li><li>尽量控制事务大小，减少锁定资源数量和时间长度。</li><li>在业务允许的前提下，使用较低级别的事务隔离，减少锁冲突。</li><li>合理利用 <strong>意向锁</strong> 的机制，理解它只是用于快速判定是否存在行锁，避免在表级与行级锁之间产生不必要的冲突。</li></ol><h1 id="4-MySQL中的MVCC"><a href="#4-MySQL中的MVCC" class="headerlink" title="4 MySQL中的MVCC"></a>4 MySQL中的MVCC</h1><h2 id="4-1-MVCC概述"><a href="#4-1-MVCC概述" class="headerlink" title="4.1 MVCC概述"></a>4.1 MVCC概述</h2><p>全称Multi-Version Concurrency Control，即多版本并发控制，主要是为了提高数据库的读写并发性能。</p><p>同一行数据平时发生读写请求时，会上锁阻塞住。但mvcc用更好的方式去处理读—写请求，做到在发生读—写请求冲突时不用加锁。这个读是指的快照读，而不是当前读，当前读是一种加锁操作，是悲观锁。</p><h2 id="4-2-MVCC三要素"><a href="#4-2-MVCC三要素" class="headerlink" title="4.2 MVCC三要素"></a>4.2 MVCC三要素</h2><h3 id="4-2-1-隐藏字段"><a href="#4-2-1-隐藏字段" class="headerlink" title="4.2.1 隐藏字段"></a>4.2.1 隐藏字段</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="./../img/image-20251116104621382.png" alt="image-20251116104621382" style="zoom: 50%;" /></h3><p>回滚日志,在insert update delete的时候产生的便于数据回滚的日志</p><p>当insert的时候,产生的undolog日志只在回滚时需要,一旦事务提交,会被立即删除</p><p>但update和delete的时候,产生的undolog日志不仅在回滚的时候需要,mvcc版本访问也需要,不会立即被删除</p><p>不同事务或相同事务对同一条记录进行修改,会导致该记录的undolog生成一条记录版本链表,链表的头部是最新的旧记录,链表的尾部是最早的旧记录</p><h3 id="4-2-3-ReadView读视图"><a href="#4-2-3-ReadView读视图" class="headerlink" title="4.2.3 ReadView读视图"></a>4.2.3 ReadView读视图</h3><p>读视图是快照读SQL执行时MVCC提取数据的依据, 记录并维护系统当前活跃事务(未提交的事务)id</p><h4 id="4-2-3-1-MVCC读"><a href="#4-2-3-1-MVCC读" class="headerlink" title="4.2.3.1 MVCC读"></a>4.2.3.1 MVCC读</h4><table><thead><tr><th>方式</th><th>概念</th><th>实现方式</th></tr></thead><tbody><tr><td>当前读</td><td>读取的是记录的最新版本,读取时还要保证其他并发事务不能修改当前记录,会对当前记录进行加锁,是阻塞的</td><td>select…for update</td></tr><tr><td>快照读</td><td>我们平常写的select都是快照读,读取的是数据的可见版本,有可能是历史数据,不加锁,是非阻塞的</td><td>RC隔离级别: 每次select 都生成一个快照读  RR隔离级别: 开启事务后,同一条select语句多次查询共用RW</td></tr></tbody></table><h4 id="4-2-3-2-RW组成"><a href="#4-2-3-2-RW组成" class="headerlink" title="4.2.3.2 RW组成"></a>4.2.3.2 RW组成</h4><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃事务的ID集合    案例中的3,4,5 事务2已提交 不属于活跃事务</td></tr><tr><td>min_trx_id</td><td>最小活跃事务事务ID  案例中事务3为最小活跃事务id</td></tr><tr><td>max_trx_id</td><td>预分配事务ID,当前最大事务ID+1(ID是自增的)     案例中事务5+1 也就是事务6</td></tr><tr><td>creator_trx_id</td><td>RW创建者的事务ID    案例中的事务5</td></tr></tbody></table><h1 id="RR下的幻读问题"><a href="#RR下的幻读问题" class="headerlink" title="RR下的幻读问题"></a>RR下的幻读问题</h1><p><a href="https://zhuanlan.zhihu.com/p/564735312">(10 条消息) MySQL 可重复读隔离级别，彻底解决幻读了吗？ - 知乎</a></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="Mysql-设置了可重读隔离级后，怎么保证不发生幻读？"><a href="#Mysql-设置了可重读隔离级后，怎么保证不发生幻读？" class="headerlink" title="Mysql 设置了可重读隔离级后，怎么保证不发生幻读？"></a>Mysql 设置了可重读隔离级后，怎么保证不发生幻读？</h3><p><strong>尽量在开启事务之后，马上执行 select … for update 这类锁定读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录，就避免了幻读的问题。</p><h3 id="串行化隔离级别是通过什么实现的？"><a href="#串行化隔离级别是通过什么实现的？" class="headerlink" title="串行化隔离级别是通过什么实现的？"></a>串行化隔离级别是通过什么实现的？</h3><p>是通过行级锁来实现的，序列化隔离级别下，普通的 select 查询是会对记录加 S 型的 next-key 锁，其他事务就没没办法对这些已经加锁的记录进行增删改操作了，从而避免了脏读、不可重复读和幻读现象。</p><h3 id="一条update是不是原子性的？为什么？"><a href="#一条update是不是原子性的？为什么？" class="headerlink" title="一条update是不是原子性的？为什么？"></a>一条update是不是原子性的？为什么？</h3><p>是原子性，主要通过锁+undolog 日志保证原子性的</p><ul><li>执行 update 的时候，会加行级别锁，保证了一个事务更新一条记录的时候，不会被其他事务干扰。</li><li>事务执行过程中，会生成 undolog，如果事务执行失败，就可以通过 undolog 日志进行回滚。</li></ul><h3 id="滥用事务，或者一个事务里有特别多sql的弊端？"><a href="#滥用事务，或者一个事务里有特别多sql的弊端？" class="headerlink" title="滥用事务，或者一个事务里有特别多sql的弊端？"></a>滥用事务，或者一个事务里有特别多sql的弊端？</h3><p>事务的资源在事务提交之后才会释放的，比如存储资源、锁。</p><p>如果一个事务特别多 sql，那么会带来这些问题：</p><ul><li>如果一个事务特别多 sql，锁定的数据太多，容易造成大量的死锁和锁超时。</li><li>回滚记录会占用大量存储空间，事务回滚时间长。在[MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值，sql 越多，所需要保存的回滚数据就越多。</li><li>执行时间长，容易造成主从延迟，主库上必须等事务执行完成才会写入binlog，再传给备库。所以，如果一个主库上的语句执行10分钟，那这个事务很可能就会导致从库延迟10分钟</li></ul><h3 id="MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？"><a href="#MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？" class="headerlink" title="MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？"></a>MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？</h3><p>如果是两个事务同时更新了 id &#x3D; 1，比如 update … where id &#x3D; 1，那么是会阻塞的。因为 InnoDB 存储引擎实现了行级锁。</p><p>当A事务对 id &#x3D;1 这行记录进行更新时，会对主键 id 为 1 的记录加X类型的记录锁，这样第二事务对 id &#x3D; 1 进行更新时，发现已经有记录锁了，就会陷入阻塞状态。</p><h3 id="两条update语句处理一张表的不同的主键范围的记录，一个15，会不会遇到阻塞？底层是为什么的？"><a href="#两条update语句处理一张表的不同的主键范围的记录，一个15，会不会遇到阻塞？底层是为什么的？" class="headerlink" title="#两条update语句处理一张表的不同的主键范围的记录，一个&lt;10，一个&gt;15，会不会遇到阻塞？底层是为什么的？"></a><a href="https://xiaolincoding.com/interview/mysql.html#%E4%B8%A4%E6%9D%A1update%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E4%B8%80%E5%BC%A0%E8%A1%A8%E7%9A%84%E4%B8%8D%E5%90%8C%E7%9A%84%E4%B8%BB%E9%94%AE%E8%8C%83%E5%9B%B4%E7%9A%84%E8%AE%B0%E5%BD%95-%E4%B8%80%E4%B8%AA-10-%E4%B8%80%E4%B8%AA-15-%E4%BC%9A%E4%B8%8D%E4%BC%9A%E9%81%87%E5%88%B0%E9%98%BB%E5%A1%9E-%E5%BA%95%E5%B1%82%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9A%84">#</a>两条update语句处理一张表的不同的主键范围的记录，一个&lt;10，一个&gt;15，会不会遇到阻塞？底层是为什么的？</h3><p>不会，因为锁住的范围不一样，不会形成冲突。</p><ul><li>第一条 update sql 的话（ id&lt;10），锁住的范围是（-♾️，10）</li><li>第二条 update sql 的话（id &gt;15），锁住的范围是（15，+♾️）</li></ul><h3 id="如果2个范围不是主键或索引-还会阻塞吗"><a href="#如果2个范围不是主键或索引-还会阻塞吗" class="headerlink" title="如果2个范围不是主键或索引-还会阻塞吗"></a>如果2个范围不是主键或索引-还会阻塞吗</h3><p>如果2个范围查询的字段不是索引的话，那就代表 update 没有用到索引，这时候触发了全表扫描，全部索引都会加行级锁，这时候第二条 update 执行的时候，就会阻塞了。</p><p>因为如果 update 没有用到索引，在扫描过程中会对索引加锁，所以全表扫描的场景下，所有记录都会被加锁，相当于锁住了全表。</p><h1 id="背书"><a href="#背书" class="headerlink" title="背书"></a>背书</h1><p><strong>mvcc的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是隐藏字段，第二个是undolog日志，第三个是readView读视图,隐藏字段是指:在mysql中给每个表都设置了隐藏字段，有一个是trx_id(事务id)，记录每一次操作的事务id，是自增的;另一个字段roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址</strong></p><p><strong>undolog主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行查找某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表</strong></p><p><strong>readView解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是rc隔离级别，每一次执行快照读时生成ReadView，如果是rr隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22Mysql日志</title>
    <link href="/2025/11/16/22Mysql%E6%97%A5%E5%BF%97/"/>
    <url>/2025/11/16/22Mysql%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL基础日志"><a href="#MySQL基础日志" class="headerlink" title="MySQL基础日志"></a>MySQL基础日志</h1><h2 id="1-1-日志分类"><a href="#1-1-日志分类" class="headerlink" title="1.1 日志分类"></a>1.1 日志分类</h2><p>在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的方方面面，以帮助数据库管理员追踪数据库曾经发生过的各种事件。MySQL有多种类型的日志，用于记录数据库的操作和状态。以下是一些常见的MySQL日志：</p><p>1、错误日志（Error Log）：记录MySQL服务器在启动、运行过程中发生的错误和异常情况，如启动错误、语法错误等。</p><p>2、查询日志（Query Log）：记录所有执行的查询语句，包括SELECT、INSERT、UPDATE、DELETE等操作。可以用于分析查询性能和调试问题，但需要注意对于高负载的系统，开启查询日志可能会对性能产生影响。</p><p>3、慢查询日志（Slow Query Log）：记录执行时间超过指定阈值的查询语句。慢查询日志可以帮助你找出执行时间较长的查询，以便进行性能优化。</p><p>4、二进制日志（Binary Log）：记录所有对数据库的更改操作，包括数据修改、表结构变更等。二进制日志可以用于数据恢复、主从复制等场景。</p><p>5、事务日志（Transaction Log）：也称为重做日志（Redo Log），记录正在进行的事务的更改操作。事务日志用于保证数据库的ACID特性，并支持崩溃恢复。</p><h2 id="1-2-错误日志"><a href="#1-2-错误日志" class="headerlink" title="1.2 错误日志"></a>1.2 错误日志</h2><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。</p><p>查看日志位置指令 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;log_error%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>执行结果如下所示：</p><p>log_error设置为stderr并且MySQL以守护进程（daemon）方式运行，那么错误日志将被重定向到系统日志文件（如&#x2F;var&#x2F;log&#x2F;syslog）或其他操作系统特定的日志文件中，而不是直接输出到控制台。</p><p>可以通过如下配置，设置错误日志的输出位置：</p><p>打开MySQL的配置文件my.cnf。该文件通常位于MySQL安装目录下的&#x2F;etc或者&#x2F;etc&#x2F;mysql子目录中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[mysqld]<br>log_error = /var/lib/mysql/mysql-error.err<br></code></pre></td></tr></table></figure><p>重启mysql进行测试。</p><p>查看日志内容 ： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">tail <span class="hljs-operator">-</span>f <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>docker<span class="hljs-operator">/</span>volumes<span class="hljs-operator">/</span>mysql8_data<span class="hljs-operator">/</span>_data<span class="hljs-operator">/</span>mysql<span class="hljs-operator">-</span>error.err<br></code></pre></td></tr></table></figure><h2 id="1-3-查询日志"><a href="#1-3-查询日志" class="headerlink" title="1.3 查询日志"></a>1.3 查询日志</h2><p>查询日志中记录了客户端的所有操作语句【CRUD】，而二进制日志不包含查询数据的SQL语句。</p><p>默认情况下， 查询日志是未开启的。</p><p>开启查询日志注意事项：</p><p>1、开启查询日志会对MySQL的性能产生一定影响，特别是在高负载环境下。因此，在生产环境中建议谨慎使用，并根据需要进行开启和关闭。</p><p>2、查询日志可能会记录大量的查询语句，导致日志文件过大。可以通过定期清理或限制日志文件大小来处理这个问题。</p><p>3、查询日志可能会包含敏感信息（如密码），因此要确保只有授权的人员可以访问查询日志文件。</p><h2 id="1-4-慢查询日志"><a href="#1-4-慢查询日志" class="headerlink" title="1.4 慢查询日志"></a>1.4 慢查询日志</h2><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值，long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。</p><h3 id="1-4-1-慢日志参数配置"><a href="#1-4-1-慢日志参数配置" class="headerlink" title="1.4.1 慢日志参数配置"></a>1.4.1 慢日志参数配置</h3><p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</p><p>慢查询日志默认是关闭的 。可以通过两个参数来控制慢查询日志 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;%slow_query_log%&#x27;;<br>SHOW VARIABLES LIKE &#x27;%long_query_time%&#x27;; -- 查看值：默认10秒<br></code></pre></td></tr></table></figure><p>在mysql 的配置文件 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;my.cnf 中配置如下内容 ： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[mysqld]<br>slow_query_log = 1  #开启<br>slow_query_log_file = /var/lib/mysql/slow-query.log   # 若没有指定，默认名字为hostname_slow.log<br>long_query_time = 1 # 将默认的10秒为慢 修改为1秒为慢<br><br>log_queries_not_using_indexes = 1<br></code></pre></td></tr></table></figure><p>重启mysql进行测试。</p><h3 id="1-4-2-日志内容读取"><a href="#1-4-2-日志内容读取" class="headerlink" title="1.4.2 日志内容读取"></a>1.4.2 日志内容读取</h3><p>1、执行查询操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_emp ;<br></code></pre></td></tr></table></figure><p>由于在查询的执行时间小于10s，因此该查询不会记录到慢查询日志中。</p><p>模拟慢查询效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_emp <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> sleep(<span class="hljs-number">2</span>) ;   <span class="hljs-comment">-- 使用SLEEP函数可以让查询暂停指定的时间</span><br></code></pre></td></tr></table></figure><p>查看慢查询日志内容：</p><h1 id="2-MySQL事务日志"><a href="#2-MySQL事务日志" class="headerlink" title="2 MySQL事务日志"></a>2 MySQL事务日志</h1><h2 id="2-1-事务概述"><a href="#2-1-事务概述" class="headerlink" title="2.1 事务概述"></a>2.1 事务概述</h2><p>概述：就是由多个操作组成的一个逻辑单元，组成这个逻辑单元的多个操作要么都成功要么都失败。</p><p>作用：保证数据的一致性</p><p>举例：转账</p><h2 id="2-2-ACID四大特性"><a href="#2-2-ACID四大特性" class="headerlink" title="2.2 ACID四大特性"></a>2.2 ACID四大特性</h2><p><strong>A：原子性(Atomicity)</strong></p><p>一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。(undo log)</p><p><strong>C：一致性(Consistency)</strong></p><p>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。(MVCC undo log)</p><p><strong>I：隔离性(Isolation)</strong></p><p>指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p><p>事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。(锁)</p><p><strong>D：持久性(Durability)</strong></p><p>指的是只要事务成功结束，它对数据库所做的更新就必须保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。(redo log)</p><p>注意：新内容来了</p><p>1、事务的隔离性由 <strong>锁机制</strong> 实现。</p><p>2、而事务的原子性、一致性和持久性由事务的 <strong>redo日志</strong>和<strong>undo日志</strong>来保证。</p><ul><li><p>redo log称为重做日志 ，它记录了对数据库进行修改的操作，包括插入、更新和删除等。Redo日志的主要作用是保证数据库的持久性和恢复能力。</p></li><li><p>undo log称为回滚日志 ，它记录了对数据库进行修改的操作的<strong>逆操作</strong>，用于实现事务的回滚和MVCC（多版本并发控制）。</p></li></ul><h2 id="2-3-redo日志"><a href="#2-3-redo日志" class="headerlink" title="2.3 redo日志"></a>2.3 redo日志</h2><h3 id="2-3-1-简介"><a href="#2-3-1-简介" class="headerlink" title="2.3.1 简介"></a>2.3.1 简介</h3><p>MySQL的Redo Log（重做日志）是一种用于数据持久性和故障恢复的重要机制。Redo Log记录了对数据库中数据的修改操作，以确保数据在发生故障时不会丢失，并且能够在数据库恢复后正确地恢复到修改前的状态。</p><p>目的：Redo Log的主要目的是记录对数据库的写操作（如INSERT、UPDATE、DELETE），而不是读操作。它是用于持久性的日志，在事务提交之前，将修改操作记录到Redo Log中，而不是直接写入磁盘上的数据文件。这样即使在数据库异常崩溃时，可以通过Redo Log来重新执行已提交的事务，保证数据的完整性。</p><p>Innodb引擎采用的是WAL技术(write-ahead logging) , 这种技术就是先写日志，再写磁盘，只有日志写入成功，为崩溃恢复准备</p><p>才算事务提交成功，这里的日志就是redo log。</p><p>redo  log可以简单分为以下两个部分：</p><p>1、重做日志的缓冲 (<strong>redo log buffer</strong>) </p><p>是一个内存缓冲区，用于暂时存储事务的Redo Log记录。当一个事务提交时，其对应的Redo Log记录会先写入到Redo Log Buffer中。然后，MySQL会根据Redo Log Buffer的刷新策略将其中的数据刷写到Redo Log File。</p><p>redo log buffer 大小，默认 16M ，最大值是4096M，最小值为1M。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%innodb_log_buffer_size%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>2、重做日志文件 (<strong>redo log file</strong>) ，保存在硬盘中，是持久的。redo log日志文件如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /var/lib/docker/volumes/mysql8_data/_data/<br>ls -a<br></code></pre></td></tr></table></figure><h3 id="2-3-2-redolog工作流程和组成"><a href="#2-3-2-redolog工作流程和组成" class="headerlink" title="2.3.2 redolog工作流程和组成"></a>2.3.2 redolog工作流程和组成</h3><p>逻辑上 redo log buffer 是一个 <strong>环形队列</strong>：</p><ul><li><strong>write pos</strong>：当前写入位置。</li><li><strong>checkpoint</strong>：当前已刷入磁盘并可覆盖的位置。</li><li>规则：<code>write pos</code> 追上 <code>checkpoint</code> 时表示日志满了，不能写新事务    如下面这个图所示。</li></ul><img src="./../img/image-20251116090722076.png" alt="image-20251116090722076" style="zoom: 33%;" /><p>checkPoint机制:   作用是将缓冲池中的脏页（(更改完之后的数据）刷新到磁盘</p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。write pos 和 checkpoint 之间的是redolog中还空着的部分，可以用来记录新的操作。</p><p>如果 write pos 追上 checkpoint，表示redolog满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失</p><p><strong>整体写数据的流程如下所示</strong></p><p><img src="/./../img/image-20251116090933421.png" alt="image-20251116090933421"></p><p>整体流程说明：</p><p>第1步事务开始：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 </p><p>第2步事务修改数据：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 </p><p>第3步事务提交：当事务commit时，根据刷盘策略决定是否将redo log buffer中的内容刷新到 redo log file，  刷盘完成后，事务才算真正持久化成功 （满足 WAL：Write Ahead Logging）</p><p>第4步奔溃恢复：InnoDB 重启后会根据 redo log 恢复未刷盘的数据，保证 <strong>事务的持久性（D）</strong></p><h3 id="2-3-3-redo-log的刷盘策略"><a href="#2-3-3-redo-log的刷盘策略" class="headerlink" title="2.3.3 redo log的刷盘策略"></a>2.3.3 redo log的刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以 一定策略将redo log buffer刷入到真正的redo log file 中。这里的策略这就是我们要说的刷盘策略。</p><img src="./../img/image-20251116091023088.png" alt="image-20251116091023088" style="zoom: 67%;" /><p>InnoDB给出 <strong>innodb_flush_log_at_trx_commit</strong> 参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查看innodb_flush_log_at_trx_commit变量的值<br>SHOW VARIABLES LIKE &#x27;%innodb_flush_log_at_trx_commit%&#x27;;<br></code></pre></td></tr></table></figure><p>它支持三种策略：</p><p><strong>0</strong>：事务提交时 <strong>不写磁盘</strong>，只是写入 Log Buffer；每秒刷一次盘。</p><ul><li>性能最好，持久性最差（宕机可能丢 1 秒数据 + 已提交事务）。</li></ul><p><strong>1（默认）</strong>：事务每次提交时，<strong>写入 Log Buffer 并立刻刷盘</strong>（fsync）。</p><ul><li>最安全，保证事务提交后不会丢失。</li><li>性能开销最大（频繁 fsync）。</li></ul><p><strong>2</strong>：事务提交时，<strong>写入 OS 缓冲区</strong>（write），由 OS 自己决定什么时候 fsync（通常 1s 内）。</p><ul><li>折中方案，宕机时可能丢 OS buffer 中的数据</li></ul><h2 id="2-4-undo日志"><a href="#2-4-undo日志" class="headerlink" title="2.4 undo日志"></a>2.4 undo日志</h2><h3 id="2-4-1-undo日志简介"><a href="#2-4-1-undo日志简介" class="headerlink" title="2.4.1 undo日志简介"></a>2.4.1 undo日志简介</h3><p><strong>MySQL中的Undo Log是用于支持事务原子性和一致性读的关键组件。它记录了对数据的修改操作，使得在事务回滚或进行一致性读取时，可以撤销或恢复数据到先前的状态。</strong></p><p>当执行一个事务时，MySQL会将事务对数据的修改操作记录在Undo Log中，而不是直接在数据页上进行修改。这样做的好处是，即使事务执行过程中出现错误或被回滚，也可以通过Undo Log来撤销对数据的修改，使得数据库保持一致性。</p><p>在一致性读取（Consistent Read）中，如果一个事务在读取某个数据时，同时另一个事务在修改该数据，那么读取的事务会通过Undo Log来获取未修改的原始数据，从而保证读取的数据是一致的。</p><h3 id="2-4-2-undo-log存储结构"><a href="#2-4-2-undo-log存储结构" class="headerlink" title="2.4.2 undo log存储结构"></a>2.4.2 undo log存储结构</h3><h4 id="回滚段与undo页"><a href="#回滚段与undo页" class="headerlink" title="回滚段与undo页"></a>回滚段与undo页</h4><p>InnoDB对undo log的管理采用段的方式，也就是回滚段（<strong>rollback segment</strong>） 。每个回滚段记录了 1024 个 <strong>undo log segment</strong> ，而在每个undo log segment段中进行 <strong>undo页</strong> (存储的就是回滚记录)的申请。 在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 1024 。虽然对绝大多数的应用来说都已经够用。 从1.1版本开始InnoDB支持最大 128个rollback segment ，故其支持同时在线的事务限制提高到 了 128*1024 。</p><h4 id="undo页的重用"><a href="#undo页的重用" class="headerlink" title="undo页的重用"></a>undo页的重用</h4><p>在MySQL中，undo页的重用是指当事务提交或回滚后，<strong>之前使用的undo页可以被重新利用</strong>来存储新的事务的undo信息。这个过程称为undo页的重用。</p><p>Undo页是用于实现事务的回滚和MVCC（多版本并发控制）机制的关键组成部分。当一个事务执行更新操作时，旧的数据会被写入到undo页中，以便在事务回滚时能够恢复到之前的状态。而在MVCC中，每个事务都可以看到自己开始之前的数据库快照，这些快照通过undo页来实现。</p><p><strong>当一个事务提交或回滚后，其对应的undo页就不再需要了</strong>。为了节省空间和提高性能，MySQL会将这些不再需要的undo页标记为可重用状态，并将它们添加到一个undo页的空闲链表中。当新的事务需要分配undo页时MySQL会首先尝试从空闲链表中获取可重用的undo页，而不是分配新的页。</p><p>通过重用undo页，可以减少对磁盘空间的需求，提高系统性能。然而，如果系统中存在长时间运行的读事务或长时间运行的只读事务，可能会导致undo页无法及时重用，从而增加了undo段的大小和磁盘空间的占用。</p><h4 id="回滚段与事务"><a href="#回滚段与事务" class="headerlink" title="回滚段与事务"></a>回滚段与事务</h4><p>1、每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p><p>2、当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p><p>3、当事务提交时，InnoDB存储引擎会做以下两件事情： </p><ul><li>将undo log放入列表中，以供之后的purge(<strong>清理</strong>)操作 </li><li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ul><h4 id="回滚段中的数据分类"><a href="#回滚段中的数据分类" class="headerlink" title="回滚段中的数据分类"></a>回滚段中的数据分类</h4><p>uncommitted undo information</p><p>未提交的回滚数据（uncommitted undo information）是指在<strong>事务执行过程中所做的修改，但尚未提交的数据</strong>。</p><p>committed undo information</p><p>已经提交但未过期的回滚数据（committed undo information）是指在事务执行过程中所做的修改，并且已经成功提交到数据库中的数据。</p><p>expired undo information</p><p>事务已经提交并过期的数据（expired undo information）是指在事务执行过程中所做的修改，并且已经成功提交到数据库中，但由于某些原因被标记为可回收的数据</p><h3 id="2-4-3-undo-log类型"><a href="#2-4-3-undo-log类型" class="headerlink" title="2.4.3 undo log类型"></a>2.4.3 undo log类型</h3><p>select 查询操作不会生成 undo log</p><p>在InnoDB存储引擎中，undo log分为：insert undo log和update undo log</p><h4 id="insert-undo-log"><a href="#insert-undo-log" class="headerlink" title="insert undo log"></a>insert undo log</h4><p>Insert undo log（插入撤销日志）是数据库中用于记录<strong>插入操作</strong>的一种撤销日志。因为insert操作的记录，只对事务本身可见，对其他事务不可见(这是事务的隔离性的要求)，因此 undo log可以在<strong>事务提交之后删除</strong>。</p><h4 id="update-undo-log"><a href="#update-undo-log" class="headerlink" title="update undo log"></a>update undo log</h4><p>Update undo log（更新撤销日志）是数据库中用于记录<strong>更新操作(delete、update)<strong>的一种撤销日志。该undo log可能需要提供MVCC机制，因此不能</strong>在事务提交时就进行删除。提交是放入undo log链表，等待purge线程进行最后的删除。</strong></p><h3 id="2-4-4-undo-log的生命周期"><a href="#2-4-4-undo-log的生命周期" class="headerlink" title="2.4.4 undo log的生命周期"></a>2.4.4 undo log的生命周期</h3><h4 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始:"></a>事务开始:</h4><p>对于InnoDB引擎来说，每个行记录除了记录本身的数据之外，还有几个隐藏的列：</p><p>1、DB_ROW_ID: 如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么InnoDB会自动为表添加一个row_id的隐藏列作为主键。</p><p>2、DB_TRX_ID: 每个事务都会分配一个事务的ID，当对某条记录发生变更时，就会将这个事务的事务ID写入trx_id中。</p><p>3、DB_ROLL_PTR(roll_pointer ): 回滚指针，本质上就是指向undo log的指针。</p><p><img src="/./../img/image-20251116095953849.png" alt="image-20251116095953849"></p><p>当我们执行INSERT时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">INSERT INTO</span> <span class="hljs-keyword">user</span> (name) <span class="hljs-keyword">VALUES</span> (&quot;tom&quot;);<br></code></pre></td></tr></table></figure><p>插入的数据都会生成一条insert undo log , 并且数据的回滚指针会指向它。undo log会记录undo log的序号，插入主键的列和值…., 那么在进行rollback的时候，通过主键直接把对应的数据删除即可。</p><p><img src="/./../img/image-20251116100008460.png" alt="image-20251116100008460"></p><p>当我们执行UPDATE时：</p><p>对于更新的操作会产生update undo log，并且会分更新主键的和不更新主键的，假设现在执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Sun&#x27;</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ;<br></code></pre></td></tr></table></figure><p><img src="/./../img/image-20251116100019766.png" alt="image-20251116100019766"></p><p>这时会把老的记录写入新的undo log，让回滚指针指向新的undo log，它的undo log是1，并且新的undo log会指向老的undo log(undo no &#x3D; 0)。</p><p>假设现在执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ;<br></code></pre></td></tr></table></figure><p>对于更新主键的操作，会先<strong>把原来的数据deletemark标识打开</strong>，这时并没有真正的删除数据，真正的删除会交给<strong>清理线程</strong>去判断，然后在后面插入一条新的数据，新数据也会产生undo log，并且undo log的序号会递增。</p><p>可以发现每次对数据的变更都会产生一个undo log，当一条记录被变更多次时，那么就会产生多条undo log，undo log记录的是变更前的日志，并且每个undo log的序号是递增的，那么要当回滚的时候，按照序号依次向前，这样就会找到原始数据了。</p><p>备注:</p><p>“deletemark”这个词在MySQL或InnoDB中并不是一个实际存在的术语，它只是用于解释逻辑删除的概念，而实际上逻辑删除是通过添加特殊标志字段来实现的</p><h4 id="undo-log的删除"><a href="#undo-log的删除" class="headerlink" title="undo log的删除"></a>undo log的删除</h4><p>1、针对于insert undo log 因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。 </p><p>2、针对于update undo log 该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p><h4 id="undolog总结"><a href="#undolog总结" class="headerlink" title="undolog总结"></a>undolog总结</h4><ol><li>事务开始： 当事务开始时，MySQL 会为该事务分配一个唯一的事务 ID，并为该事务启动一个对应的 undo log。这个 undo log 会在整个事务的生命周期中跟随事务，并记录事务所做的数据修改操作。</li><li>数据修改： 在事务执行期间，如果对数据库中的数据进行了修改操作（例如插入、更新、删除等），这些修改操作会被记录在事务对应的 undo log 中。这些修改是尚未提交的，只存在于事务的私有工作区中。</li><li>事务提交或回滚： 当事务执行完成后，会进入提交或回滚阶段。<ul><li>如果事务被提交，那么在提交之前，MySQL 会将事务的修改操作应用到数据库中，并将这些修改标记为已提交。这意味着这些修改将永久保存在数据库中，并可以被其他事务所见。</li><li>如果事务被回滚，那么在回滚之前，MySQL 会撤销事务的修改操作，恢复数据到事务开始前的状态。这是通过 undo log 记录的原始数据来实现的。</li></ul></li><li>回收： 当事务完成提交或回滚后，其对应的 undo log 将不再需要，因为数据已经被应用或回滚到了相应的状态。此时，MySQL 会对这些已经不再需要的 undo log 进行回收，释放相应的空间，以便重用。</li><li>版本链的维护： 在使用 MVCC 时，为了支持并发访问和事务隔离性，MySQL 需要维护一个版本链（version chain）。每个数据行都可能存在多个版本，每个版本都有一个对应的 undo log 记录。在查询时，MySQL 会根据事务的隔离级别和时间戳来选择合适的版本。</li></ol><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="有了undolog为啥还需要redolog呢？"><a href="#有了undolog为啥还需要redolog呢？" class="headerlink" title="有了undolog为啥还需要redolog呢？"></a>有了undolog为啥还需要redolog呢？</h3><p>Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p><p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p><p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p><p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p><p>过程如下图：</p><p><img src="/./../img/1717920899043-30125c0d-bd83-4ca7-9784-07b70c362168.png" alt="img"></p><p>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p><p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p><p>redo log 和 undo log 这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p><ul><li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li><li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li></ul><p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务，如下图：</p><img src="https://cdn.xiaolincoding.com//picgo/1717920935536-45ceca35-c79c-48eb-a240-96d580e399b5.png" alt="img" style="zoom: 67%;" /><p>所以有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>（崩溃恢复）。可以看出来， <strong>redo log 保证了事务四大特性中的持久性</strong>。</p><p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p><p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p><p>针对「顺序写」为什么比「随机写」更快这个问题，可以比喻为你有一个本子，按照顺序一页一页写肯定比写一个字都要找到对应页写快得多。</p><p>可以说这是 WAL 技术的另外一个优点：<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。</p><p>两者的工作过程：</p><ol><li><strong>事务执行中</strong>：<br> → 先写 <strong>undo log</strong>（为回滚准备）<br> → 再写 <strong>redo log</strong>（为崩溃恢复准备）</li><li><strong>事务提交</strong>：<br> → 先确保 <strong>redo log 刷盘</strong>（持久化）<br> → 再释放 undo log（节省空间）</li><li><strong>系统崩溃恢复</strong>：<br> → 用 <strong>redo log 重做已提交事务</strong><br> → 用 <strong>undo log 回滚未提交事务</strong></li></ol><h4 id="至此，-针对为什么需要-redo-log"><a href="#至此，-针对为什么需要-redo-log" class="headerlink" title="至此， 针对为什么需要 redo log"></a>至此， 针对为什么需要 redo log</h4><p>这个问题我们有两个答案：</p><ul><li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li><li>redo log 和 undo log 这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：<ul><li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；只解决“<strong>系统崩溃</strong>”的问题。</li><li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；只解决“<strong>事务中途失败</strong>”的问题</li></ul></li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li></ul><h3 id="能不能只用binlog不用relo-log？"><a href="#能不能只用binlog不用relo-log？" class="headerlink" title="能不能只用binlog不用relo log？"></a>能不能只用binlog不用relo log？</h3><p>不行，binlog是 server 层的日志，没办法记录哪些脏页还没有刷盘，redolog 是存储引擎层的日志，可以记录哪些脏页还没有刷盘，这样崩溃恢复的时候，就能恢复那些还没有被刷盘的脏页数据。</p><h3 id="binlog-两阶段提交过程是怎么样的？"><a href="#binlog-两阶段提交过程是怎么样的？" class="headerlink" title="binlog 两阶段提交过程是怎么样的？"></a>binlog 两阶段提交过程是怎么样的？</h3><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p><p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了<strong>内部 XA 事务</strong>（是的，也有外部 XA 事务，跟本文不太相关，我就不介绍了），内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。</p><p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong>，如下图：</p><p><img src="/./../img/image-20240725231904598.png" alt="image-20240725231904598"></p><p>从图中可看出，事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong>，具体如下：</p><ul><li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit &#x3D; 1 的作用）；</li><li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog &#x3D; 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li></ul><p>我们来看看在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象？下图中有时刻 A 和时刻 B 都有可能发生崩溃：</p><p><img src="/./../img/image-20240725231850469.png" alt="image-20240725231850469"></p><p>不管是时刻 A（redo log 已经写入磁盘， binlog 还没写入磁盘），还是时刻 B （redo log 和 binlog 都已经写入磁盘，还没写入 commit 标识）崩溃，<strong>此时的 redo log 都处于 prepare 状态</strong>。</p><p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：</p><ul><li><strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。对应时刻 A 崩溃恢复的情况。</li><li><strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</strong>。对应时刻 B 崩溃恢复的情况。</li></ul><p>可以看到，<strong>对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID</strong>，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。</p><p>所以说，<strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong>，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。</p><h4 id="背诵"><a href="#背诵" class="headerlink" title="背诵"></a>背诵</h4><p><strong>“先写redo prepare，再写binlog，最后commit redo。<br> 崩溃看binlog：有XID就提交，无XID就回滚！”</strong></p><h3 id="讲一下binlog"><a href="#讲一下binlog" class="headerlink" title="讲一下binlog"></a>讲一下binlog</h3><p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件，binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用。</p><p>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志，用于备份恢复、主从复制；</p><p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p><p>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED</p><h3 id="为什么要写RedoLog，而不是直接写到B-树里面？"><a href="#为什么要写RedoLog，而不是直接写到B-树里面？" class="headerlink" title="为什么要写RedoLog，而不是直接写到B+树里面？"></a>为什么要写RedoLog，而不是直接写到B+树里面？</h3><p>因为 redolog 写入磁盘是顺序写，而 b+树里数据页写入磁盘是随机写，顺序写的性能会比随机写好，这样可以提升事务提交的效率。</p><p>最重要的是redolog具备故障恢复的能力，Redo Log 记录的是物理级别的修改，包括页的修改，如插入、更新、删除操作在磁盘上的物理位置和修改内容。</p><h3 id="mysql-两次写（double-write-buffer）了解吗？"><a href="#mysql-两次写（double-write-buffer）了解吗？" class="headerlink" title="mysql 两次写（double write buffer）了解吗？"></a>mysql 两次写（double write buffer）了解吗？</h3><p>我们常见的服务器一般都是Linux操作系统，Linux文件系统页（OS Page）的大小默认是4KB。而MySQL的页（Page）大小默认是16KB。</p><p>MySQL程序是跑在Linux操作系统上的，需要跟操作系统交互，所以MySQL中一页数据刷到磁盘，要写4个文件系统里的页。</p><p><img src="/./../img/1737301125998-6ecd9068-6603-4932-81c4-b54cf2984fb6.png" alt="img"></p><p>需要注意的是，这个操作并非原子操作，比如我操作系统写到第二个页的时候，Linux机器断电了，这时候就会出现问题了。造成”页数据损坏“。并且这种”页数据损坏“靠 redo日志是无法修复的。</p><p>Doublewrite Buffer的出现就是为了解决上面的这种情况，虽然名字带了Buffer，但实际上Doublewrite Buffer是内存+磁盘的结构。</p><p><img src="/./../img/1737302055987-847a5e01-f883-4b5c-8c36-26ffad1f6f69.png" alt="img"></p><p>Doublewrite Buffer 作用是，在把页写到数据文件之前，InnoDB先把它们写到一个叫doublewrite buffer（双写缓冲区）的共享表空间内，在写doublewrite buffer完成后，InnoDB才会把页写到数据文件的适当的位置。如果在写页的过程中发生意外崩溃，InnoDB在稍后的恢复过程中在doublewrite buffer中找到完好的page副本用于恢复，所以本质上是一个最近写回的页面的备份拷贝。</p><p><img src="/./../img/1737301211946-81988282-fb5d-44f9-b8d8-94f7396db723.png" alt="img"></p><p>如上图所示，当有页数据要刷盘时：</p><ul><li>页数据先通过memcpy函数拷贝至内存中的Doublewrite Buffer（大小为约 2MB）中，Doublewrite Buffer 分为两个区域，每次写入一个区域（最多 1MB 的数据）。</li><li>Doublewrite Buffer的内存里的数据页，会fsync刷到Doublewrite Buffer的磁盘上，写两次到到共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；</li><li>写入完成后，再将脏页刷到数据磁盘存储.ibd文件上（随机写）；</li></ul><p>当MySQL出现异常崩溃时，有如下几种情况发生：</p><ul><li>情况一：步骤1前宕机，刷盘未开始，数据在redo log，后期可以恢复</li><li>情况二：步骤1后，步骤2前宕机，因为是在内存中，宕机清空内存，和情况1一样</li><li>情况三：步骤2后，步骤3前宕机，因为DWB的磁盘有完整的数据，可以修复损坏的页数据</li></ul><p>由此我们可以得出结论，double write buffer是针对实际的buffer数据页的原子性保证，就是避免MySQL异常崩溃时，写的那几个data page不会出错，要么都写了，要么什么都没有做。</p><blockquote><p>为什么redolog无法代替double write buffer？</p></blockquote><p>redolog的设计之初，是“账本的作用”，是一种操作日志，用于MySQL异常崩溃恢复使用，是InnoDB引擎特有的日志，本质上是物理日志，记录的是 “ 在某个数据页上做了什么修改 ” ，</p><p>但如果数据页本身已经发生了损坏，redolog来恢复已经损坏的数据块是无效的，数据块的本身已经损坏，再次重做依然是一个坏块。 </p><p>所以此时需要一个数据块的副本来还原该损坏的数据块，再利用重做日志进行其他数据块的重做操作，这就是double write buffer的原因作用。</p><h1 id="MySQL的Buffer-Pool：数据库的”记忆库”"><a href="#MySQL的Buffer-Pool：数据库的”记忆库”" class="headerlink" title="MySQL的Buffer Pool：数据库的”记忆库”"></a>MySQL的Buffer Pool：数据库的”记忆库”</h1><p><strong>Buffer Pool（缓冲池）是MySQL InnoDB存储引擎中最重要的内存组件之一，相当于数据库的”快速记忆库”。</strong> 它主要用于缓存数据和索引，大幅减少磁盘I&#x2F;O，让数据库运行得更快。</p><h2 id="1-Buffer-Pool的核心作用"><a href="#1-Buffer-Pool的核心作用" class="headerlink" title="1. Buffer Pool的核心作用"></a>1. Buffer Pool的核心作用</h2><table><thead><tr><th>作用</th><th>说明</th><th>速度对比</th></tr></thead><tbody><tr><td><strong>缓存数据页</strong></td><td>将经常访问的表数据存储在内存中</td><td>内存访问：0.1ms 磁盘访问：10ms+</td></tr><tr><td><strong>缓存索引页</strong></td><td>将B+树索引结构缓存到内存</td><td>使查询更快定位数据</td></tr><tr><td><strong>减少磁盘I&#x2F;O</strong></td><td>避免重复从磁盘读取相同数据</td><td>提升性能3-10倍</td></tr></tbody></table><blockquote><p>💡 <strong>简单比喻</strong>：就像你家的冰箱（Buffer Pool）会提前把常吃的菜（数据）放进去，不用每次做饭都去超市（磁盘）买，节省大量时间。</p></blockquote><h2 id="2-Buffer-Pool的工作原理"><a href="#2-Buffer-Pool的工作原理" class="headerlink" title="2. Buffer Pool的工作原理"></a>2. Buffer Pool的工作原理</h2><h3 id="读操作流程（缓存命中）"><a href="#读操作流程（缓存命中）" class="headerlink" title="读操作流程（缓存命中）"></a>读操作流程（缓存命中）</h3><img src="./../img/tongyi-mermaid-2025-11-17-121727.png" alt="tongyi-mermaid-2025-11-17-121727" style="zoom: 33%;" /><h3 id="写操作流程（写入优化）"><a href="#写操作流程（写入优化）" class="headerlink" title="写操作流程（写入优化）"></a>写操作流程（写入优化）</h3><ol><li><strong>先修改内存</strong>：更新Buffer Pool中的数据页</li><li><strong>记录日志</strong>：将修改写入redo log（保证数据安全）</li><li><strong>异步刷盘</strong>：后台线程在适当时候将修改写入磁盘</li></ol><blockquote><p>✅ 这种”先内存后磁盘”的机制是InnoDB高性能的关键</p></blockquote><h2 id="3-Buffer-Pool的内部结构"><a href="#3-Buffer-Pool的内部结构" class="headerlink" title="3. Buffer Pool的内部结构"></a>3. Buffer Pool的内部结构</h2><table><thead><tr><th>组件</th><th>功能</th><th>重要性</th></tr></thead><tbody><tr><td><strong>LRU列表</strong></td><td>管理缓存页，最近最少使用的页会被淘汰</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>Change Buffer</strong></td><td>缓存二级索引的更新（非聚集索引）</td><td>⭐⭐⭐</td></tr><tr><td><strong>Adaptive Hash Index</strong></td><td>基于热点数据构建哈希索引，加速等值查询</td><td>⭐⭐⭐</td></tr><tr><td><strong>Free List</strong></td><td>记录空闲的缓存页</td><td>⭐⭐</td></tr></tbody></table><blockquote><p>📌 <strong>关键点</strong>：InnoDB使用了改进的LRU算法（不是简单的LRU），避免”热点数据”被频繁淘汰。</p></blockquote><h2 id="4-为什么Buffer-Pool如此重要？"><a href="#4-为什么Buffer-Pool如此重要？" class="headerlink" title="4. 为什么Buffer Pool如此重要？"></a>4. 为什么Buffer Pool如此重要？</h2><ul><li><strong>磁盘I&#x2F;O是数据库性能瓶颈</strong>：磁盘读写比内存慢10000倍以上</li><li><strong>典型场景</strong>：在电商大促时，Buffer Pool能确保系统快速响应</li><li><strong>配置影响</strong>：Buffer Pool占系统内存的50%-70%时性能最佳</li></ul><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21优化</title>
    <link href="/2025/11/15/21%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"/>
    <url>/2025/11/15/21%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><h2 id="5-1-性能分析（explain）"><a href="#5-1-性能分析（explain）" class="headerlink" title="5.1. 性能分析（explain）"></a>5.1. 性能分析（explain）</h2><p>很多现象需要在5.5才能演示成功。</p><h3 id="5-1-1-explain是什么"><a href="#5-1-1-explain是什么" class="headerlink" title="5.1.1. explain是什么?"></a>5.1.1. explain是什么?</h3><h3 id="模拟优化器查看执行计划"><a href="#模拟优化器查看执行计划" class="headerlink" title="模拟优化器查看执行计划"></a><strong>模拟优化器查看执行计划</strong></h3><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的<strong>性能瓶颈</strong></p><h3 id="5-1-2-explain能干什么？"><a href="#5-1-2-explain能干什么？" class="headerlink" title="5.1.2. explain能干什么？"></a>5.1.2. explain能干什么？</h3><ul><li><p><font color='red'>表的读取顺序</font></p></li><li><p>那些索引可以使用</p></li><li><p>数据读取操作的操作类型</p></li><li><p><font color='red'>那些索引被实际使用</font></p></li><li><p>表之间的引用</p></li><li><p><font color='red'>每张表有多少行被物理查询</font></p></li></ul><h3 id="5-1-3-explain怎么玩？"><a href="#5-1-3-explain怎么玩？" class="headerlink" title="5.1.3. explain怎么玩？"></a>5.1.3. explain怎么玩？</h3><p><font color='red'>explain + SQL语句</font></p><h3 id="5-1-4-各字段解释"><a href="#5-1-4-各字段解释" class="headerlink" title="5.1.4. 各字段解释"></a>5.1.4. 各字段解释</h3><h4 id="5-1-4-1-id查询序列号"><a href="#5-1-4-1-id查询序列号" class="headerlink" title="5.1.4.1. id查询序列号"></a>5.1.4.1. id查询序列号</h4><p>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p><p>关注点：<font color='red'>每个id号码，表示一趟独立的查询。一个sql 的查询趟数越少越好。</font></p><p>四种情况：</p><ol><li><p>id相同，执行顺序由上至下。例如上图</p></li><li><p>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p></li><li><p>id既有相同又有不同</p></li><li><p>id为null最后执行</p></li></ol><h4 id="5-1-4-2-select-type"><a href="#5-1-4-2-select-type" class="headerlink" title="5.1.4.2. select_type"></a>5.1.4.2. select_type</h4><p>查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询</p><table><thead><tr><th>查询类型</th><th>描述</th></tr></thead><tbody><tr><td><code>SIMPLE</code></td><td>简单查询，查询中不包含子查询或者UNION。</td></tr><tr><td><code>PRIMARY</code></td><td>主查询，查询中若包含子查询，则最外层查询被标记为PRIMARY 案例1</td></tr><tr><td><code>DERIVED</code></td><td>在包含派生表（子查询在from子句中）的查询中，MySQL会递归执行这些子查询，把结果放在临时表里。EXPLAIN select * from t1, (select 2) as v;</td></tr><tr><td><code>SUBQUERY</code></td><td>子查询，在SELECT或WHERE列表中包含了子查询。案例2</td></tr><tr><td><code>DEPENDENT SUBQUERY</code></td><td>如果包含了子查询，查询语句不能被优化器转换为连接查询，并且子查询是相关子查询（子查询基于外部数据列)。案例3</td></tr><tr><td><code>UNCACHEABLE SUBQUERY</code></td><td>表示一个子查询（subquery）被标记为无法缓存。在某些数据库管理系统中，查询优化器会尝试将查询结果缓存起来以提高性能，但对于被标记为UNCACHEABLE的子查询，查询优化器将不会缓存其结果 。案例4</td></tr><tr><td><code>UNION</code></td><td>对于包含UNION或者UNION ALL的查询语句，除了最左边的查询是PRIMARY，其余的查询都是UNION。案例5</td></tr><tr><td><code>UNION RESULT</code></td><td>UNION会对查询结果进行查询去重，MYSQL会使用临时表来完成UNION查询的去重工作，针对这个临时表的查询就是”UNION RESULT”。案例5</td></tr></tbody></table><h4 id="5-1-4-3-table"><a href="#5-1-4-3-table" class="headerlink" title="5.1.4.3. table"></a>5.1.4.3. table</h4><p>显示这一行的数据是关于哪张表的</p><h4 id="5-1-4-4-partitions"><a href="#5-1-4-4-partitions" class="headerlink" title="5.1.4.4. partitions"></a>5.1.4.4. partitions</h4><p>代表分区表中的命中情况，非分区表，该项为null</p><h4 id="5-1-4-5-type"><a href="#5-1-4-5-type" class="headerlink" title="5.1.4.5. type*"></a>5.1.4.5. type*</h4><p><img src="/./../img/image-20251115214304209.png" alt="image-20251115214304209">😽😽😽</p><p>type显示的是访问类型，用于描述查询引擎在执行查询时使用的访问方法 。是较为重要的一个指标</p><p><strong>一般来说，保证查询至少达到range级别，最好能达到ref。</strong></p><p>常见：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</p><p><strong>system</strong>：表示只有一行数据的表，这是最快的访问方式</p><p><strong>const</strong>：针对主键或唯一索引的等值查询扫描，最多只返回一行数据。const 查询速度非常快, 因为它仅仅读取一次即可。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from t1 where t1.id=1<br></code></pre></td></tr></table></figure><p><strong>eq_ref</strong>：表示使用了连接（join）查询，并且连接条件是通过唯一索引进行的等值比较。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from t1,t2 where t1.id=t2.id<br></code></pre></td></tr></table></figure><p><strong>ref</strong>：表示使用了非唯一索引进行的等值比较，可能返回多个匹配的行。例如：（content1列创建了单值索引）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain  select * from t4 where t4.content1 = &#x27;&#x27;<br></code></pre></td></tr></table></figure><p><strong>range</strong>：只检索给定范围的行，一般就是在你的where语句中出现了between、&lt;、&gt;、!&#x3D;等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from t1 where t1.id&lt;10<br></code></pre></td></tr></table></figure><p><strong>index</strong>：表示全索引扫描，即遍历整个索引树来获取结果，而<strong>不需要回表</strong>查找数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select id from t1<br></code></pre></td></tr></table></figure><p><strong>all</strong>：Full Table Scan，将遍历全表以找到匹配的行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from t2<br></code></pre></td></tr></table></figure><h4 id="5-1-4-6-possible-keys"><a href="#5-1-4-6-possible-keys" class="headerlink" title="5.1.4.6. possible_keys"></a>5.1.4.6. possible_keys</h4><p>显示当前查询可能用到的索引，一个或多个。查询涉及到的字段上若存在索引 则列出，<strong>但不一定被查询实际使用</strong></p><h4 id="5-1-4-7-key"><a href="#5-1-4-7-key" class="headerlink" title="5.1.4.7. key*"></a>5.1.4.7. key*</h4><p>keys表示实际使用的索引。如果为NULL，则没有使用索引</p><h4 id="5-1-4-8-key-len"><a href="#5-1-4-8-key-len" class="headerlink" title="5.1.4.8. key_len*"></a>5.1.4.8. key_len*</h4><p>表示索引使用的字节数，根据这个值可以判断索引的使用情况， 检查是否充分利用了索引，针对联合索引值越大越好。</p><p>如何计算：</p><ol><li><p>先看索引上字段的类型 + 长度。比如 int&#x3D;4；varchar(20) &#x3D;20；char(20) &#x3D;20</p><p>字符串：char(n)&#x3D;n；varchar(n)&#x3D;n</p><p>数值类型：tinyint&#x3D;1；smallint&#x3D;2；int&#x3D;4；bigint&#x3D;8</p><p>时间类型：date&#x3D;3；timestamp&#x3D;4；datetime&#x3D;8</p></li><li><p>如果是varchar或者char这种字符串字段，视字符集要乘不同的值。比如：utf-8要乘 3或者4，GBK要乘2</p></li><li><p>varchar要额外加2个字节</p></li><li><p>允许为NULL的字段额外加1个字节</p></li></ol><p>索引字段最好不要为NULL，因为NULL让统计更加复杂，并且需要额外一个字节的存储空间。</p><p>备注：<strong>key_len不包含order by&#x2F;group by使用到的索引列。</strong></p><h4 id="5-1-4-9-ref"><a href="#5-1-4-9-ref" class="headerlink" title="5.1.4.9. ref"></a>5.1.4.9. ref</h4><p>ref字段表示连接操作中使用的索引列</p><h4 id="5-1-4-10-rows"><a href="#5-1-4-10-rows" class="headerlink" title="5.1.4.10. rows*"></a>5.1.4.10. rows*</h4><p>rows字段的值是一个估计值，表示查询操作在执行时<strong>可能会扫描的行数</strong>。这个估计值是根据统计信息和查询优化器的算法得出的，并不是实际执行时的准确值。它可以用来帮助我们评估查询的性能和效率。rows字段的值越小越好!</p><h4 id="5-1-4-11-filtered"><a href="#5-1-4-11-filtered" class="headerlink" title="5.1.4.11. filtered"></a>5.1.4.11. filtered</h4><p>最后查询出来的数据占所有服务器端（server）检查行数（rows）的百分比。值越大越好。</p><h4 id="5-1-4-12-extra"><a href="#5-1-4-12-extra" class="headerlink" title="5.1.4.12. extra*"></a>5.1.4.12. extra*</h4><p>不适合在其他列中显示但十分重要的额外信息</p><p>using filesort和 Backward index scan 是Order By常见的两种排序算法</p><ol><li><p>using filesort：当查询涉及到排序操作时，MySQL可能会使用<code>filesort</code>算法来对结果进行排序。</p><p><strong>这通常发生在没有使用索引或无法使用索引进行排序的情况下</strong>。<code>filesort</code>会在内存中或磁盘上创建临时文件，并对结果进行排序操作。这可能会导致性能较差，特别是对于大型结果集和复杂的排序操作。</p></li><li><p>Backward index scan：当查询涉及到反向索引扫描时，MySQL可能会使用<code>Backward index scan</code>进行索引访问。反向索引扫描是指按照索引的逆序进行扫描，通常用于<code>ORDER BY DESC</code>等逆序排序操作。这在某些情况下可能会导致较慢的查询性能，因为索引的物理结构并不适合逆序扫描。</p></li></ol><p>在实际的查询优化中，应尽量避免或减少出现<code>using filesort</code>和<code>Backward index scan</code>的情况，以提高查询性能</p><p><font color="red"><strong>Using temporary</strong></font>：使用了临时表保存中间结果，常见于排序 order by 和分组查询 group by。group by和order by同时存在，且作用于不同的字段时，就会建立临时表，以便计算出最终的结果集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER table t_emp DROP index idx_age_name;<br>SHOW INDEX FROM t_emp;<br><br>explain  select deptId,count(*) from t_emp where deptId=3 group by name order by deptId;<br></code></pre></td></tr></table></figure><p><img src="/./../img/image-20251115232116929.png" alt="image-20251115232116929"></p><p><strong>USING index</strong>：<strong>使用了覆盖索引</strong>，表示直接访问索引就足够获取到所需要的数据，不需要通过索引回表（非常好）</p><p><strong>Using where</strong>：使用了where，但在where上有字段没有创建索引。也可以理解为如果数据从引擎层被返回到server层进行过滤，那么就是Usingwhere。</p><p><strong>impossible where</strong>：where子句的值总是false。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> <span class="hljs-number">1</span> != <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p><font color="red"><strong>Using index condition</strong></font>: 叫作Index Condition Pushdown Optimization （<strong>索引下推优化</strong>）</p><p>什么是索引下推:</p><p>是MySQL中的一种查询优化技术，用于提高查询性能和减少回表次数。</p><p>ICP 开启时 (默认)：MySQL 会把二级索引里能过滤的条件 下推到存储引擎，在索引层就过滤一部分数据，减少回表次数。也就是说 直接在索引扫描阶段就完成过滤</p><p>ICP 关闭时：所有条件都在 Server 层判断，InnoDB 只返回索引匹配的数据页，Server 再去逐行判断，回表更多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `test_index` (<br>  `id` int NOT NULL,<br>  `a` varchar(255) DEFAULT NULL,<br>  `b` varchar(255) DEFAULT NULL,<br>  `c` varchar(255) DEFAULT NULL,<br>  `extra` varchar(255) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `idx_a_b_c` (`a`,`b`,`c`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;<br><br>INSERT INTO test_index (id, a, b, c, extra) VALUES<br>(1, &#x27;x&#x27;, &#x27;y1&#x27;, &#x27;z1&#x27;, &#x27;extra1&#x27;),<br>(2, &#x27;x&#x27;, &#x27;y2&#x27;, &#x27;z2&#x27;, &#x27;extra2&#x27;),<br>(3, &#x27;x&#x27;, &#x27;y3&#x27;, &#x27;z3&#x27;, &#x27;extra3&#x27;),<br>(4, &#x27;m&#x27;, &#x27;n1&#x27;, &#x27;p1&#x27;, &#x27;extra4&#x27;),<br>(5, &#x27;m&#x27;, &#x27;n2&#x27;, &#x27;p2&#x27;, &#x27;extra5&#x27;),<br>(6, &#x27;m&#x27;, &#x27;n3&#x27;, &#x27;p3&#x27;, &#x27;extra6&#x27;);<br># 执行如下SQL语句<br>EXPLAIN SELECT * FROM test_index WHERE a = &#x27;x&#x27; AND b LIKE &#x27;y%&#x27; AND c = &#x27;z2&#x27;;<br></code></pre></td></tr></table></figure><p>分析:</p><p>没有 ICP  MySQL 在通过索引扫描时，只能用 a &#x3D; ‘x’ AND b LIKE ‘y%’ 在索引层面做筛选；至于 c &#x3D; ‘z2’ 这个条件，要回表之后再判断意味着会拿到更多的候选行，再去表里逐个比对，效率低</p><p><font color="green">有 ICP MySQL 可以在 存储引擎层 就利用联合索引 (a, b, c)，把 c &#x3D; ‘z2’ 也提前判断掉，减少了回表的次数也就是说，ABC 三个条件都能在索引扫描时用上</font></p><h3 id="5-1-5-小结"><a href="#5-1-5-小结" class="headerlink" title="5.1.5. 小结"></a>5.1.5. 小结</h3><p><strong>表的读取顺序：id</strong>（趟数越少越好）</p><p>那些索引可以使用：possible_keys</p><p><strong>数据读取操作的操作类型：type</strong>（system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL）</p><p><strong>哪些索引被实际使用：key</strong></p><p><strong>哪些索引列被实际使用：key_len</strong></p><p>表之间的引用：table</p><p><strong>每张表有多少行被物理查询：rows</strong>（越小越好）</p><p><strong>额外的重要信息：extra</strong></p><p>避免：Using filesort（排序）、Using temporary（分组）</p><h3 id="5-1-6-explain的局限性"><a href="#5-1-6-explain的局限性" class="headerlink" title="5.1.6. explain的局限性"></a>5.1.6. explain的局限性</h3><ol><li><p>EXPLAIN不考虑各种Cache</p></li><li><p>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</p></li><li><p>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</p></li><li><p>部分统计信息是估算的，并非精确值</p></li></ol><h2 id="5-3-单表优化"><a href="#5-3-单表优化" class="headerlink" title="5.3. 单表优化"></a>5.3. 单表优化</h2><p>MySQL中提高性能的一个最有效的方式是对数据表<strong>设计合理的索引</strong>。索引提供了高效访问数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p><p>我们创建索引后，用不用索引，最终是优化器说了算。<strong>优化器会基于开销选择索引，怎么开销小就怎么来</strong>。不是基于规则，也不是基于语义。</p><p>另外SQL语句是否使用索引，和数据库的版本、数据量、数据选择度（查询中选择的列数）运行环境都有关系</p><h3 id="5-3-1-索引优化原则"><a href="#5-3-1-索引优化原则" class="headerlink" title="5.3.1. 索引优化原则"></a>5.3.1. 索引优化原则</h3><ol><li><p>在索引列上有其他操作（<strong>计算、函数、(自动or手动)类型转换</strong>）导致索引失效</p></li><li><p><strong>like以通配符开头</strong>（’%abc…’）导致索引失效</p></li><li><p>**不等于（!&#x3D;或者&lt;&gt;）**导致索引失效</p></li><li><p><strong>is not null</strong> 也无法使用索引，但是is null是可以使用索引的</p></li><li><p><strong>字符串不加单引号</strong>导致索引失效</p><ol><li>以下两个sql，哪个写法更好：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建索引<br><span class="hljs-keyword">create</span> index idx_name <span class="hljs-keyword">on</span> emp(name);<br>EXPLAIN <span class="hljs-keyword">SELECT</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;abc%&#x27;</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">LEFT</span>(emp.name,<span class="hljs-number">3</span>)<span class="hljs-operator">=</span><span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></td></tr></table></figure><p>sql访问类型range &gt; ALL；使用索引idx_emp_name &gt; NULL；使用索引长度63 &gt; NULL; 扫描行数25 &lt; 498951</p></li><li><p>把第一个sql的like查询条件改成‘%abc%’，会怎样呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT  * FROM emp WHERE emp.name LIKE &#x27;%abc%&#x27;;<br></code></pre></td></tr></table></figure><p>可以发现改成’%abc%’之后，第一个sql失去了索引优势，走了全表扫描。</p><p><strong>注意</strong>：Alibaba《Java开发手册》【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></li><li><p>再来看这两个sql：不等于(!&#x3D;或者&lt;&gt;)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create index idx_age on emp(age);<br>EXPLAIN SELECT  * FROM emp WHERE emp.age=30;<br>EXPLAIN SELECT  * FROM emp WHERE emp.age!=30;<br></code></pre></td></tr></table></figure></li><li><p>is not null和is null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT  * FROM emp WHERE emp.name is null ;<br>EXPLAIN SELECT  * FROM emp WHERE emp.name is not null; <br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 当数据库中的数据的<strong>索引列的NULL值达到比较高的比例的时候</strong>，即使在IS NOT NULL 的情况下 MySQL的查询优化器会选择使用索引，</p><p>此时<strong>type</strong>的值是<strong>range</strong>（范围查询）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 将 id&gt;20000 的数据的 name 值改为 NULL</span><br>   <span class="hljs-keyword">UPDATE</span> emp <span class="hljs-keyword">SET</span> `name` <span class="hljs-operator">=</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">WHERE</span> `id` <span class="hljs-operator">&gt;</span> <span class="hljs-number">20000</span>;<br>   <span class="hljs-comment">-- 执行查询分析，可以发现 IS NOT NULL 使用了索引</span><br>   <span class="hljs-comment">-- 具体多少条记录的值为NULL可以使索引在IS NOT NULL的情况下生效，由查询优化器的算法决定</span><br>   EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.name <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span>;<br></code></pre></td></tr></table></figure><p>测试完将name的值改回来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> emp <span class="hljs-keyword">SET</span> `name` <span class="hljs-operator">=</span> rand_string(<span class="hljs-number">6</span>) <span class="hljs-keyword">WHERE</span> `id` <span class="hljs-operator">&gt;</span> <span class="hljs-number">20000</span>;<br></code></pre></td></tr></table></figure></li><li><p>字符串加引号( 类型转换导致索引失效)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT  * FROM emp WHERE emp.name = &#x27;123&#x27;;<br><br>EXPLAIN SELECT  * FROM emp WHERE emp.name = 123;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-3-2-组合索引原则"><a href="#5-3-2-组合索引原则" class="headerlink" title="5.3.2. 组合索引原则"></a>5.3.2. 组合索引原则</h3><ol><li>全值匹配我最爱</li><li>符合最左原则：不跳过索引中的列。</li><li>如果where条件中是OR关系，加索引不起作用</li><li>存储引擎不能使用索引中范围条件右边的列</li></ol><p>首先删除之前创建的索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 尽量在navicat执行 直接在linux执行会很慢<br>CALL proc_drop_index(&quot;fydb&quot;,&quot;emp&quot;);  <br></code></pre></td></tr></table></figure><ol><li>全值匹配我最爱</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM emp WHERE age=30 and deptId=1 and name=&#x27;abc&#x27;;<br>create index idx_age_deptId_name on emp(age, deptId, name);<br>SELECT * FROM emp WHERE age=30 and deptId=1 and name=&#x27;abc&#x27;;<br></code></pre></td></tr></table></figure><ol start="2"><li>最左匹配原则</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM emp WHERE age=30 and deptId=1;<br>SELECT * FROM emp WHERE deptId=1 and name=&#x27;abc&#x27;;<br></code></pre></td></tr></table></figure><ol start="3"><li>OR关联</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain SELECT * FROM emp WHERE age=30 and deptId=1 and name=&#x27;abc&#x27;;<br><br>explain SELECT * FROM emp WHERE age=30 and deptId=1 OR name=&#x27;abc&#x27;;<br></code></pre></td></tr></table></figure><ol start="4"><li>范围条件右边的列</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain SELECT * FROM emp WHERE age=30 and deptId=1 and name=&#x27;abc&#x27;;<br><br>explain SELECT * FROM emp WHERE age=30 and deptId&gt;10000 and name=&#x27;abc&#x27;;<br></code></pre></td></tr></table></figure><h3 id="5-3-3-小结"><a href="#5-3-3-小结" class="headerlink" title="5.3.3. 小结"></a>5.3.3. 小结</h3><p>一般性建议：</p><ol><li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li><li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面</li><li>书写sql语句时，尽量避免造成索引失效的情况</li></ol><h2 id="5-4-关联查询优化"><a href="#5-4-关联查询优化" class="headerlink" title="5.4. 关联查询优化"></a>5.4. 关联查询优化</h2><p>接下来再次创建两张表，并分别导入数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE IF NOT EXISTS `class` (<br>`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,<br>`card` INT(10) UNSIGNED NOT NULL,<br>PRIMARY KEY (`id`)<br>);<br>CREATE TABLE IF NOT EXISTS `book` (<br>`bookid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,<br>`card` INT(10) UNSIGNED NOT NULL,<br>PRIMARY KEY (`bookid`)<br>);<br><br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));<br> <br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br>INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));<br></code></pre></td></tr></table></figure><p>此时class有16条数据，book有20条数据。</p><p>在<strong>MySQL</strong>中，驱动表和被驱动表的选择依赖于查询的类型。例如，在<em>LEFT JOIN</em>操作中，左表（left table）是驱动表，而右表（right table）是被驱动表。相反，在<em>RIGHT JOIN</em>中，右表成为驱动表，左表则是被驱动表。对于<em>INNER JOIN</em>，MySQL通常会选择数据量较小的表作为驱动表，因为这样可以减少查询时的循环次数，提高效率。</p><h3 id="5-4-1-关联案例"><a href="#5-4-1-关联案例" class="headerlink" title="5.4.1. 关联案例"></a>5.4.1. 关联案例</h3><p>explain分析一下几个sql：其中左外连接中驱动表是左表 右外连接驱动表是右表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;<br><br>EXPLAIN SELECT * FROM class RIGHT JOIN book ON class.card = book.card;<br><br>EXPLAIN SELECT * FROM class INNER JOIN book ON class.card = book.card;<br></code></pre></td></tr></table></figure><p>没有创建索引前的测试： 进行了进行了全表扫描，查询次数为16*20</p><p>给book.card创建索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create index idx_book_card on book(card);<br></code></pre></td></tr></table></figure><p>然后explain分析：</p><p>删除旧索引，添加新索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 删除旧索引 + 新建 + 第3次explain<br>call proc_drop_index(&quot;fydb&quot;,&quot;book&quot;);<br><br>create index idx_class_card on class(card);<br></code></pre></td></tr></table></figure><p>再次explain分析：</p><p>同时给两张表的card字段添加索引：（class(card)索引已有：index_class_card，只需给book（card）添加索引）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create index idx_book_card on book(card);<br></code></pre></td></tr></table></figure><p>最后explain分析：</p><p>结论：针对两张表的连接条件涉及的列，索引要创建在被驱动表上，驱动表尽量是小表</p><p>关于查询方式的选择</p><p>需求: 求所有人物对应的掌门名称(此处使用第四章创建的t_emp 和 t_dept )</p><p>方式一:三表左连接方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 员工表(t_emp)、部门表(t_dept)、ceo(t_emp)表 关联查询<br>EXPLAIN SELECT emp.name, ceo.name AS ceoname<br>FROM t_emp emp<br>LEFT JOIN t_dept dept ON emp.deptid = dept.id<br>LEFT JOIN t_emp ceo ON dept.ceo = ceo.id;<br></code></pre></td></tr></table></figure><p>一趟查询，用到了主键索引，<strong>效果最佳</strong></p><p>方式二: 子查询方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain SELECT<br>emp.name,<br>(SELECT ceo.name FROM t_emp ceo WHERE ceo.id = dept.ceo) AS ceoname<br>FROM t_emp emp<br>LEFT JOIN t_dept dept ON emp.deptid = dept.id;<br></code></pre></td></tr></table></figure><p>两趟查询，用到了主键索引，跟第一种比，效果稍微差点。</p><p><strong>总结</strong>：能够直接多表关联的尽量直接关联，不用子查询。减少查询趟数</p><h3 id="5-4-2-优化建议"><a href="#5-4-2-优化建议" class="headerlink" title="5.4.2. 优化建议"></a>5.4.2. 优化建议</h3><ol><li>保证被驱动表的join字段已经被索引</li><li>left&#x2F;right join 时，选择小表作为驱动表，大表作为被驱动表。</li><li>inner join 时，mysql会自己帮你把小结果集的表选为驱动表。</li><li>子查询尽量不要放在被驱动表，有可能使用不到索引。</li><li>能够直接多表关联的尽量直接关联，不用子查询。</li><li>索引要创建在被驱动表上</li></ol><h1 id="MySQL驱动表详解"><a href="#MySQL驱动表详解" class="headerlink" title="MySQL驱动表详解"></a>MySQL驱动表详解</h1><p><strong>驱动表</strong>是MySQL多表连接查询（JOIN）中的一个重要概念，指的是<strong>在JOIN操作中首先被读取和处理的表</strong>。</p><h2 id="驱动表的核心定义"><a href="#驱动表的核心定义" class="headerlink" title="驱动表的核心定义"></a>驱动表的核心定义</h2><ul><li><strong>驱动表</strong>（Driving Table）：查询中<strong>首先被扫描</strong>的表，它的每一行都会去被驱动表中查找匹配数据</li><li><strong>被驱动表</strong>（Driven Table）：查询中<strong>后续被扫描</strong>的表，依赖驱动表的中间结果进行匹配</li></ul><h2 id="为什么需要驱动表？"><a href="#为什么需要驱动表？" class="headerlink" title="为什么需要驱动表？"></a>为什么需要驱动表？</h2><p>MySQL在执行JOIN查询时，通常使用<strong>嵌套循环连接</strong>（Nested Loop Join）算法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> 驱动表 &#123;      <span class="hljs-comment">-- 外层循环</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> 被驱动表 &#123;  <span class="hljs-comment">-- 内层循环</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">row</span>满足连接条件) &#123;<br>            输出匹配结果<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键点</strong>：驱动表的行数决定了外层循环的次数，因此选择合适驱动表可以大幅减少查询成本。</p><h2 id="驱动表选择原则"><a href="#驱动表选择原则" class="headerlink" title="驱动表选择原则"></a>驱动表选择原则</h2><h3 id="1-优先选择”小表”作为驱动表"><a href="#1-优先选择”小表”作为驱动表" class="headerlink" title="1. 优先选择”小表”作为驱动表"></a>1. 优先选择”小表”作为驱动表</h3><ul><li><strong>核心原则</strong>：永远用<strong>结果集小的表</strong>驱动<strong>结果集大的表</strong></li><li>例如：<ul><li>user表10,000条记录（小表）</li><li>class表20条记录（大表）</li><li>选择class表作为驱动表，只需循环20次</li><li>选择user表作为驱动表，需要循环10,000次</li></ul></li></ul><h3 id="2-选择驱动表的判断依据"><a href="#2-选择驱动表的判断依据" class="headerlink" title="2. 选择驱动表的判断依据"></a>2. 选择驱动表的判断依据</h3><table><thead><tr><th>情况</th><th>选择依据</th></tr></thead><tbody><tr><td>未指定联接条件</td><td>行数少的表作为驱动表</td></tr><tr><td>指定了联接条件</td><td>过滤后结果集小的表作为驱动表</td></tr><tr><td>有WHERE条件</td><td>WHERE条件过滤后结果集小的表作为驱动表</td></tr></tbody></table><h2 id="如何确定驱动表？"><a href="#如何确定驱动表？" class="headerlink" title="如何确定驱动表？"></a>如何确定驱动表？</h2><ol><li><p><strong>通过EXPLAIN查看执行计划</strong>：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tableA <span class="hljs-keyword">JOIN</span> tableB <span class="hljs-keyword">ON</span> tableA.id = tableB.id;<br></code></pre></td></tr></table></figure><ul><li>排在第一行的表是驱动表</li><li><code>rows</code>列显示扫描的行数，越小越好</li></ul></li><li><p><strong>使用STRAIGHT_JOIN强制指定</strong>：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">SELECT * FROM <span class="hljs-built_in">table</span>B STRAIGHT_JOIN <span class="hljs-built_in">table</span>A ON <span class="hljs-built_in">table</span>B.id = <span class="hljs-built_in">table</span>A.id;<br></code></pre></td></tr></table></figure><ul><li>强制指定tableB为驱动表，tableA为被驱动表</li></ul></li></ol><h2 id="为什么驱动表选择如此重要？"><a href="#为什么驱动表选择如此重要？" class="headerlink" title="为什么驱动表选择如此重要？"></a>为什么驱动表选择如此重要？</h2><ul><li><strong>性能差异巨大</strong>：使用大表作为驱动表可能导致查询时间从几毫秒增加到几秒甚至几分钟</li><li><strong>I&#x2F;O成本</strong>：驱动表的行数决定需要执行的内层循环次数</li><li><strong>索引利用</strong>：被驱动表的关联字段必须有索引才能高效查询</li></ul><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">-- 错误示例：大表作为驱动表<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> users u <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> orders o <span class="hljs-keyword">ON</span> u.id = o.user_id;<br><br>-- 正确示例：小表作为驱动表<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> orders o <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> users u <span class="hljs-keyword">ON</span> o.user_id = u.id;<br></code></pre></td></tr></table></figure><p>如果orders表有10万条记录，users表有1000条记录：</p><ul><li>错误示例：需要10万次循环（每次在users表中查找匹配）</li><li>正确示例：只需1000次循环（每次在orders表中查找匹配）</li></ul><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><ol><li><strong>小表驱动大表</strong>：永远优先选择结果集小的表作为驱动表</li><li><strong>被驱动表建立索引</strong>：确保关联字段有索引</li><li><strong>使用EXPLAIN分析</strong>：查看执行计划，确认驱动表是否合理</li><li><strong>必要时使用STRAIGHT_JOIN</strong>：当优化器选择错误时手动干预</li></ol><blockquote><p>💡 <strong>一句话记住</strong>：驱动表是”起点”，被驱动表是”终点”。选择小结果集作为起点，能大幅减少查询成本。</p></blockquote><p>理解驱动表的概念并正确应用，是优化MySQL查询性能的关键一步。在实际开发中，养成使用EXPLAIN分析查询的习惯，能帮助你写出更高效的SQL。😊</p><h2 id="5-5-子查询优化"><a href="#5-5-子查询优化" class="headerlink" title="5.5. 子查询优化"></a>5.5. 子查询优化</h2><p>尽量不要使用not in  或者 not exists (此处使用第四章关联建表语句和数据)</p><p>需求：查询非掌门人的信息</p><p>方式一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询员工，这些员工的id没在（掌门人id列表中）<br>-- 【查询不是CEO的员工】<br>explain SELECT * FROM t_emp emp WHERE emp.id NOT IN<br>(SELECT dept.ceo FROM t_dept dept WHERE dept.ceo IS NOT NULL);<br>-- mysql8之后 做了优化  演示效果不明显<br>explain SELECT * FROM t_emp emp WHERE emp.id  IN<br>(SELECT dept.ceo FROM t_dept dept WHERE dept.ceo IS NOT NULL);<br></code></pre></td></tr></table></figure><h2 id="5-6-排序及分组优化"><a href="#5-6-排序及分组优化" class="headerlink" title="5.6. 排序及分组优化"></a>5.6. 排序及分组优化</h2><h3 id="5-6-1-无过滤-不索引"><a href="#5-6-1-无过滤-不索引" class="headerlink" title="5.6.1. 无过滤 不索引"></a>5.6.1. 无过滤 不索引</h3><p>准备工作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 删除采用存储过程导入数据的 emp表   中的所有的索引<br>-- 创建新的索引结构<br>CREATE INDEX idx_age_deptid_name ON emp (age,deptid,`name`);<br></code></pre></td></tr></table></figure><p>sql演示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 没有使用索引：<br>EXPLAIN SELECT * FROM emp ORDER BY age,deptid;<br>-- 使用了索引：order by想使用索引，必须有过滤条件，索引才能生效，limit也可以看作是过滤条件<br>EXPLAIN SELECT * FROM emp ORDER BY age,deptid LIMIT 10;<br></code></pre></td></tr></table></figure><p>执行结果如下</p><h3 id="5-6-2-顺序错不索引"><a href="#5-6-2-顺序错不索引" class="headerlink" title="5.6.2. 顺序错不索引"></a>5.6.2. 顺序错不索引</h3><p>sql演示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 创建了一个索引 idx_age_deptId_name  理论key_len=73<br><br>-- 会走索引type=ref  key_len = 5   extra中没有using filesort           <br>EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY deptid; <br><br>-- 会走索引type=ref  key_len = 5   extra中没有using filesort   <br>EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY deptid, `name`; <br><br>-- 会走索引type=ref  key_len = 5   extra出现了using filesort  获取数据的时候走索引,但是排序的时候没有走<br>EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY deptid, empno;<br><br>-- 会走索引type=ref  key_len = 5   extra出现了using filesort  获取数据的时候走索引,但是排序的时候没有走<br>EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY `name`, deptid;<br><br>-- 不会走索引type=all  key_len = 0   extra出现了using filesort using where  获取数据的时候走索引,但是--- 排序的时候没有走<br>EXPLAIN SELECT * FROM emp WHERE deptid=45 ORDER BY age;<br></code></pre></td></tr></table></figure><h3 id="5-6-3-方向反不索引"><a href="#5-6-3-方向反不索引" class="headerlink" title="5.6.3. 方向反不索引"></a>5.6.3. 方向反不索引</h3><p>sql演示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 排序使用了索引：排序条件和索引一致，并方向相同，可以使用索引</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> age<span class="hljs-operator">=</span><span class="hljs-number">45</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptid <span class="hljs-keyword">DESC</span>, `name` <span class="hljs-keyword">DESC</span>;<br><br><span class="hljs-comment">-- 没有使用索引：两个排序条件方向相反</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> age<span class="hljs-operator">=</span><span class="hljs-number">45</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> deptid <span class="hljs-keyword">ASC</span>, `name` <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h3 id="5-6-4-优化演示"><a href="#5-6-4-优化演示" class="headerlink" title="5.6.4. 优化演示"></a>5.6.4. 优化演示</h3><p>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序</p><p><strong>执行案例前先清除emp上的索引，只留主键</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查询 年龄为30岁的，且员工编号小于101000的用户，按用户名称排序<br>SELECT  * FROM emp WHERE age =30 AND empno &lt;101000 ORDER BY NAME;<br></code></pre></td></tr></table></figure><p>结论：type 是 ALL,即最坏的情况。Extra 里还出现了 Using filesort,也是最坏的情况。优化是必须的。</p><p>优化思路： 尽量让where的过滤条件和排序使用上索引。</p><p>现在过滤条件使用了两个字段（age，empno）排序使用了name。</p><p>我们建一个三个字段的组合索引可否？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_age_empno_name ON emp(age,empno,NAME);<br></code></pre></td></tr></table></figure><p>再次explain测试：</p><p>我们发现using filesort 依然存在，所以name 并没有用到索引。</p><p>原因是因为empno是一个范围过滤，对于获取数据而言,是可以通过索引下推的方式减少回表,来快速获取要排序的数据  但是在对这些数据进行排序操作的时候,没有用到索引</p><p>所以我们建一个3值索引是没有意义的<br>那么我们先删掉这个索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP INDEX idx_age_empno_name ON emp<br></code></pre></td></tr></table></figure><p>为了去掉filesort我们可以把索引建成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_age_name ON emp(age,NAME);<br></code></pre></td></tr></table></figure><p>也就是说empno 和name这个两个字段只能二选其一。<br> 这样我们优化掉了 using filesort。</p><p> 执行一下sql：</p><p>速度果然提高了4倍。</p><p>假如：<strong>选择创建age和empno会速度会怎样呢，自己试试有惊喜！</strong></p><p>虽然出现了usingfilesort 表示排序的数据没有用索引进行排序  type是range表示获取数据用到了索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE INDEX idx_age_name ON emp(age,empno);<br></code></pre></td></tr></table></figure><p>结果竟然有 filesort的 sql 运行速度，超过了已经优化掉 filesort的 sql ，而且快了好多倍。何故</p><p>原因：是所有的排序都是在条件过滤之后才执行的，所以如果条件过滤了大部分数据的话，几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序但实际提升性能很有限。  相对的 empno&lt;101000 这个条件如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。</p><p>结论：  当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。也可以将选择权交给MySQL：索引同时存在，mysql自动选择最优的方案：（对于这个例子，mysql选择idx_age_empno），但是，随着数据量的变化，选择的索引也会随之变化的。</p><h3 id="5-6-5-双路排序和单路排序"><a href="#5-6-5-双路排序和单路排序" class="headerlink" title="5.6.5. 双路排序和单路排序"></a>5.6.5. 双路排序和单路排序</h3><p>如果排序没有使用索引，引起了filesort，那么filesort有两种算法</p><p>1、双路排序</p><p>2、单路排序</p><h4 id="5-6-5-1-双路排序"><a href="#5-6-5-1-双路排序" class="headerlink" title="5.6.5.1 双路排序"></a>5.6.5.1 双路排序</h4><p>原理：**第一遍扫描出需要排序的字段，然后进行排序后，根据排序结果，第二遍再扫描一下需要select的列数据。**这样会引起大量的随机IO，效率不高，但是节约内存。排序使用quick sort，但是如果内存不够则会按照block进行排序，将排序结果写入磁盘文件，然后再将结果合并。</p><p>具体过程：</p><p>1、读取所有满足条件的记录。</p><p>2、对于每一行，存储一对值到缓冲区（排序列，行记录指针），一个是排序的索引列的值，即order by用到的列值，和指向该行数据的行指针。</p><p>3、当缓冲区满后，运行一个快速排序（qsort）来将缓冲区中数据排序，并将排序完的数据存储到一个临时文件，并保存一个存储块的指针，当然如果缓冲区不满，则不会创建临时文件了。</p><p>4、重复以上步骤，直到将所有行读完，并建立相应的有序的临时文件。</p><p>5、对块级进行排序，这个类似于归并排序算法，只通过两个临时文件的指针来不断交换数据，最终达到两个文件，都是有序的。</p><p>6、重复5直到所有的数据都排序完毕。</p><p>7、采取顺序读的方式，将每行数据读入内存，并取出数据传到客户端，这里读取数据时并不是一行一行读，读取缓存大小由read_rnd_buffer_size来指定。特点: 采取的方法为：快速排序 + 归并排序。</p><p>但有一个问题，就是，一行数据会<strong>被读两次</strong>，第一次是where条件过滤时，第二个是排完序后还得用行指针去读一次，一个优化的方法是，直接读入数据，排序的时候也根据这个排序，排序完成后，就直接发送到客户端了。</p><h4 id="5-6-5-2-单路排序"><a href="#5-6-5-2-单路排序" class="headerlink" title="5.6.5.2 单路排序"></a>5.6.5.2 单路排序</h4><p>在MySQL4.1版本之前只有第一种排序算法双路排序，第二种算法是从MySQL4.1开始的改进算法，主要目的是为了减少第一次算法中需要两次访问表数据的IO操作，将两次变成了一次，但相应也会耗用更多的sort buffer空间。当然，MySQL4.1开始的以后所有版本同时也支持第一种算法。</p><p>具体过程：</p><p>1、读取满足条件的记录</p><p>2、对于每一行，记录排序的key和数据行指针，并且把要查询的列也读出来</p><p>3、根据索引key排序</p><p>4、读取排序完成的文件，并直接根据数据位置读取数据返回客户端，而不是去访问表</p><p>特点：</p><p>1、单路排序一次性将结果读取出来，然后在sort buffer中排序，避免了双路排序的两次读的随机IO。</p><p>2、这也有一个问题：当获取的列很多的时候，排序起来就<strong>很占空间</strong></p><p><strong>结论及引申出的问题</strong></p><p>1、单路比多路要多占用更多内存空间</p><p>2、因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了<strong>sort_buffer_size</strong>的容量，导致每次只能取sort_buffer_size容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排……从而多次I&#x2F;O。</p><p>3、单路本来想省一次I&#x2F;O操作，反而导致了大量的I&#x2F;O操作，反而得不偿失。</p><h3 id="5-6-6-排序优化策略"><a href="#5-6-6-排序优化策略" class="headerlink" title="5.6.6. 排序优化策略"></a>5.6.6. 排序优化策略</h3><p>优化策略：</p><p>1、减少select 后面的查询的字段：<strong>order by时select * 是一个大忌</strong>。</p><p>2、查询字段过多会占用sort_buffer_size的容量。<strong>增大sort_buffer_size参数的设置</strong>：当然，要根据系统的能力去提高，因为这个参数是针对每个进程（connection）的 1M-8M之间调整。 MySQL8.0，InnoDB存储引擎默认值是1048576字节，1MB。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%sort_buffer_size%&#x27;</span>; <span class="hljs-comment">-- 默认1MB</span><br></code></pre></td></tr></table></figure><p>查看结果如下所示：</p><p>3、增大<strong>max_length_for_sort_data</strong>参数的设置：MySQL根据max_length_for_sort_data变量来确定使用哪种算法，默认值是4096字节，如果需要返回的列的总长度<strong>大于max_length_for_sort_data，使用双路排序算法</strong>，否则使用单路排序算法。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I&#x2F;O活动和低的处理器使用率。1024-8192之间调整。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%max_length_for_sort_data%&#x27;</span>; <span class="hljs-comment">-- 默认4K</span><br></code></pre></td></tr></table></figure><p>查看结果如下所示：</p><p><strong>举例：</strong></p><p>1、如果数据总量很小（单路一次就可以读取所有数据），单条记录大小很大（大于4K，默认会使用双路排序），此时，可以增加max_length_for_sort_data的值，增加sort_buffer_size的值，让服务器默认使用单路排序。</p><p>2、如果数据总量很大（单路很多次IO才可以），单条记录大小很小（小于4K，默认会使用单路排序），此时，可以减小max_length_for_sort_data的值，让服务器默认使用双路排序。</p><h3 id="5-6-7-分组优化"><a href="#5-6-7-分组优化" class="headerlink" title="5.6.7. 分组优化"></a>5.6.7. 分组优化</h3><p>1、group by 使用索引的原则几乎跟order by一致。但是<strong>group by 即使没有过滤条件用到索引，也可以直接使用索引</strong>（Order By 必须有过滤条件才能使用上索引）</p><p>2、包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p><h2 id="5-8-覆盖索引"><a href="#5-8-覆盖索引" class="headerlink" title="5.8. 覆盖索引"></a>5.8. 覆盖索引</h2><p>最后使用索引的手段：覆盖索引</p><h3 id="5-7-1-什么是覆盖索引"><a href="#5-7-1-什么是覆盖索引" class="headerlink" title="5.7.1. 什么是覆盖索引"></a>5.7.1. 什么是覆盖索引</h3><p>**理解方式一：**索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要回表读取了。一个索引包含了满足查询结果的数据就叫做覆盖索引。</p><p>**理解方式二：**非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p><p>简单说就是：select 到 from 之间查询的列 &lt;&#x3D; 使用的索引列 + 主键</p><p><strong>好处：</strong></p><ol><li>避免Innodb表进行索引的二次查询（回表）</li><li>可以把随机IO变成顺序IO加快查询效率</li></ol><p>**缺点：**索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。  </p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="怎么决定建立哪些索引"><a href="#怎么决定建立哪些索引" class="headerlink" title="怎么决定建立哪些索引?"></a>怎么决定建立哪些索引?</h2><blockquote><p>什么时候不需要创建索引？</p></blockquote><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li><li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li>表数据太少的时候，不需要创建索引；</li><li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由</li></ul><h3 id="索引优化详细讲讲"><a href="#索引优化详细讲讲" class="headerlink" title="索引优化详细讲讲"></a>索引优化详细讲讲</h3><p>常见优化索引的方法：</p><ul><li>前缀索引优化：使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</li><li>覆盖索引优化：覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</li><li>主键索引最好是自增的：<ul><li>如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</li><li>如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</li></ul></li><li>防止索引失效：<ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul></li></ul><h2 id="了解过前缀索引吗？"><a href="#了解过前缀索引吗？" class="headerlink" title="了解过前缀索引吗？"></a>了解过前缀索引吗？</h2><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><h2 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h2><p><strong>前缀索引（Prefix Index）</strong> 是MySQL中的一种索引优化技术，<strong>只对字符串列的前N个字符创建索引</strong>，而不是对整个字符串列。<br> <strong>语法示例</strong>：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 为name列的前10个字符创建索引</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_name_prefix <span class="hljs-keyword">ON</span> users(<span class="hljs-type">name</span>(<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><blockquote><p>💡 <strong>核心思想</strong>：<br> <strong>“用更短的索引长度，换取更小的索引体积，从而提升查询性能”</strong></p></blockquote><hr><h2 id="为什么需要前缀索引？（问题背景）"><a href="#为什么需要前缀索引？（问题背景）" class="headerlink" title="为什么需要前缀索引？（问题背景）"></a>为什么需要前缀索引？（问题背景）</h2><h3 id="问题：长字符串列的索引问题"><a href="#问题：长字符串列的索引问题" class="headerlink" title="问题：长字符串列的索引问题"></a>问题：长字符串列的索引问题</h3><table><thead><tr><th>列类型</th><th>示例值</th><th>完整索引大小</th><th>问题</th></tr></thead><tbody><tr><td><code>VARCHAR(255)</code></td><td><code>&quot;user1234567890@domain.com&quot;</code></td><td>约255字节&#x2F;行</td><td>索引过大，占用大量磁盘&#x2F;内存</td></tr><tr><td><code>VARCHAR(255)</code></td><td>100万行</td><td>~255MB</td><td>无法完全缓存到Buffer Pool</td></tr></tbody></table><h3 id="优化目标："><a href="#优化目标：" class="headerlink" title="优化目标："></a>优化目标：</h3><ul><li><strong>减少索引大小</strong> → 降低磁盘占用</li><li><strong>提升内存缓存率</strong> → 减少磁盘I&#x2F;O</li><li><strong>保持查询效率</strong> → 通过合理选择前缀长度</li></ul><hr><h2 id="前缀索引优化的核心步骤"><a href="#前缀索引优化的核心步骤" class="headerlink" title="前缀索引优化的核心步骤"></a>前缀索引优化的核心步骤</h2><h3 id="步骤1：分析列值分布（关键！）"><a href="#步骤1：分析列值分布（关键！）" class="headerlink" title="步骤1：分析列值分布（关键！）"></a>步骤1：分析列值分布（关键！）</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 计算不同前缀长度的唯一值比例</span><br><span class="hljs-keyword">SELECT</span> <br>  COUNT(<span class="hljs-keyword">DISTINCT</span> LEFT(<span class="hljs-type">name</span>, <span class="hljs-number">5</span>)) / COUNT(*) <span class="hljs-keyword">AS</span> uniq_5,<br>  COUNT(<span class="hljs-keyword">DISTINCT</span> LEFT(<span class="hljs-type">name</span>, <span class="hljs-number">10</span>)) / COUNT(*) <span class="hljs-keyword">AS</span> uniq_10,<br>  COUNT(<span class="hljs-keyword">DISTINCT</span> LEFT(<span class="hljs-type">name</span>, <span class="hljs-number">15</span>)) / COUNT(*) <span class="hljs-keyword">AS</span> uniq_15<br><span class="hljs-keyword">FROM</span> users;<br></code></pre></td></tr></table></figure><p><strong>输出示例</strong>：</p><table><thead><tr><th>前缀长度</th><th>唯一值比例</th><th>说明</th></tr></thead><tbody><tr><td>5</td><td>0.85</td><td>15%重复，可能不够区分</td></tr><tr><td>10</td><td>0.98</td><td>2%重复，足够好</td></tr><tr><td>15</td><td>0.999</td><td>0.1%重复，但索引更大</td></tr></tbody></table><blockquote><p>💡 <strong>选择原则</strong>：<br> <strong>选择唯一值比例≥95%的最小前缀长度</strong>（例如10）</p></blockquote><h3 id="步骤2：创建前缀索引"><a href="#步骤2：创建前缀索引" class="headerlink" title="步骤2：创建前缀索引"></a>步骤2：创建前缀索引</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 基于分析结果，选择10字符作为前缀</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_name_prefix <span class="hljs-keyword">ON</span> users(<span class="hljs-type">name</span>(<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><h3 id="步骤3：验证效果"><a href="#步骤3：验证效果" class="headerlink" title="步骤3：验证效果"></a>步骤3：验证效果</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 检查索引是否被使用</span><br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;John%&#x27;</span>;<br><br><span class="hljs-comment">-- 查看索引大小（优化前 vs 优化后）</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">TABLE</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;users&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="前缀索引-vs-完整索引：性能对比"><a href="#前缀索引-vs-完整索引：性能对比" class="headerlink" title="前缀索引 vs 完整索引：性能对比"></a>前缀索引 vs 完整索引：性能对比</h2><table><thead><tr><th>指标</th><th>完整索引（<code>name(255)</code>）</th><th>前缀索引（<code>name(10)</code>）</th><th>优化效果</th></tr></thead><tbody><tr><td><strong>索引大小</strong></td><td>255字节&#x2F;行</td><td>10字节&#x2F;行</td><td><strong>↓ 96%</strong></td></tr><tr><td><strong>磁盘占用</strong></td><td>255MB (100万行)</td><td>10MB (100万行)</td><td><strong>↓ 96%</strong></td></tr><tr><td><strong>Buffer Pool命中率</strong></td><td>70%</td><td>98%</td><td><strong>↑ 28%</strong></td></tr><tr><td><strong>查询速度</strong></td><td>2.1ms</td><td>0.3ms</td><td><strong>↑ 6倍</strong></td></tr></tbody></table><blockquote><p>💡 <strong>为什么更快？</strong><br> 因为索引更小，<strong>更多索引页能常驻内存</strong>，减少磁盘I&#x2F;O。</p></blockquote><hr><h2 id="前缀索引的陷阱与注意事项"><a href="#前缀索引的陷阱与注意事项" class="headerlink" title="前缀索引的陷阱与注意事项"></a>前缀索引的陷阱与注意事项</h2><h3 id="陷阱1：前缀长度不足导致重复"><a href="#陷阱1：前缀长度不足导致重复" class="headerlink" title="陷阱1：前缀长度不足导致重复"></a>陷阱1：前缀长度不足导致重复</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 问题：前缀长度太短</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_email <span class="hljs-keyword">ON</span> users(email(<span class="hljs-number">5</span>)); <br><br><span class="hljs-comment">-- 问题：所有以&quot;abc&quot;开头的邮箱都归为同一索引</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> email = <span class="hljs-string">&#x27;abc@domain.com&#x27;</span>; <br><span class="hljs-comment">-- 实际可能返回多个结果（需回表验证）</span><br></code></pre></td></tr></table></figure><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ul><li>通过<code>COUNT(DISTINCT LEFT(email, 5))</code>确保唯一值比例&gt;95%</li><li>对于邮箱，通常需要10-20字符（如<code>email(15)</code>）</li></ul><h3 id="陷阱2：无法用于ORDER-BY和GROUP-BY"><a href="#陷阱2：无法用于ORDER-BY和GROUP-BY" class="headerlink" title="陷阱2：无法用于ORDER BY和GROUP BY"></a>陷阱2：无法用于<code>ORDER BY</code>和<code>GROUP BY</code></h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 前缀索引无法优化以下查询</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">name</span>; <br><span class="hljs-comment">-- 会触发文件排序（filesort）</span><br></code></pre></td></tr></table></figure><h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h3><ul><li>对于<code>ORDER BY</code>，使用完整索引或<code>ORDER BY</code>字段本身</li><li>前缀索引<strong>仅适用于<code>WHERE</code>条件</strong>（尤其是<code>LIKE &#39;prefix%&#39;</code>）</li></ul><h1 id="Mysql优化"><a href="#Mysql优化" class="headerlink" title="Mysql优化"></a>Mysql优化</h1><p>在面试中，建议按优先级依次介绍慢 SQL 定位、<a href="">索引优化</a>、表结构设计和 <a href="">SQL 优化</a>等内容。架构层面的优化，如<a href="">读写分离和分库分表</a>、<a href="">数据冷热分离</a> 应作为最后的手段，除非在特定场景下有明显的性能瓶颈，否则不应轻易使用，因其引入的复杂性会带来额外的维护成</p><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20Mysql架构和索引</title>
    <link href="/2025/11/15/20Mysql%E6%9E%B6%E6%9E%84%E5%92%8C%E7%B4%A2%E5%BC%95/"/>
    <url>/2025/11/15/20Mysql%E6%9E%B6%E6%9E%84%E5%92%8C%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h1><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用，并发挥良好作用。<font color='red'>主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。</font>这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><p><img src="/./../img/image-20251115210849031.png" alt="image-20251115210849031"></p><ol><li><p>连接层</p><p>最上层是一些客户端和连接服务，包含本地socket通信和大多数基于客户端&#x2F;服务端工具实现的类似于tcp&#x2F;ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p></li><li><p>服务层</p><ol><li><p>Management Serveices &amp; Utilities： 系统管理和控制工具</p></li><li><p>SQL Interface：SQL接口。接受用户的SQL命令（包括DDL和DML指令）并返回执行结果。</p><p>比如select from就是调用SQL Interface</p></li><li><p>Parser: 解析器，将客户端发送的SQL进行语法和语义解析，生成“解析树”。</p><p>SQL命令传递到解析器的时候会被解析器验证和解析。预处理器根据一些MySQL规则进一步检查“解析树”是否合法，例如这里将检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义，最后生成新的“解析树”。</p></li><li><p>Optimizer: 查询优化器。</p><ul><li><p>语法树没有问题后，<strong>优化器将其转成执行计划，并选择最有效的执行计划</strong>。优化器是决定查询性能的关键组件，而数据库的统计信息是优化器判断的基础。</p></li><li><p>这个执行计划表明应该<strong>使用哪些索引</strong>进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来执行查询，并将查询结果返回给用户。  </p></li><li><p>执行一个查询时，它使用“选取-投影-连接”策略进行查询。例如：  </p><p>select uid,name from user where  gender&#x3D; 1;</p><ul><li>这个select 查询先根据where 语句进行<strong>选取</strong>，而不是先将表全部查询出来以后再进行gender过滤</li><li>这个select查询先根据uid和name进行属性<strong>投影</strong>，而不是将属性全部取出以后再进行过滤</li></ul></li></ul><p>将这两个查询条件<strong>连接</strong>起来生成最终查询结果。  </p><p><strong>注意：mysql的优化器是基于查询成本的优化，不是基于查询时间的优化。</strong></p></li><li><p>Cache和Buffer： 查询缓存组件。</p><p>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。它存储SELECT语句以及相应的查询结果集。</p><p>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等</p><p>这个查询缓存可以在 不同客户端之间共享 。  </p><p>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除  如下可以查看是否有查询缓存功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%query_cache_type%&#x27;</span>; <br></code></pre></td></tr></table></figure></li></ol></li><li><p>引擎层</p><p>存储引擎层，<strong>存储引擎真正的负责了MySQL中数据的存储和提取</strong>，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB</p></li><li><p>存储层</p><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存<br>在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设<br>备，但现代文件系统的实现使得这样做没有必要了。</p></li></ol><h2 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h2><ul><li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li><li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li><li>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</li><li>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit 状态)</li></ul><p><img src="/./../img/image-20251115210857046.png" alt="image-20251115210857046"></p><p>mysql的查询流程大致是：SQL语句 → 查询缓存 → 解析器 → 优化器 → 执行器   </p><ol><li><p>**mysql客户端通过协议与mysql服务器建连接，发送查询语句，授权认证，先检查查询缓存，如果命中，直接返回结果。**服务器就不会再对查询进行解析、优化、以及执行。MySQL8.0 之后就抛弃了这个功能。原因如下：命中率极低</p></li><li><p>**在解析器中对 SQL 语句进行语法分析、语义分析。**检查解析树是否合法。</p></li><li><p>**由查询优化器将其转化成执行计划。**优化器的作用就是找到这其中最好的执行计划。</p></li><li><p><strong>执行器执行sql</strong>：截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。在执行之前需要判断该用户是否具备权限，如果没有则会返回权限错误，如果具备权限则执行SQL查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p></li></ol><h2 id="SQL执行计划"><a href="#SQL执行计划" class="headerlink" title="SQL执行计划"></a>SQL执行计划</h2><p>利用<code>show profiles</code> 可以查看sql的执行周期。需要先开启该功能。</p><h2 id="语法顺序"><a href="#语法顺序" class="headerlink" title="语法顺序"></a>语法顺序</h2><p><img src="/./../img/image-20251115210926022.png" alt="image-20251115210926022"></p><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><h3 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h3><p>面试题:<br>InnoDB引擎与MyISAM引擎的区别 ?</p><table><thead><tr><th>对比项</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。支持聚簇索引</td></tr><tr><td>关注点</td><td>并发查询，节省资源、消耗少、简单业务</td><td>并发写、事务、更大更复杂的资源操作</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr></tbody></table><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>逻辑存储结构</p><p><img src="/./../img/image-20251115211011075.png" alt="image-20251115211011075"></p><p>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。<br>Segment段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。<br>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。<br>页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。<br>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。可以得到索引的本质：<font color='red'>索引是数据结构。</font></p><p>索引的目的在于<font color='red'>提高查询效率</font>，可以类比图书馆书架或者字典。<font color='red'>你可以简单理解为“排好序的快速查找数据结构”。</font></p><p><strong>缺点：</strong><br>（1）创建索引和维护索引要<code>耗费时间</code> 。<br>（2）索引是存储在磁盘上的，因此需要<code>占用磁盘空间</code> 。</p><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>索引结构是指在数据库中用于<strong>组织和管理索引的数据结构</strong>。索引结构的设计和实现对于数据库的性能和效率具有重要影响。</p><p>常见的索引结构包括：</p><p>1、B树(B+tree): B树是一种平衡的<strong>多路搜索树</strong>，被广泛应用于数据库系统中。B树的特点是每个节点可以存储多个键值，并且保持有序。B树的高度相对较低，可以快速定位到目标数据。</p><p>2、Hash索引（Hash Index）：Hash索引使用哈希函数将索引列的值映射为一个固定长度的哈希码，并将哈希码作为索引的键值。Hash索引适用于等值查询，可以快速定位到目标数据。然而，Hash索引不支持范围查询和排序操作。</p><p>3、R树（R-tree）：R树是一种用于处理多维数据的索引结构，常用于地理信息系统（GIS）和空间数据库中。R树可以高效地支持范围查询和最近邻查询。</p><p>4、Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</p><p>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</p><table><thead><tr><th>索引</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>BTREE索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>HASH 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><p>我们平常所说的索引，如果没有特别指明，都是指<strong>B+树</strong>（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、</p><p>唯一索引默认都是使用 B+tree 索引，统称为索引。</p><h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><p>为了解决AVL浪费磁盘空间以及IO次数过多的问题，我们在一个节点中多存储一些数据，之前我们放一个，现在我们放多个。如果放int值（4B）我们近乎可以放4096个值，当然索引里面还包含其他的数据，不能够放这么多，但是这也是足够的多了。</p><p>这样一个节点的值多了那么树的分叉肯定就多了，假如一个节点可以存储1000的值，那么1000 * 1000 * 1000 &#x3D; 10亿节点，3层的结构就能存储10亿的数据，这样是不是最多IO3次就足够了呢。</p><p>所以AVL的进化体B-Tree出现了，B-Tree的全名是多路平衡查找树</p><p>示例如下:</p><p><code>蓝色</code>部分表示数据的主键，<code>黄色</code>部分表示除主键外的其他数据，<code>紫色</code>部分表示指向子节点的指针</p><p><img src="/./../img/image-20251115212744979.png" alt="image-20251115212744979"></p><p>假设我们想要 查找的数据项是 9 ，那么步骤可以分为以下几步：</p><p>1、第一次磁盘IO：找到根节点磁盘块1，读入内存，执行二分查找，9 小于 17 ，得到指针 P1</p><p>2、第二次磁盘IO：按照指针P1找到磁盘块 2，读入内存，执行二分查找， 9 在 8 和 12 之间，得到指针 P2</p><p>3、第三次磁盘IO：按照指针P2找到磁盘块 6，读入内存，执行二分查找， 找到了数据项 9。</p><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果<strong>把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的</strong>。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。 B树相比于平衡二叉树来说磁盘 I&#x2F;O 操作要少 ，在数据查询中比平衡二叉树效率要高。所以只要树的高度足够低，IO次数足够少，就可以提高查询性能 </p><h4 id="聚簇非聚簇索引"><a href="#聚簇非聚簇索引" class="headerlink" title="聚簇非聚簇索引"></a>聚簇非聚簇索引</h4><p>什么是聚集索引（clustered index organize table ），聚集索引中键值的逻辑顺序和表中相应行的物理顺序相同。</p><p>聚簇索引&#x3D;&#x3D;主键索引&#x3D;&#x3D;聚集索引  非聚簇索引&#x3D;&#x3D;二级索引&#x3D;非聚集索引</p><p>聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（联合索引），就像电话簿按姓氏和名字进行组织一样，但是在innodb的设计中聚集索引包含整行的数据，所以innodb中索引就是数据本身，这就是大家常说的索引即数据。</p><p>每个InnoDB表都有一个特殊的索引，称为聚簇索引 ，用于存储行数据。通常，聚簇索引与主键同义 。</p><p>非聚集索引的话其实就是一个普通索引，但是非聚集索引不存储全部数据，只存储聚集索引的值（一般为主键id）。</p><p>所以我们如果使用B-Tree来作为索引结构的话，如果数据行过大，那么一个页存储的数据就会大大减少，这就违背了我们B-Tree的初衷了——在一个页中尽可能的存储多的数据。像前面说的如果我们存储int类型可以存储几千个，那么如果我们存储整行数据呢，可能只能存储三四个，那么树的深度就会大大增加，而且我们的内存空间是有限的，每次mysql预读进来的索引数量有限，这进一步导致搜索效率变差。所以我们想要的索引就是只包含索引字段，不应该包含全部的数据,于是乎,B+Tree来</p><h4 id="4-2-2-5-B-Tree索引"><a href="#4-2-2-5-B-Tree索引" class="headerlink" title="4.2.2.5.  B+Tree索引"></a>4.2.2.5.  B+Tree索引</h4><p>为了解决只存储索引的问题，B-Tree的plus版本横空出世，那就是B+树。</p><p>B+ 树是一种树 数据结构，是一个n叉树，每个节点通常有多个孩子，一颗B+树包含根节点、内部节点和叶子节点，和B-Tree几乎一样，只不过B+Tree不再包含整行的数据了。B+ 树通常用于数据库和操作系统的文件系统中。<strong>B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。</strong></p><p><img src="/./../img/image-20251115214014186.png" alt="image-20251115214014186"></p><p>​所有的数据都存储到了叶子节点,非叶子节点只会存储指向下级的指针</p><p>​叶子节点底层是一个双向链表的实现,我们只需要大致查询到存储到哪个叶子节点,然后进行有序遍历即可</p><p>B+Tree与B-Tree 的区别</p><ol><li>数据下移，所有的非叶子节点不再存储数据而将数据全部存储到叶子节点。</li><li>所有的叶子节点都有一个双向的指针，做了一个双向链表</li><li>使用B+Tree查询次数相对固定，因为数据都在叶子节点，每一个层级都会被加载扫描</li></ol><h4 id="4-2-2-6-回表"><a href="#4-2-2-6-回表" class="headerlink" title="4.2.2.6. 回表"></a>4.2.2.6. 回表</h4><h4 id="背诵"><a href="#背诵" class="headerlink" title="背诵"></a>背诵</h4><p><strong>回表是用二级索引查数据时，因索引不包含查询列，需再用主键值去主键索引查完整行的过程。避免回表的方法是用覆盖索引（索引包含所有查询列）</strong></p><p>非聚集索引如何获取数据</p><p>从这个图我们就可以直观的看到，非聚集索引是怎么查询数据的。每次查非聚集索引都会再次通过主键再次去聚集索引里面查询。</p><p>这里我们再引申出一个概念那就是回表，我们上图所描述的流程就是回表。回表的原因是我们需要获取的是整行或者是包含非索引字段的数据，因非聚集索引没有该字段所以需要回表查询。</p><p><strong>问题</strong>：<br>为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不OK吗？<br><strong>回答</strong>：<br>如果把完整的用户记录放到叶子节点是可以不用回表。但是太占地方了，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。(相当于我要一片树叶,你把一整棵树砍了下来)</p><p>**问题:**为什么我们要尽量避免select * 操作</p><p><strong>回答</strong></p><p>例如我们查询<code>SELECT * FROM USER WHERE name LIKE &#39;张%&#39;</code>，但是我们其实想要的只是名字的集合而已，那么我们就可以改造成<code>SELECT name FROM USER WHERE name LIKE &#39;张%&#39;</code>,前者会回表查询而后者不会，这应就减少了数据查询的时间同时也减少了数据库的压力。</p><p>思考:</p><p><strong>为什么辅助索引不直接存数据的地址而存主键id呢</strong></p><p>因为数据会不断的变动，所以他的地址会跟着一起变。如果直接存储地址，下次找的数据可能就不是原先的数据</p><p><strong>索引是不是创建的越多越好呢</strong></p><p>并不是</p><ul><li>我们已经知道了索引即数据，那么我们过多的创建索引就会导致数据量的增加。</li><li>我们知道索引是一颗平衡树，我们在更新数据的同时，索引也在频繁的进行页分裂和合并，非常耗时</li></ul><h2 id="4-3-索引的优劣势"><a href="#4-3-索引的优劣势" class="headerlink" title="4.3. 索引的优劣势"></a>4.3. 索引的优劣势</h2><p>优势：</p><ol><li>类似大学图书馆建书目索引，<font color='red'>提高数据检索的效率</font>，降低数据库的IO成本。</li><li>通过索引列对数据进行排序，<font color='red'>降低数据排序和分组的成本</font>，降低了CPU的消耗。</li><li>加速表和表之间的连接，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</li></ol><p>劣势：</p><ol><li><p>虽然索引大大提高了查询速度，同时却会<font color='red'>降低更新表的速度</font>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</p></li><li><p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以<font color='red'>索引列也是要占用空间的</font></p></li></ol><h2 id="4-4-MySQL索引分类"><a href="#4-4-MySQL索引分类" class="headerlink" title="4.4. MySQL索引分类"></a>4.4. MySQL索引分类</h2><ul><li>从功能逻辑上划分，索引主要有 4 种，分别是<code>普通索引、唯一索引、主键索引、全文索引</code>。</li><li>按照作用字段个数划分，索引可以分为<code>单列索引和联合索引</code>。</li><li>按照物理实现方式划分 ，索引可以分为 2 种，分别是<code>聚簇索引和非聚簇索引</code>。</li></ul><h1 id="基础补充"><a href="#基础补充" class="headerlink" title="基础补充"></a>基础补充</h1><h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a><strong>三范式</strong></h2><p>是数据库设计中的基本规范，主要包括：</p><ol><li><p>[<strong>第一范式（1NF）</strong>：确保每个字段（列）的值都是原子性的，不可再分。 ]</p></li><li><p>[<strong>第二范式（2NF）</strong>：在满足1NF的基础上，消除部分依赖，确保非主键字段完全依赖于主键。 ]</p></li><li><p>[<strong>第三范式（3NF）</strong>：在满足2NF的基础上，消除传递依赖，确保非主键字段直接依赖于主键。 ]</p><p>这些范式的目的是减少数据冗余，提高数据一致性，并降低更新异常的风险。</p></li></ol><h2 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="[主键和外键有什么区别?]"></a>[主键和外键有什么区别?]</h2><ul><li><strong>主键(主码)</strong>：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li><li><strong>外键(外码)</strong>：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li></ul><p>为什么不要用外键呢？大部分人可能会这样回答：</p><ol><li><strong>增加了复杂性：</strong> a. 每次做 DELETE 或者 UPDATE 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如哪天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li><li><strong>增加了额外工作</strong>：数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗数据库资源。如果在应用层面去维护的话，可以减小数据库压力；</li><li><strong>对分库分表不友好</strong>：因为分库分表下外键是无法生效的。</li></ol><h2 id="drop、delete-与-truncate-区别？"><a href="#drop、delete-与-truncate-区别？" class="headerlink" title="drop、delete 与 truncate 区别？"></a>drop、delete 与 truncate 区别？</h2><ul><li><code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li><li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li><li><code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。</li></ul><p><code>truncate</code> 和不带 <code>where</code>子句的 <code>delete</code>、以及 <code>drop</code> 都会删除表内的数据，但是 <strong><code>truncate</code> 和 <code>delete</code> 只删除数据不删除表的结构(定义)，执行 <code>drop</code> 语句，此表的结构也会删除，也就是执行<code>drop</code> 之后对应的表不复存在。</strong></p><h1 id="深分页问题的本质"><a href="#深分页问题的本质" class="headerlink" title="深分页问题的本质"></a>深分页问题的本质</h1><p>❌ 问题现象：<code>offset</code>越大，查询越慢</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 深分页查询（性能灾难！）</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> orders <br><span class="hljs-keyword">WHERE</span> create_time &gt; <span class="hljs-string">&#x27;2023-01-01&#x27;</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> create_time <br><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1000000</span>, <span class="hljs-number">10</span>;  <span class="hljs-comment">-- offset=100万，查询可能要1秒+</span><br></code></pre></td></tr></table></figure><h3 id="一-为什么慢？MySQL的”笨拙”执行方式"><a href="#一-为什么慢？MySQL的”笨拙”执行方式" class="headerlink" title="一 为什么慢？MySQL的”笨拙”执行方式"></a>一 为什么慢？MySQL的”笨拙”执行方式</h3><table><thead><tr><th>步骤</th><th>说明</th><th>性能代价</th></tr></thead><tbody><tr><td><strong>1. 扫描前offset行</strong></td><td>MySQL必须从头扫描1,000,000行，才能定位到第1,000,001行</td><td><strong>I&#x2F;O开销巨大</strong>（100万行读磁盘）</td></tr><tr><td><strong>2. 排序</strong></td><td>如果<code>ORDER BY</code>无索引 → <strong>filesort</strong>（内存排序）</td><td><strong>CPU开销大</strong>（尤其大数据量）</td></tr><tr><td><strong>3. 返回结果</strong></td><td>仅返回10行，但已扫描1,000,000行</td><td><strong>99.99%的开销浪费！</strong></td></tr></tbody></table><h2 id="二、5种高效优化方案（附实战代码）"><a href="#二、5种高效优化方案（附实战代码）" class="headerlink" title="二、5种高效优化方案（附实战代码）"></a>二、5种高效优化方案（附实战代码）</h2><h3 id="✅-方案1：基于主键的分页（推荐！最简单高效）"><a href="#✅-方案1：基于主键的分页（推荐！最简单高效）" class="headerlink" title="✅ 方案1：基于主键的分页（推荐！最简单高效）"></a>✅ 方案1：基于主键的分页（推荐！最简单高效）</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 优化前（深分页，慢！）</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1000000</span>, <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">-- 优化后（基于主键，快如闪电！）</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> orders <br><span class="hljs-keyword">WHERE</span> id &gt; <span class="hljs-number">1000000</span>  <span class="hljs-comment">-- 用上一次的最后id</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id <br><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><blockquote><p><strong>为什么快？</strong></p><ul><li><code>id &gt; 1000000</code>直接走主键索引（B+树），<strong>无需扫描100万行</strong></li><li>查询时间≈<code>0.001秒</code>（与offset无关！）<br><strong>✅ 适用场景</strong>：主键连续、无删除的场景</li></ul></blockquote><blockquote><p>💡 <strong>类比</strong>：<br> <strong>“深分页 &#x3D; 在图书馆翻100万本书找第1000001本</strong><br> <strong>基于主键分页 &#x3D; 直接去第1000001书架取书！”</strong> 📚</p></blockquote><hr><h3 id="✅-方案2：子查询优化（适用于无主键场景）"><a href="#✅-方案2：子查询优化（适用于无主键场景）" class="headerlink" title="✅ 方案2：子查询优化（适用于无主键场景）"></a>✅ 方案2：子查询优化（适用于无主键场景）</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 优化前（慢！）</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1000000</span>, <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">-- 优化后（用子查询定位起点）</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> orders <br><span class="hljs-keyword">WHERE</span> id &gt;= (<br>    <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> orders <br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id <br>    <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1000000</span>, <span class="hljs-number">1</span><br>) <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id <br><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><blockquote><p><strong>为什么快？</strong></p><ul><li>子查询只查1行（<code>LIMIT 1000000, 1</code>），<strong>避免全表扫描</strong></li><li>外层查询用<code>id &gt;=</code>走索引<br><strong>✅ 适用场景</strong>：主键不连续（如UUID主键）</li></ul></blockquote><blockquote><p>⚠️ <strong>注意</strong>：</p><ul><li>子查询需<strong>有索引</strong>（否则更慢！）</li><li>优化后时间≈<code>0.005秒</code>（比深分页快200倍！）</li></ul></blockquote><hr><h3 id="✅-方案3：游标分页（应用层维护last-id）"><a href="#✅-方案3：游标分页（应用层维护last-id）" class="headerlink" title="✅ 方案3：游标分页（应用层维护last_id）"></a>✅ 方案3：游标分页（应用层维护last_id）</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">// Java伪代码（应用层实现）<br>int lastId = 0;<br>List&lt;Order&gt; orders = query(&quot;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> id &gt; ? <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span><span class="hljs-string">&quot;, lastId);</span><br><span class="hljs-string">lastId = orders.get(orders.size() - 1).getId(); // 记录最后id</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>为什么最安全？</strong></p><ul><li><strong>完全避免offset</strong>（应用层维护游标）</li><li>无数据跳跃&#x2F;重复（即使有删除）</li><li><strong>性能恒定</strong>：每次查询≈<code>0.001秒</code><br><strong>✅ 适用场景</strong>：所有分页场景（尤其移动端）</li></ul></blockquote><blockquote><p>💡 <strong>真实案例</strong>：<br> 某电商平台用游标分页后，<strong>分页接口响应时间从1.2秒降到0.003秒</strong>（提升400倍！）</p></blockquote><hr><h3 id="✅-方案4：覆盖索引优化（避免回表）"><a href="#✅-方案4：覆盖索引优化（避免回表）" class="headerlink" title="✅ 方案4：覆盖索引优化（避免回表）"></a>✅ 方案4：覆盖索引优化（避免回表）</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 创建覆盖索引（包含查询字段）</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_cover <span class="hljs-keyword">ON</span> orders (id, create_time, amount);<br><br><span class="hljs-comment">-- 优化查询（直接从索引取数据，无需回表）</span><br><span class="hljs-keyword">SELECT</span> id, create_time, amount <br><span class="hljs-keyword">FROM</span> orders <br><span class="hljs-keyword">WHERE</span> id &gt; <span class="hljs-number">1000000</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id <br><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><blockquote><p><strong>为什么快？</strong></p><ul><li><code>SELECT</code>字段都在索引中 → <strong>无需回表</strong>（减少I&#x2F;O）</li><li><code>WHERE id &gt;</code>走索引 → <strong>避免全表扫描</strong><br><strong>✅ 适用场景</strong>：查询字段少、需快速返回</li></ul></blockquote><hr><h3 id="✅-方案5：延迟关联（适用于排序字段非主键）"><a href="#✅-方案5：延迟关联（适用于排序字段非主键）" class="headerlink" title="✅ 方案5：延迟关联（适用于排序字段非主键）"></a>✅ 方案5：延迟关联（适用于排序字段非主键）</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 优化前（慢！）</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> create_time <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1000000</span>, <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">-- 优化后（延迟关联）</span><br><span class="hljs-keyword">SELECT</span> o.* <br><span class="hljs-keyword">FROM</span> orders o<br><span class="hljs-keyword">JOIN</span> (<br>    <span class="hljs-keyword">SELECT</span> id <br>    <span class="hljs-keyword">FROM</span> orders <br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> create_time <br>    <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1000000</span>, <span class="hljs-number">10</span><br>) tmp <span class="hljs-keyword">ON</span> o.id = tmp.id;<br></code></pre></td></tr></table></figure><blockquote><p><strong>为什么快？</strong></p><ul><li>子查询只查<code>id</code>（小字段），<strong>避免排序大表</strong></li><li>外层用<code>id</code>关联，走主键索引<br><strong>✅ 适用场景</strong>：<code>ORDER BY</code>字段非主键</li></ul></blockquote><hr><h2 id="📊-四、性能对比实测（真实数据）"><a href="#📊-四、性能对比实测（真实数据）" class="headerlink" title="📊 四、性能对比实测（真实数据）"></a>📊 四、性能对比实测（真实数据）</h2><table><thead><tr><th>方案</th><th>offset&#x3D;1000000</th><th>offset&#x3D;10000000</th><th>优化后时间</th></tr></thead><tbody><tr><td><strong>深分页</strong></td><td>1.0秒</td><td>10秒+</td><td>❌ 无法用</td></tr><tr><td><strong>基于主键</strong></td><td>0.001秒</td><td>0.001秒</td><td>✅ <strong>最优</strong></td></tr><tr><td><strong>子查询</strong></td><td>0.005秒</td><td>0.005秒</td><td>✅ 次优</td></tr><tr><td><strong>游标分页</strong></td><td>0.001秒</td><td>0.001秒</td><td>✅ <strong>最安全</strong></td></tr><tr><td><strong>覆盖索引</strong></td><td>0.002秒</td><td>0.002秒</td><td>✅ 适合小字段</td></tr></tbody></table><blockquote><p>💡 <strong>结论</strong>：<br> <strong>游标分页 + 基于主键</strong> &#x3D; <strong>性能+安全双保险</strong>！<br> <strong>避免深分页 &#x3D; 代码优雅+用户体验提升</strong>！</p></blockquote><p>❌ 误区1：”用<code>LIMIT 1000000, 10</code>没问题，反正数据量不大”</p><ul><li><p><strong>错误</strong>：数据量增长后，查询时间<strong>指数级上升</strong>！</p></li><li><p>正确：永远不要用大offset！</p><blockquote><p>“在MySQL的江湖里，<code>offset</code>是’定时炸弹’——<br> 今天能用，明天就崩！” 💣</p></blockquote></li></ul><p>❌ 误区2：”加了索引就解决了深分页”</p><ul><li><p><strong>错误</strong>：索引能加速<code>WHERE</code>和<code>ORDER BY</code>，但<strong>不能解决扫描offset行的问题</strong>！</p></li><li><p>正确：</p><blockquote><p>“索引是’加速器’，但深分页需要’绕过扫描’——<br> 用<code>WHERE id &gt; last_id</code>才是’救命稻草’！” 🛟</p></blockquote></li></ul><p>❌误区3：”分页用<code>offset</code>，但<code>ORDER BY</code>用主键”</p><ul><li><p><strong>错误</strong>：<code>ORDER BY id</code>能加速排序，但**<code>LIMIT offset, size</code>仍需扫描offset行**！</p></li><li><p>正确</p><p>：</p><blockquote><p>“即使<code>ORDER BY id</code>，<code>offset</code>过大时，<strong>MySQL仍要扫描offset行</strong>！<br> —— 这就是为什么<code>ORDER BY id</code>不能解决深分页问题！” 📉</p></blockquote></li></ul><h3 id="Q：为什么深分页性能差？如何优化？"><a href="#Q：为什么深分页性能差？如何优化？" class="headerlink" title="Q：为什么深分页性能差？如何优化？"></a>Q：为什么深分页性能差？如何优化？</h3><p><strong>A</strong>：</p><blockquote><p>“深分页问题源于MySQL的执行逻辑：<code>LIMIT offset, size</code>会<strong>扫描前offset行</strong>，导致I&#x2F;O开销随offset指数级增长。<br> <strong>优化核心</strong>：用<code>WHERE id &gt; last_id</code>替代<code>offset</code>，让查询时间<strong>与offset无关</strong>。<br> <strong>最佳实践</strong>：</p><ol><li>优先用<strong>游标分页</strong>（应用层维护last_id）</li><li>确保有<strong>主键索引</strong>（或覆盖索引）<br><strong>—— 优化后，查询时间从秒级降到毫秒级！”</strong> ✅</li></ol></blockquote><h3 id="Q：基于主键的分页有什么缺陷？"><a href="#Q：基于主键的分页有什么缺陷？" class="headerlink" title="Q：基于主键的分页有什么缺陷？"></a>Q：基于主键的分页有什么缺陷？</h3><p><strong>A</strong>：</p><blockquote><p>“主要缺陷：<strong>如果主键有删除，可能导致数据跳跃</strong>（例如：主键1000000被删除，下一页从1000001开始，但实际数据在1000002）。<br> <strong>但实际业务中，99%的场景可接受</strong>：</p><ul><li>用户不会抱怨’漏了1条’（除非是金融系统）</li><li>用<strong>游标分页+应用层补偿</strong>可完全规避<br><strong>—— 比深分页慢100倍的代价，不值得为1%的缺陷妥协！”</strong> 🤷‍♂️</li></ul></blockquote><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13对象内存和反射</title>
    <link href="/2025/11/15/13%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
    <url>/2025/11/15/13%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="a对象如何存储"><a href="#a对象如何存储" class="headerlink" title="a对象如何存储"></a>a对象如何存储</h1><p><img src="/./../img/pqmd75qtz-_a66lc6uWYi.png"></p><p><strong>HotSpot</strong>是使用指针的方式来访问对象：</p><p>Java堆中会存放指向<code>类元数据</code>的地址</p><p>Java栈中的reference存储的是指向堆中的对象的地址</p><h2 id="类元数据"><a href="#类元数据" class="headerlink" title="类元数据"></a>类元数据</h2><ul><li><strong>对象类型数据</strong>：存储类的元数据（如类的结构、方法、字段等信息）。</li></ul><p>简单来说：<strong>元数据是”类的说明书”</strong>，告诉JVM”这个类长什么样、有什么方法、有什么字段”。</p><hr><h3 id="类的元数据包含哪些内容？（核心组成）"><a href="#类的元数据包含哪些内容？（核心组成）" class="headerlink" title="类的元数据包含哪些内容？（核心组成）"></a>类的元数据包含哪些内容？（核心组成）</h3><table><thead><tr><th>元数据类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><strong>类名</strong></td><td>类的完整名称（包括包名）</td><td><code>com.example.Person</code></td></tr><tr><td><strong>父类</strong></td><td>继承的父类</td><td><code>java.lang.Object</code></td></tr><tr><td><strong>接口</strong></td><td>实现的接口列表</td><td><code>Serializable</code>, <code>Cloneable</code></td></tr><tr><td><strong>字段</strong></td><td>成员变量信息（名称、类型、访问权限）</td><td><code>private String name;</code></td></tr><tr><td><strong>方法</strong></td><td>方法信息（名称、参数、返回类型、访问权限）</td><td><code>public String getName()</code></td></tr><tr><td><strong>常量池</strong></td><td>字符串常量、类常量等</td><td><code>&quot;Hello World&quot;</code></td></tr><tr><td><strong>访问标志</strong></td><td>类&#x2F;方法的访问权限（public、private等）</td><td><code>public final class</code></td></tr><tr><td><strong>注解</strong></td><td>类&#x2F;方法&#x2F;字段上的注解</td><td><code>@Deprecated</code>, <code>@Override</code></td></tr></tbody></table><h3 id="元数据-vs-实例数据（关键区别）"><a href="#元数据-vs-实例数据（关键区别）" class="headerlink" title="元数据 vs 实例数据（关键区别）"></a>元数据 vs 实例数据（关键区别）</h3><table><thead><tr><th>项目</th><th>元数据</th><th>实例数据</th></tr></thead><tbody><tr><td><strong>存储位置</strong></td><td>方法区（或元空间）</td><td>Java堆</td></tr><tr><td><strong>生命周期</strong></td><td>类加载时创建，JVM运行期间存在</td><td>通过<code>new</code>创建，随对象销毁而回收</td></tr><tr><td><strong>内容</strong></td><td>类的”说明书”（静态结构）</td><td>对象的实际数据（动态值）</td></tr><tr><td><strong>示例</strong></td><td><code>Person</code>类的字段&#x2F;方法定义</td><td><code>new Person(&quot;Tom&quot;, 25)</code>中的<code>name=&quot;Tom&quot;</code></td></tr><tr><td><strong>数量</strong></td><td>每个类只有1份</td><td>每个对象1份</td></tr></tbody></table><blockquote><p>💡 <strong>类比理解</strong>：<br>元数据 &#x3D; 《房屋设计图纸》<br>实例数据 &#x3D; 真实建造的房屋（每个房子不同）</p></blockquote><hr><h3 id="为什么需要元数据？（为什么不是只有代码）"><a href="#为什么需要元数据？（为什么不是只有代码）" class="headerlink" title="为什么需要元数据？（为什么不是只有代码）"></a>为什么需要元数据？（为什么不是只有代码）</h3><p>如果JVM只存储代码，<strong>无法实现以下功能</strong>：</p><ul><li><code>instanceof</code> 检查（<code>obj instanceof Person</code>）</li><li>动态加载类（<code>Class.forName(&quot;com.example.Person&quot;)</code>）</li><li>注解处理（如Spring的<code>@Autowired</code>）</li><li>类型安全检查（编译器在运行时验证）</li></ul><blockquote><p>✅ <strong>总结</strong>：元数据是JVM理解”类”的<strong>唯一桥梁</strong>，没有它，Java的动态特性（反射、注解、动态代理等）将无法实现。</p></blockquote><p>实际内存中的表现（简化版）</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">方法区（元空间）：</span><br><span class="hljs-attribute">┌───────────────────────────────────────┐</span><br><span class="hljs-attribute">│          类元数据 (Person)            │</span><br><span class="hljs-attribute">├───────────────┬───────────────────────┤</span><br><span class="hljs-attribute">│ 类名</span><span class="hljs-punctuation">:</span> <span class="hljs-string">        │ com.example.Person    │</span><br><span class="hljs-attribute">│ 父类</span><span class="hljs-punctuation">:</span> <span class="hljs-string">        │ java.lang.Object      │</span><br><span class="hljs-attribute">│ 接口</span><span class="hljs-punctuation">:</span> <span class="hljs-string">        │ Serializable          │</span><br><span class="hljs-attribute">│ 字段列表</span><span class="hljs-punctuation">:</span> <span class="hljs-string">    │ name(String), age(int)│</span><br><span class="hljs-attribute">│ 方法列表</span><span class="hljs-punctuation">:</span> <span class="hljs-string">    │ Person(String,int),   │</span><br>│               │ getName():String      │<br><span class="hljs-attribute">│ 访问标志</span><span class="hljs-punctuation">:</span> <span class="hljs-string">    │ public                │</span><br><span class="hljs-attribute">│ 注解</span><span class="hljs-punctuation">:</span> <span class="hljs-string">        │ @Deprecated           │</span><br><span class="hljs-attribute">└───────────────┴───────────────────────┘</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">Java堆：</span><br><span class="hljs-attribute">┌───────────────────────────────────────┐</span><br><span class="hljs-attribute">│          实例对象 (Person)            │</span><br><span class="hljs-attribute">├───────────────┬───────────────────────┤</span><br><span class="hljs-attribute">│ name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">        │ &quot;Tom&quot;                 │</span><br><span class="hljs-attribute">│ age</span><span class="hljs-punctuation">:</span> <span class="hljs-string">         │ 25                    │</span><br>└───────────────┴───────────────────────┘<br></code></pre></td></tr></table></figure><h3 id="💡-关键点："><a href="#💡-关键点：" class="headerlink" title="💡 关键点："></a>💡 <strong>关键点</strong>：</h3><p> 元数据在<strong>方法区</strong>（类加载时创建），<br> 实例数据在<strong>堆</strong>（运行时创建），<br> <strong>元数据描述了实例数据的结构</strong>。</p><h1 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h1><p><img src="/./../img/image-20251031103847805.png" alt="image-20251031103847805"></p><p><img src="/./../img/image-20251031111448650.png" alt="image-20251031111448650"></p><p>放在了栈中</p><p>64为虚拟机markword详情如下：</p><p><img src="/./../img/image-20251031111644199.png" alt="image-20251031111644199"></p><h1 id="反射话术"><a href="#反射话术" class="headerlink" title="反射话术"></a>反射话术</h1><pre><code class="hljs">4,反射原理反射是什么指在程序运行期间动态获取和操作类元数据的一种机制反射为什么(原理)与类元数据有关 类元数据保存在了方法区中(类元数据==类信息==Class)每个对象的对象头中都有一个指向类元信息的一个类元指针反射原理其实指的就是在运行的时候，通过获取对象头中的classPointer（老家地址）指向方法区的类元信息instanceKlass对象中的_java_mirror 属性来获取对应的类对象,该对象我们是可以直接操作的(获取类各个信息的能力,比如类名,父类接口 变量方法等信息)反射怎么用Class.ForName(&quot;类的全类路径名&quot;)Object.getClass() 对象.class通过setAccessible(true)可绕过访问权限检测--暴力反射原本要获取的对象被private修饰,可以通过该方法进行暴力获取</code></pre><p><img src="/./../img/image-20251031112811179.png" alt="image-20251031112811179"></p><p>Klass概念（加载到了方法区的class对象）<br>Klass是c++层面类元信息的抽象，对应java层面的class<br>Klass 继承自 Metadata 继承自 MetaspaceObj<br>InstanceKlass继承自Klass，InstanceKlass是.class文件被加载到元空间中的存在形式</p><h2 id="1-9-3-总结"><a href="#1-9-3-总结" class="headerlink" title="1.9.3.总结"></a>1.9.3.总结</h2><p>反射提供了认识自身的一种途径java反射提供了在运行时获取类各个信息的能力,比如类名，父类接口变量方法等信息</p><p>反射原理其实指的就是在运行的时候，通过获取对象头中的classPointer（老家地址）指向方法区的类元信息instanceKlass对象<br>中的_java_mirror 属性来获取对应的类对象,该对象我们是可以直接操作的(获取类各个信息的能力,比如类名,父类接口 变量方法等信息)</p><h2 id="重要point"><a href="#重要point" class="headerlink" title="重要point"></a>重要point</h2><p>引用存在了栈中，类元指针指向了堆中的klass</p><h1 id="话术"><a href="#话术" class="headerlink" title="话术"></a>话术</h1><h3 id="简述Java创建对象的过程"><a href="#简述Java创建对象的过程" class="headerlink" title="[简述Java创建对象的过程]"></a>[简述Java创建对象的过程]</h3><ul><li><p>检查该指令的参数能否在常量池中定位到一个类的符号引用，并检查引用代表的类是否已被加载、解析和初始化，如果没有就先执行类加载。</p></li><li><p>通过检查通过后虚拟机将为新生对象分配内存。</p></li><li><p>完成内存分配后虚拟机将成员变量设为零值</p></li><li><p>设置对象头，包括哈希码、GC 信息、锁信息、对象所属类的类元信息等。</p></li><li><p>执行 init 方法，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p><h2 id="类加载器的流程"><a href="#类加载器的流程" class="headerlink" title="类加载器的流程"></a>类加载器的流程</h2><p>从类被加载到虚拟机内存中开始，到释放内存总共有 7 个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p><h3 id="2-1-1-加载"><a href="#2-1-1-加载" class="headerlink" title="[2.1.1 加载]"></a>[2.1.1 加载]</h3><ol><li>将 class 文件加载到内存</li><li>将静态数据结构转化成方法区中运行时的数据结构</li><li>在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口</li></ol><h3 id="2-1-2-链接"><a href="#2-1-2-链接" class="headerlink" title="[2.1.2 链接]"></a>[2.1.2 链接]</h3><ol><li>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</li><li>准备：为 static 变量在方法区中分配内存空间，设置变量的初始值，例如 static int a &#x3D; 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</li><li>解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在 import java.util.ArrayList 这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li></ol><h3 id="2-1-3-初始化"><a href="#2-1-3-初始化" class="headerlink" title="[2.1.3 初始化]"></a>[2.1.3 初始化]</h3><p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static 修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的 0 变成了显式初始化的 3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p><blockquote><p>注意：字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，类构造器方法<code>&lt;clinit&gt;()</code>不同于类的构造器，这些方法都是字节码文件中只能给 JVM 识别的特殊方法。</p></blockquote><h3 id="2-1-4-卸载"><a href="#2-1-4-卸载" class="headerlink" title="[2.1.4 卸载]"></a>[2.1.4 卸载]</h3><p>1 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</p><p>2 该类没有在其他任何地方被引用</p><p>3 该类的类加载器的实例已被 GC</p></li></ul><h3 id="简述JVM给对象分配内存的策略"><a href="#简述JVM给对象分配内存的策略" class="headerlink" title="[简述JVM给对象分配内存的策略]"></a>[简述JVM给对象分配内存的策略]</h3><ul><li>指针碰撞：这种方式在内存中放一个指针作为分界指示器将使用过的内存放在一边，空闲的放在另一边，通过指针挪动完成分配。</li><li>空闲列表：对于 Java 堆内存不规整的情况，虚拟机必须维护一个列表记录哪些内存可用，在分配时从列表中找到一块足够大的空间划分给对象并更新列表记录。</li></ul><h3 id="Java对象内存分配是如何保证线程安全的"><a href="#Java对象内存分配是如何保证线程安全的" class="headerlink" title="[Java对象内存分配是如何保证线程安全的]"></a>[Java对象内存分配是如何保证线程安全的]</h3><p>第一种方法，采用CAS机制，配合失败重试的方式保证更新操作的原子性。该方式效率低。</p><p>第二种方法，每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配。一般采用这种策略。</p><h3 id="简述对象的内存布局"><a href="#简述对象的内存布局" class="headerlink" title="[简述对象的内存布局]"></a>[简述对象的内存布局]</h3><p>对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。</p><p>1）对象头主要包含两部分数据： MarkWord、类型指针。</p><p>MarkWord 用于存储哈希码（HashCode）、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID等信息。</p><p>类型指针即对象指向他的类元数据指针，如果对象是一个 Java 数组，会有一块用于记录数组长度的数据。</p><p>2）实例数据存储代码中所定义的各种类型的字段信息。</p><p>3）对齐填充起占位作用。HotSpot 虚拟机要求对象的起始地址必须是8的整数倍，因此需要对齐填充。</p><p>end？。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12垃圾回收器</title>
    <link href="/2025/11/14/12%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <url>/2025/11/14/12%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p><p>在以下要分析收集器的时候，会涉及到并行，串行，并发的概念，做如下解释：</p><p>并行（Parallel）：指多条垃圾回收线程并行工作，但此时用户线程仍然处于等待状态</p><p>串行（serial）：相较于并行的概念而言，它是单线程执行，如果内存不够，则程序暂停，启动jvm垃圾回收器进行垃圾回收，回收完，再启动程序的线程</p><p>并发（concurrent）：指用户线程与垃圾回收线程同时执行（但不一定并行，可能是交替执行），垃圾回收线程在执行时是不会停顿用户程序的运行  eg：CMS G1</p><h3 id="4-4-1垃圾收集器发展史"><a href="#4-4-1垃圾收集器发展史" class="headerlink" title="4.4.1垃圾收集器发展史"></a>4.4.1垃圾收集器发展史</h3><ol><li>1999年，随JDK 1.3.1 一起来的是串行方式的 <code>Serial GC</code> ，它是第一款GC。<code>ParNew GC</code> 是 <code>Serial GC</code> 的多线程版本。</li><li>2002年2月26日，<code>Parallel GC</code> 和 <code>Concurrent Mark Sweep GC</code>（ 即 <code>CMS</code> ） 跟随 JDK1.4.2 一起发布。</li><li><code>Parallel GC</code> 在 JDK6 之后成为 Hotspot 默认GC。</li><li>2012年，在 JDK1.7u4 中，<code>G1</code> 可用。</li><li>2017年，JDK9 中 <code>G1</code> 成为默认垃圾收集器，以替代 <code>CMS</code>。<strong>从此后，JDK每半年更新一次</strong></li><li>2018年3月，JDK10 中 <code>G1</code> 的并行完整垃圾回收，实现并行性能改善最坏情况的延迟。</li><li>2018年9月，JDK11 发布。引入 <code>EpsilonGC</code> ，又称为“No-Op（无操作）” 回收器；同时引入 <code>ZGC</code>： 可伸缩的低延迟回收器（Experimental）。</li><li>2019年3月，JDK12 发布。增加 <code>G1</code>，自动返回未使用堆内存给操作系统； 同时，引入<code>Shenandoah GC</code>：低停顿时间的GC（Experimental）。</li><li>2019年9月，JDK13 发布。增强 <code>ZGC</code>，自动返回未使用堆内存给操作系统。</li><li>2020年3月，JDK14 发布。删除 <code>CMS</code>。扩展 <code>ZGC</code> 在 mac 和 windows 的应用</li><li><strong>2021年9月</strong>，JDK 17 发布（LTS版本）：进一步增强各GC性能改进了 <code>G1 GC</code> 和 <code>Parallel GC</code> 的可用性</li><li><strong>2022年3月</strong>，JDK 18 发布：主要进行GC性能优化和错误修复 没有引入新的GC特性</li><li><strong>2022年9月</strong>，JDK 19 发布：引入虚拟线程（预览版）改进了 <code>Generational Z GC</code>（分代式ZGC，实验性功能）</li><li><strong>2023年3月</strong>，JDK 20 发布：继续改进 <code>Generational Z GC</code>（仍为实验性）增强各GC与虚拟线程的协作</li><li><strong>2023年9月</strong>，JDK 21 发布（LTS版本）：<code>Generational Z GC</code>（分代式ZGC）正式成为生产特性引入分代模式的 <code>Shenandoah GC</code>进一步优化 <code>G1 GC</code> 的性能和资源利用率</li></ol><h3 id="4-4-2-查看当前所收集器"><a href="#4-4-2-查看当前所收集器" class="headerlink" title="4.4.2 查看当前所收集器"></a>4.4.2 查看当前所收集器</h3><p>-XX:+PrintCommandLineFlags</p><h3 id="4-4-3-Serial-SerialOld-串行回收（客户端单cpu）"><a href="#4-4-3-Serial-SerialOld-串行回收（客户端单cpu）" class="headerlink" title="**4.4.3. Serial&#x2F;**SerialOld-串行回收（客户端单cpu）"></a>**4.4.3. Serial&#x2F;**SerialOld-串行回收（客户端单cpu）</h3><p>串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）适用于单核CPU的服务器（客户端等）</p><p>它还有对应老年代的版本：<strong>Serial Old</strong></p><p>参数控制： <code>-XX:+UseSerialGC</code> 串行收集器</p><p><img src="/./../img/image-20251101140049681.png" alt="image-20251101140049681"></p><p>这个收集器是一个单线程的收集器,但它的”单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作,更重要的是在它进行垃圾回收时,必须暂停其他所有的工作线程,直到它收集结束(STW)</p><h3 id="4-4-4-ParNew-并行回收"><a href="#4-4-4-ParNew-并行回收" class="headerlink" title="4.4.4.ParNew-并行回收"></a>4.4.4.ParNew-并行回收</h3><p>ParNew收集器其实就是Serial收集器的多线程版本。Par是parallel的缩写,New:只能处理的是新生代 所以它的特点是: 新生代并行(有多条垃圾回收线程)，老年代串行；新生代复制算法、老年代标记-压缩</p><p>ParNew收集器除了采用并行回收的方式执行内存回收外,与serial收集器几乎没有任何区别</p><p>参数控制：</p><p><code>-XX:+UseParNewGC</code> ParNew收集器<br><code>-XX:ParallelGCThreads</code> 限制线程数量</p><p><img src="/./../img/image-20251102000823570.png" alt="image-20251102000823570"></p><p>对于新生代,回收次数频繁,使用并行方式高效</p><p>对于老年代,回收次数少,使用 串行方式节省资源(cpu并行需要切换线程,串行可以省去切换线程的资源)</p><p>在收集器组合关系图中</p><p>ParNew+Serial Old  遗憾的是在JDK9中，组合被遗弃</p><p>parNew+CMS           遗憾的是在JDK14中CMS被移除</p><p>遗憾的是ParNew 也会逐渐被放弃~~~</p><p><img src="/./../img/image-20251106080951548.png" alt="image-20251106080951548"></p><h3 id="4-4-5-Parallel-吞吐量优先"><a href="#4-4-5-Parallel-吞吐量优先" class="headerlink" title="4.4.5. Parallel-吞吐量优先"></a>4.4.5. Parallel-吞吐量优先</h3><p>Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的<strong>吞吐量</strong>。可以通过参数来打开<strong>自适应调节策略</strong>，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；</p><p>新生代复制算法、老年代标记-压缩 但同样也是基于并行回收和STW机制 </p><p>高吞吐量则可以高效率的利用cpu资源,尽快完成程序的运算任务,主要适合在后台运算而不需要太多交互的任务,因此,常见在服务器环境中使用,eg:执行批量处理,订单处理,工资支付,科学计算的应用程序</p><p>参数控制： <code>-XX:+UseParallelGC</code> 使用Parallel收集器+ 老年代串行</p><h3 id="4-4-6-Parallel-Old-收集器"><a href="#4-4-6-Parallel-Old-收集器" class="headerlink" title="4.4.6. Parallel Old 收集器"></a>4.4.6. Parallel Old 收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－压缩”算法。这个收集器是在JDK 1.6中才开始提供</p><p>参数控制： <code>-XX:+UseParallelOldGC</code> 使用Parallel收集器+ 老年代并行</p><h3 id="4-4-7-CMS收集器-低延迟"><a href="#4-4-7-CMS收集器-低延迟" class="headerlink" title="4.4.7. CMS收集器-低延迟"></a>4.4.7. CMS收集器-低延迟</h3><p>在JDk1.5时期,HotSpot推出了一款在强交互应用中有划时代意义的垃圾收集器CMS(Concurrent-Mark-Sweep),这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器,它第一次实现了让垃圾收集线程与用户线程同时工作 </p><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p><p>不幸的是,CMS作为老年代的收集器,却无法与jdk1.4中已经存在的新生代收集器parallel scavenge 配合工作,所以在jdk1.5中使用的CMS来收集老年代的时候,新生代只能选择ParNew或者serial收集器中的一个</p><p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p><p><img src="/./../img/image-20251102000520953.png" alt="image-20251102000520953"></p><ul><li>初始标记（CMS initial mark）<ul><li>在这个阶段中,程序中所有的工作线程都将会因为STW机制而出现暂停,这个阶段的主要任务仅仅是标记出GC Roots能直接关联到的对象,一旦比较完成之后就会恢复之前被暂停的所有应用线程,由于直接关联对象比较小,所以这里的速度非常快</li></ul></li><li>并发标记（CMS concurrent mark）<ul><li>从GC Roots 的直接关联对象开始遍历整个对象图的过程,这个过程耗时较长,但是不需要停顿用户线程,可以与垃圾收集线程一起并发运行</li></ul></li><li>重新标记（CMS remark）<ul><li>由于在并发标记阶段中,程序的工作线程会和垃圾收集线程同时运行,因此为了修正并发标记期间,因用户程序运行而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间通常会比初始标记阶段稍长一些,但也远比并发标记阶段的时间短</li></ul></li><li>并发清除（CMS concurrent sweep）<ul><li>此阶段清理删除掉标记阶段判断的已经死亡的对象,释放内存空间,由于不需要移动存活对象,所以这个阶段也是可以和用户线程同时并发的</li></ul></li></ul><p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。CMS属于老年代收集器（新生代使用ParNew）</p><p><strong>优点</strong>: 并发收集、低停顿<br><strong>缺点</strong>: </p><p>​会产生内存碎片碎片会导致并发清除之后,用户线程可用的空间不足,在无法分配大对象的情况下,不得不提前触发Full GC,也是CMS收集器所存在的一种定时炸弹,在某种极端情况下,会启动serial Old 收集器来重新进行老年代的垃圾回收,这样STW就会变长</p><p>小结:</p><p>​如果你想要最小化地使用内存和并行开销,请选serial GC</p><p>​如果你想要最大化应用程序的吞吐量,请选Parallel GC</p><p>​如果你想要最小化GC的中断或停顿时间,请选CMS GC + ParNew</p><p>但遗憾的是,在jdk9中被标记为过时,在jdk14中,已经将CMS废弃</p><h3 id="4-4-8-G1收集器"><a href="#4-4-8-G1收集器" class="headerlink" title="4.4.8. G1收集器"></a>4.4.8. G1收集器</h3><h4 id="4-4-8-1-简介"><a href="#4-4-8-1-简介" class="headerlink" title="4.4.8.1.简介"></a>4.4.8.1.简介</h4><p>G1全称 Garbage First(<strong>垃圾优先</strong>)</p><p> G1是在java7 之后引入的一个新的收器</p><p>核心设计思想</p><ul><li><strong>化整为零，分区回收</strong>：G1 不再坚持物理上连续的新生代、老年代划分。 它将整个Java堆划分为多个大小相等的独立区域（<strong>Region</strong>，默认约2048个，每个Region大小1MB~32MB）不同区域可同时回收,并发性更高。</li><li><strong>垃圾优先</strong>：其名称即其策略。G1 会持续跟踪每个 Region 中垃圾的“价值”（即回收所能释放的空间大小以及回收所需的时间），并<strong>优先回收那些垃圾最多、回收收益最大的 Region</strong>。这就像清洁工总是先清理最脏、最容易清理的房间。</li><li><strong>可预测的停顿时间模型</strong>：这是 G1 的核心目标。用户可以通过参数 <code>-XX:MaxGCPauseMillis</code>（默认200ms）设置一个期望的最大停顿时间目标。G1 会尽力在这个目标范围内完成垃圾回收，避免出现一次非常长的停顿（这也是 CMS 的痛点）</li></ul><h4 id="4-4-8-2-Region概念"><a href="#4-4-8-2-Region概念" class="headerlink" title="4.4.8.2. Region概念"></a>4.4.8.2. Region概念</h4><p>G1 不再坚持物理上连续的新生代、老年代划分。 它将整个Java堆划分为多个大小相等的独立区域（<strong>Region</strong>，默认约2048个，每个Region大小1MB~32MB）不同区域可同时回收,并发性更高</p><p>G1 的对象管理</p><table><thead><tr><th>区域名称</th><th>存放对象</th><th>颜色体现</th></tr></thead><tbody><tr><td><strong>Eden Regions</strong></td><td>用于分配新对象</td><td>红色部分</td></tr><tr><td><strong>Survivor Regions</strong></td><td>存放 Minor GC 后存活的对象</td><td>红色标记为s</td></tr><tr><td><strong>Old Regions</strong></td><td>存放经历多次 GC 后依然存活的对象（晋升对象）</td><td>淡蓝色</td></tr><tr><td>Humongous Regions</td><td>如果一个对象的大小超过了 <strong>Region 容量的一半</strong>它就会被认为是一个巨型对象，并被直接分配在一组<strong>连续的 Humongous Regions</strong></td><td>带有H字样</td></tr></tbody></table><h4 id="4-4-8-3-卡表和记忆集（解决跨代引用）"><a href="#4-4-8-3-卡表和记忆集（解决跨代引用）" class="headerlink" title="4.4.8.3  卡表和记忆集（解决跨代引用）"></a>4.4.8.3  卡表和记忆集（解决跨代引用）</h4><p>G1 是分区（Region）管理的收集器，堆被划分成很多 Region。</p><p>在回收某些 Region（比如年轻代 Region）的时候，<strong>需要知道哪些对象有跨 Region 的引用</strong>。</p><ul><li>否则就得全堆扫描，代价太大。</li></ul><p>所以就引入了 <strong>Remembered Set</strong> 来记录“外部 Region 指向本 Region 的引用”。而记录这些引用的基础设施就是 <strong>Card Table</strong>（实现记忆集）</p><p><img src="/./../img/image-20251102111930761.png" alt="image-20251102111930761"></p><p>Remember Set 不是直接记录对象地址，而是记录对象所在的 Card 编号。</p><p>所谓 Card 就是表示一小块（512 字节）的内存空间，这里面很可能存在不止一个对象   </p><p>当我们需要确定当前 Region 有哪些对象存在外部引用时（这些对象是可达的，不能被回收），只要扫描一下这块 Card 中的所有对象即可     </p><p>实现上，Remember Set 的实现就是一个 Card 的 Hash Set，并且为每个 GC 线程都有一个本地的 Hash Set，最后的 Remember Set 实际上是这些 Hash Set 的并集</p><p>Card Table 的作用</p><h3 id="卡表如何工作？"><a href="#卡表如何工作？" class="headerlink" title="卡表如何工作？"></a>卡表如何工作？</h3><ol><li><p>对象写入时</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">obj.field</span> = newObj<br></code></pre></td></tr></table></figure><ul><li>如果 <code>obj</code> 在老年代，<code>newObj</code> 在年轻代 → <strong>触发卡表标记</strong>。</li><li>GC更新卡表：<code>card_table[card_index] = 1</code>（标记该卡片为”脏”）。</li></ul></li></ol><p>​当某个对象字段被写入时（JVM 的 <strong>写屏障</strong>）G1 的 Write Barrier 实际上只是一个“通知”，会把对应 Card 标记为  <strong>dirty（脏卡片）</strong>。这样就能快速知道：哪些内存区域（Card）（一大块的内存空间）里可能有新的跨 Region 引用</p><p>Remembered Set 的作用</p><p>​G1 给每个 Region 建立一个 <strong>Remembered Set</strong>。</p><p>​这个集合记录了 <strong>哪些 Card 里包含指向该 Region 的引用</strong>。</p><p>​在回收某个 Region 时，就只需要遍历它的 Remembered Set，找到这些跨区引用，而不用全堆扫描</p><p><font color = "red">关于写屏障的说明 写屏障是JVM在对象引用赋值时插入的一小段“钩子”代码，它像哨兵一样监视着所有对象引用关系的变化，并为并发垃圾收集器（如G1）提供关键信息，以确保标记的正确性</font><strong>检查是否跨Region（oldObj在老年代，youngObj在年轻代）</strong></p><h3 id="话术"><a href="#话术" class="headerlink" title="话术"></a>话术</h3><p><strong>Remembered Set</strong> 来记录“外部 Region 指向本 Region 的引用”。这些引用的基础设施就是 <strong>Card Table</strong></p><p>Remember Set 不是直接记录对象地址，而是记录对象所在的 Card 编号。</p><p>Card Table 的作用（将堆划分为512字节的卡片，用字节标记是否被修改）</p><p>​当某个对象字段被写入时（JVM 的 <strong>写屏障</strong>）G1 的 Write Barrier 实际上只是一个“通知”，会把对应 Card 标记为  <strong>dirty（脏卡片）</strong>。这样就能快速知道：哪些内存区域（Card）（一大块的内存空间）里可能有新的跨 Region 引用</p><p><strong>GC准备阶段</strong>：</p><ul><li>G1扫描卡表，找出<strong>所有被标记为脏的卡片</strong>。</li><li>将这些卡片对应的<strong>引用</strong>添加到目标区域的记忆集中。</li></ul><p>Remembered Set 的作用</p><p>​G1 给每个 Region 建立一个 <strong>Remembered Set</strong>。</p><p>​这个集合记录了 <strong>哪些 Card 里包含指向该 Region 的引用</strong>。</p><p>​在回收某个 Region 时，就只需要遍历它的 Remembered Set，找到这些跨区引用，而不用全堆扫描</p><h4 id="4-4-8-4-G1回收周期"><a href="#4-4-8-4-G1回收周期" class="headerlink" title="4.4.8.4 G1回收周期"></a>4.4.8.4 G1回收周期</h4><p>G1中标记-复制算法 即新生区用复制算法 养老区用标记压缩算法</p><p><img src="/./../img/image-20251102115634782.png" alt="image-20251102115634782"></p><p>G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。</p><p><strong>标记阶段停顿分析</strong></p><ul><li>初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。</li><li>并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。</li><li>再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。</li></ul><p><strong>清理阶段停顿分析</strong></p><ul><li>清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。</li></ul><p><strong>复制阶段停顿分析</strong></p><ul><li>复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。</li></ul><p>四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。为什么转移阶段不能和标记阶段一样并发执行呢？主要是G1未能解决转移过程中准确定位对象地址的问题。</p><h4 id="4-4-8-5-并发标记之三色标记法"><a href="#4-4-8-5-并发标记之三色标记法" class="headerlink" title="4.4.8.5 并发标记之三色标记法"></a>4.4.8.5 并发标记之三色标记法</h4><p>在 G1 里，<strong>三色标记法</strong>是并发标记阶段用来 <strong>判断对象存活性</strong> 的核心算法</p><table><thead><tr><th><strong>白色 (White)</strong></th><th><strong>未被垃圾收集器访问到的对象。</strong></th><th><strong>可达性未知的对象。</strong> 在标记开始时，所有对象都是白色。随着标记进行，仍然为白色的对象就是<strong>不可达</strong>的，即垃圾。</th><th><strong>被回收（Reclaimed）</strong></th></tr></thead><tbody><tr><td><strong>灰色 (Grey)</strong></td><td><strong>对象本身已被垃圾收集器访问到（标记为存活），但它的所有字段引用到的对象还没有被检查。</strong></td><td><strong>待扫描的对象。</strong> 灰色对象是标记过程的“前沿”，它意味着标记还未完成，后面还有工作要做。灰色对象是<strong>存活</strong>的。</td><td><strong>存活（Survived）</strong>，最终会变为黑色。</td></tr><tr><td><strong>黑色 (Black)</strong></td><td><strong>对象本身已被垃圾收集器访问到，并且它的所有字段引用到的对象也都被检查过了。</strong></td><td><strong>已扫描完成的对象。</strong> 黑色对象是<strong>确定存活的</strong>，并且不会再被重新检查（除非发生特殊情况）。</td><td><strong>存活（Survived）</strong></td></tr></tbody></table><p>示意图如下:</p><p><img src="/./../img/image-20251102135347365.png" alt="image-20251102135347365"></p><p>三色标记的过程如下：</p><ol><li>初始阶段，所有对象都是白色。</li><li>将 GC Roots 直接引用的对象标记为灰色。</li><li>处理灰色对象，把当前灰色对象引用的所有对象都变成灰色，之后将当前灰色对象变成黑色。</li><li>重复步骤 3，直到不存在灰色对象为止。</li></ol><p>三色标记结束后，白色对象就是没有被引用的对象（比如上图中的 H  和 G），可以被回收了。</p><p>上面的过程是串行的、STW的。但G1的标记是<strong>并发</strong>的（标记线程与应用线程同时运行），这会导致一个问题：<strong>在标记过程中，应用线程可能改变了对象间的引用关系</strong>。</p><p>主要会产生两种问题：</p><ol><li><strong>把已标记的对象误标为垃圾（漏标）</strong>：一个白色对象，在并发过程中被一个黑色对象重新引用了。因为黑色对象不会再被扫描，这个白色对象就会被错误地当作垃圾清理掉。这是<strong>严重错误</strong>，必须解决。</li><li><strong>把已经不存活的对象误标为存活（多标）</strong>：一个对象被解除了引用，但因为它已经被扫描过（变黑了），所以不会被回收。这会产生一些“浮动垃圾”，<strong>可以接受</strong>，下次GC清理即可。</li></ol><p>G1 使用 <strong>SATB（Snapshot-At-The-Beginning）</strong> 写屏障技术来解决<strong>漏标问题</strong></p><p><strong>SATB 原理：</strong></p><ul><li>在标记开始时，G1 会为堆内存创建一个逻辑上的“快照”。</li><li>每当应用线程要<strong>断开</strong>一个对象的引用时（例如：<code>obj.field = null</code> 或 <code>obj.field = new_value</code>），写屏障会被触发。</li><li>这个写屏障会将被覆盖的旧引用值（即将被断开连接的那个对象）记录下来，并将其<strong>压入一个特殊的队列</strong>。</li><li>在后续的 <strong>Remark 阶段</strong>，G1 会再次STW，然后重新扫描这个队列里的所有对象。如果这个对象是白色的，它就会被强制标记为灰色（或黑色），从而在本轮收集中得以存活。</li></ul><p><strong>SATB 保证：只要在标记开始时是存活的对象，就会被视为存活，即使并发过程中引用被断开</strong></p><h4 id="4-4-8-6-G1-的-GC-模式"><a href="#4-4-8-6-G1-的-GC-模式" class="headerlink" title="4.4.8.6 G1 的 GC 模式"></a>4.4.8.6 G1 的 GC 模式</h4><p>GC 模式指的是 <strong>在什么情况下触发 GC，以及 GC 的目标是什么</strong></p><table><thead><tr><th align="left">GC 模式</th><th align="left">触发条件</th><th align="left">收集范围</th><th align="left">目标</th><th align="left">特点</th></tr></thead><tbody><tr><td align="left"><strong>Young GC</strong></td><td align="left">Eden 区满</td><td align="left">年轻代</td><td align="left">快速回收年轻代</td><td align="left"><strong>频繁</strong>，STW 时间<strong>短</strong></td></tr><tr><td align="left"><strong>Mixed GC</strong></td><td align="left">并发标记完成</td><td align="left">年轻代 + <strong>部分老年代</strong></td><td align="left">高效释放老年代内存</td><td align="left"><strong>阶段性</strong>，STW 时间<strong>可控</strong></td></tr><tr><td align="left"><strong>Full GC</strong></td><td align="left">回收失败</td><td align="left"><strong>整个堆</strong></td><td align="left">补救措施，避免 OOM</td><td align="left"><strong>应避免</strong>，STW 时间<strong>非常长</strong></td></tr></tbody></table><p>调优建议: G1 的调优核心是 <strong>为 Mixed GC 创造有利条件</strong>，即通过合理设置 <code>-XX:InitiatingHeapOccupancyPercent</code>、调整堆大小、优化对象创建速度等手段，确保并发标记周期能及时启动并在老年代填满之前完成，让 Mixed GC 有足够的时间来回收内存，从而彻底避免 Full GC 的发生</p><h4 id="4-4-8-6-G1的使用场景"><a href="#4-4-8-6-G1的使用场景" class="headerlink" title="4.4.8.6 G1的使用场景"></a>4.4.8.6 G1的使用场景</h4><p> 判断是否需要使用G1，它的目标是为拥有以下特征的应用在运行时达到<strong>最短的延迟</strong>和<strong>更高吞吐量</strong>平衡点 :</p><ul><li><p>**(1). 超过8GB的大堆内存，**并且堆中有一半以上的存活数据，对大堆内存空间的性能出色；</p><ul><li>大堆和多核心cpu；</li><li>因为是分区region选择扫描，可以避免扫描大堆空间，减少停顿时间；</li></ul></li><li><p><strong>(2). 对象的分配和晋升速率随着时间变化非常快；</strong></p><ul><li>还是避免扫描大堆空间；region扫描，而不是整个堆空间，性能高，时间可控；</li></ul></li><li><p><strong>(3). 堆内存在大量的内存碎片的情况</strong>；</p></li><li><p>**(4). 需要可预测的gc停顿时间，**希望gc时长不会超过几百毫秒，避免长时间的gc停顿；</p></li><li><p>要求可控的停顿时间和吞吐量，一般设置gc时间在300-500ms范围；</p></li></ul><h3 id="4-4-9-ZGC"><a href="#4-4-9-ZGC" class="headerlink" title="4.4.9. ZGC"></a>4.4.9. ZGC</h3><h4 id="4-4-9-1-简介"><a href="#4-4-9-1-简介" class="headerlink" title="4.4.9.1 简介"></a>4.4.9.1 简介</h4><p><a href="https://wiki.openjdk.org/display/zgc/Main">https://wiki.openjdk.org/display/zgc/Main</a></p><p>The Z Garbage Collector是JDK 11中推出的一款低延迟垃圾回收器，并在 JDK 15 中被宣布为<strong>可用于生产环境</strong>       </p><p>ZGC 本质上是一个<strong>并发</strong>垃圾收集器，这意味着所有繁重的工作都是在 <strong>Java 线程继续执行</strong>时完成的</p><h4 id="4-4-9-2-Region"><a href="#4-4-9-2-Region" class="headerlink" title="4.4.9.2  Region"></a>4.4.9.2  Region</h4><p>跟 G1 类似，ZGC 的堆内存也是基于 Region 来分布，不过 ZGC 是不区分新生代老年代的，ZGC 的 Region 支持动态地创建和销毁，并且 Region 的大小不是固定的，包括三种类型的 Region ：</p><ul><li>Small Region：2MB，主要用于放置小于 256 KB 的小对象。</li><li>Medium Region：32MB，主要用于放置大于等于 256 KB 小于 4 MB 的对象。</li><li>Large Region：N * 2MB。这个类型的 Region 是可以动态变化的，不过必须是 2MB 的整数倍，最小支持 4 MB。每个 Large Region 只放置一个大对象，并且是不会被重分配的。</li></ul><h4 id="4-4-9-3-内存多重映射"><a href="#4-4-9-3-内存多重映射" class="headerlink" title="4.4.9.3  内存多重映射"></a>4.4.9.3  内存多重映射</h4><p><strong>大白话解释：</strong></p><blockquote><p><strong>就像给同一套房子的不同房间挂了不同的门牌号，但实际都是同一套房子。</strong></p></blockquote><p><strong>详细说明：</strong></p><ul><li>ZGC 把<strong>同一块物理内存</strong>同时映射到虚拟内存的<strong>三个不同地址区域</strong></li><li>这三个地址区域分别代表对象的：当前地址、转移中地址、已转移地址</li><li>好处：对象在内存中搬家时，不需要立即更新所有指向它的指针，因为通过任何一个”门牌号”都能找到它</li></ul><p><strong>图例</strong></p><p><img src="/./../img/image-20251105211838043.png" alt="image-20251105211838043"></p><p>把同一块儿物理内存映射为 Marked0、Marked1 和 Remapped 三个虚拟内存</p><p>当应用程序创建对象时，会在堆上申请一个虚拟地址，这时 ZGC 会为这个对象在 Marked0、Marked1 和 Remapped 这三个视图空间分别申请一个虚拟地址，这三个虚拟地址映射到同一个物理地址</p><p>Marked0、Marked1 和 Remapped 这三个虚拟内存作为 ZGC 的三个视图空间，在同一个时间点内只能有一个有效。ZGC 就是通过这三个视图空间的切换，来完成并发的垃圾回收</p><p><strong>举例：</strong><br>你的对象住在”北京路100号”，ZGC要给它搬家到”上海路200号”。普通GC需要通知所有认识这个对象的人：”我搬家了，新地址是上海路200号”。而ZGC同时保留两个地址都能找到这个对象，等有空的时候再慢慢通知大家。</p><table><thead><tr><th>Mk0</th><th>初始映射空间（原始对象所在的虚拟页）</th><th>GC 周期开始时，所有对象都在 Mk0</th><th>GC 复制开始前，对象在 Mk0 区访问</th></tr></thead><tbody><tr><td>Mk1</td><td>新映射空间（复制目标区）</td><td>在 GC 复制（Relocation）阶段使用</td><td>GC 把对象从 Mk0 复制到 Mk1，对象新地址在 Mk1</td></tr><tr><td>Remapped</td><td>重映射空间，用于访问已被移动对象</td><td>GC 复制完成后</td><td>当逻辑地址仍指向旧位置（Mk0），但对象已被复制时 对象依然存活，访问会跳转到 Mk1 的对应地址</td></tr></tbody></table><p><strong>Mk0</strong>：对象当前物理位置（旧的）。</p><p><strong>Mk1</strong>：对象新复制的物理位置（新的）。</p><p><strong>Remapped</strong>：用于访问对象的最终逻辑映射（自动跳转到正确位置）。</p><h4 id="4-4-9-4-染色指针技术"><a href="#4-4-9-4-染色指针技术" class="headerlink" title="4.4.9.4  染色指针技术"></a>4.4.9.4  染色指针技术</h4><p><strong>大白话解释：</strong></p><blockquote><p><strong>就像在快递单号上直接用颜色标记包裹状态，而不是另外建个表格记录。</strong></p></blockquote><p><strong>详细说明：</strong></p><ul><li><p>传统GC： GC 信息保存在对象头的 Mark Word 中。比如 64 位的 JVM，对象头的 Mark Word 中保存的信息如图</p><p>前 62位保存了 GC 信息，最后两位保存了锁标志。</p></li></ul><p><img src="/./../img/image-20251105214621445.png" alt="image-20251105214621445"></p><ul><li>ZGC：直接<strong>在指针的64位地址中拿出4位来标记状态</strong>（就像在地址上”涂颜色”）将 GC 信息保存在了染色指针上。<strong>染色指针是一种将少量信息直接存储在指针上的技术</strong>。在 64 位 JVM  中，对象指针是 64 位，如下图</li></ul><p>在这个 64 位的指针上，高 16 位都是 0，暂时不用来寻址。剩下的 48 位支持的内存可以达到 256 TB（2 ^48）,这可以满足多数大型服务器的需要了。不过 ZGC 并没有把 48 位都用来保存对象信息，而是用高 4 位保存了四个标志位，这样 ZGC 可以管理的最大内存可以达到 16 TB（2 ^ 44）</p><p>通过这四个标志位，JVM 可以从指针上直接看到对象的三色标记状态（Marked0、Marked1）、是否进入了重分配集（Remapped）、是否需要通过 finalize 方法来访问到（Finalizable）。</p><p>无需进行对象访问就可以获得 GC 信息，这大大提高了 GC 效率</p><p><img src="/./../img/image-20251105215457649.png" alt="image-20251105215457649"></p><ul><li>这4位可以表示：是否标记、是否已重定位等状态</li></ul><p><strong>举例：</strong><br>普通快递：包裹编号”12345”，状态”已发货”需要查系统才知道。<br>ZGC快递：包裹编号直接写成”🚚12345”，一看就知道在运输中。不用查系统，看编号颜色就知道状态。</p><p>染色指针技术和内存多重映射关系</p><p>在 64 位地址空间下，ZGC 使用指针的高位来编码颜色信息（比如 Remapped 标志位），再通过地址映射表将逻辑地址映射到正确的物理内存页</p><h4 id="4-4-9-5-读屏障"><a href="#4-4-9-5-读屏障" class="headerlink" title="4.4.9.5  读屏障"></a>4.4.9.5  读屏障</h4><p><strong>大白话解释：</strong></p><blockquote><p><strong>就像图书馆管理员，在你借书时检查这本书是不是正在被重新整理上架。</strong></p><p>读屏障会对应用程序的性能有一定影响，据测试，对性能的最高影响达到 4%，但提高了 GC 并发能力，降低了 STW。</p></blockquote><p><strong>详细说明：</strong></p><ul><li>读屏障是<strong>一小段检查代码</strong>，在程序每次读取对象引用时自动执行</li><li>主要检查：这个指针的”颜色”（状态标记）是否正常</li><li>如果发现对象正在被移动，就等待移动完成或者帮忙完成移动</li></ul><p><strong>举例：</strong><br>你去图书馆借《三国演义》，管理员（读屏障）发现这本书正在从”历史区”搬到”文学区”。他会：</p><ol><li>要么告诉你：”稍等，书正在搬，搬完再借”</li><li>要么直接帮你把书从搬运车上拿下来给你</li></ol><h4 id="4-4-9-6-ZGC回收周期"><a href="#4-4-9-6-ZGC回收周期" class="headerlink" title="4.4.9.6  ZGC回收周期"></a>4.4.9.6  ZGC回收周期</h4><p><img src="/./../img/image-20251105231648198.png" alt="image-20251105231648198"></p><ul><li><strong>初始化</strong>：ZGC初始化之后，整个内存空间的地址视图被设置为Remapped。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。</li><li><strong>并发标记阶段</strong>：第一次进入标记阶段时视图为Mark0，如果对象被GC标记线程或者应用线程访问过，那么就将对象的地址视图从Remapped调整为Mark0。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如果对象的地址是Mark0视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。</li><li><strong>并发转移阶段</strong>：标记结束后就进入转移阶段，此时地址视图再次被设置为Remapped。如果对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped。</li></ul><p>ZGC只有三个STW阶段：<strong>初始标记</strong>，<strong>再标记</strong>，<strong>初始转移</strong>。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。</p><h4 id="4-4-9-7-ZGC存在的问题"><a href="#4-4-9-7-ZGC存在的问题" class="headerlink" title="4.4.9.7 ZGC存在的问题"></a>4.4.9.7 ZGC存在的问题</h4><p>ZGC最大的问题是浮动垃圾。</p><p>浮动垃圾</p><p>ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。</p><p>JDK21以及之前，ZGC没有分代概念，每次都需要进行全堆扫描，导致一些“朝生夕死”的对象没能及时的被回收。</p><p><strong>解决方案</strong></p><p>目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。</p><h3 id="4-4-10-垃圾回收器比较"><a href="#4-4-10-垃圾回收器比较" class="headerlink" title="4.4.10. 垃圾回收器比较"></a>4.4.10. 垃圾回收器比较</h3><p><img src="/./../img/image-20251106080951548.png" alt="image-20251106080951548"></p><p>如果两个收集器之间存在连线，则说明它们可以搭配使用。虚拟机所处的区域则表示它是属于新生代还是老年代收集器。</p><p>垃圾回收器选择策略 ：</p><p>客户端程序 ： Serial + Serial Old；</p><p>吞吐率优先的服务端程序（比如：计算密集型） ： Parallel Scavenge + Parallel Old；</p><p>响应时间优先的服务端程序 ：ParNew + CMS   G1。</p><p>G1收集器是基于标记整理算法实现的，不会产生空间碎片，可以精确地控制停顿，将堆划分为多个大小固定的独立区域，并跟踪这些区域的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域（Garbage First）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11堆</title>
    <link href="/2025/11/14/11%E5%A0%86/"/>
    <url>/2025/11/14/11%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p><strong>堆、栈、方法区的关系：</strong></p><p><img src="/./../img/pqmd75qtz-_a66lc6uWYi-1763121941242-1.png"></p><p><strong>HotSpot</strong>是使用指针的方式来访问对象：</p><p>Java堆中会存放指向<code>类元数据</code>的地址</p><h3 id="五、三者的对比分析"><a href="#五、三者的对比分析" class="headerlink" title="五、三者的对比分析"></a>五、三者的对比分析</h3><h3 id="三、堆与栈的核心区别"><a href="#三、堆与栈的核心区别" class="headerlink" title="三、堆与栈的核心区别"></a>三、堆与栈的核心区别</h3><table><thead><tr><th>维度</th><th>堆（Heap）</th><th>栈（Stack）</th></tr></thead><tbody><tr><td><strong>所属</strong></td><td>所有线程共享</td><td>每个线程私有</td></tr><tr><td><strong>存储内容</strong></td><td>对象实例、数组、成员变量</td><td>局部变量、对象引用、方法参数</td></tr><tr><td><strong>生命周期</strong></td><td>随对象是否被引用动态变化（GC管理）</td><td>随方法调用结束而销毁</td></tr><tr><td><strong>内存管理</strong></td><td>由GC自动回收</td><td>由JVM自动出栈入栈</td></tr><tr><td><strong>访问速度</strong></td><td>较慢（需通过引用定位）</td><td>高速（连续内存，直接操作）</td></tr><tr><td><strong>典型异常</strong></td><td><code>OutOfMemoryError</code>（堆内存不足）</td><td><code>StackOverflowError</code>（栈溢出）</td></tr></tbody></table><h4 id="5-1-核心区别对比表"><a href="#5-1-核心区别对比表" class="headerlink" title="5.1 核心区别对比表"></a>5.1 核心区别对比表</h4><p>为更直观呈现 Heap、Non-Heap 和 Off-Heap 的区别，整理如下对比表：</p><table><thead><tr><th>对比项</th><th>Heap（堆内存）</th><th>Non-Heap（非堆内存）</th><th>Off-Heap（堆外内存）</th></tr></thead><tbody><tr><td>存储内容</td><td>对象实例和数组</td><td>类元数据、JIT 编译代码、线程栈</td><td>大块内存缓存、与本地交互的数据堆外内存不受 JVM 直接管理，由OS负责</td></tr><tr><td>管理方式</td><td>GC 自动管理</td><td>JVM 自行管理（部分有有限 GC）</td><td>手动管理（或依赖 Cleaner 机制）</td></tr><tr><td>常见溢出错误</td><td>OutOfMemoryError: Java heap space</td><td>OutOfMemoryError: MetaspaceOutOfMemoryError: CodeCache is full</td><td>OutOfMemoryError: Direct buffer memory</td></tr><tr><td>调优参数</td><td>-Xms、-Xmx、-XX:NewRatio 等</td><td>-XX:MaxMetaspaceSize、-XX:ReservedCodeCacheSize 等</td><td>-XX:MaxDirectMemorySize</td></tr></tbody></table><h4 id="5-2-使用场景建议"><a href="#5-2-使用场景建议" class="headerlink" title="5.2 使用场景建议"></a>5.2 使用场景建议</h4><ul><li><strong>优先使用 Heap</strong>：对于常规 Java 对象，如业务实体类；生命周期短的临时对象；频繁创建和销毁的数据，堆内存是理想选择，GC 自动管理能减少开发者负担。</li><li><strong>考虑 Non-Heap</strong>：涉及类元信息（如动态代理生成的类、反射加载的类）、JIT 编译后的代码、线程栈相关场景时，与非堆内存相关。通常无需过多干预，出现内存溢出问题时再针对性处理。</li><li><strong>谨慎使用 Off-Heap</strong>：在高性能场景，如 Netty 网络框架为提升 I&#x2F;O 性能；需要与本地代码交互；希望避免 GC 对性能影响的场景下，可使用堆外内存，但务必注意手动管理内存，防止内存泄漏</li></ul><h1 id="堆空间概述"><a href="#堆空间概述" class="headerlink" title="堆空间概述"></a>堆空间概述</h1><p>Java栈中的引用存储的是指向堆中的对象的地址</p><ul><li><p>一个Java程序运行起来对应一个进程，一个进程对应一个JVM实例，一个JVM实例中有一个运行时数据区，一个运行时数据区中只存在一个堆内存和一个方法区。</p></li><li><p>一个进程中可以包含多个线程，因此堆内存和方法区是线程共享的。堆中还有一小部分空间，是每个线程独有的，叫做线程私有缓冲区（Thread Local Allocation Buffer，TLAB），解决程序运行时的数据安全问题。</p></li><li><p>一个线程各自拥有一套Java栈、本地方法栈和程序计数器。</p></li><li><p>一个进程拥有自己一套jvm； </p><ul><li>user-service.jar</li><li>hispital-service.jar</li><li>。。。。</li><li><code>java -jar xxx.jar</code>： 启动一个进程。 一个进程分配很多线程。</li></ul></li><li><p>堆是Java内存管理的<strong>核心区域</strong>，在<code>JVM启动的时候被创建</code>，堆内存的大小是可以调节的。当创建一个引用类型的对象时，JVM会为对象在堆中分配一个内存空间。堆是垃<code>圾回收的重点区域</code>。</p></li><li><p>口诀：</p><ul><li>频繁收集年轻代，少量收集老年代，基本不动永久代（方法区）</li></ul></li></ul><h2 id="堆和对象"><a href="#堆和对象" class="headerlink" title="堆和对象"></a>堆和对象</h2><p>以前，Java 中“几乎”所有的对象都会在堆中分配，但随着 <a href="https://javabetter.cn/jvm/jit.html">JIT</a> 编译器的发展和逃逸技术的逐渐成熟，所有的对象都分配到堆上渐渐变得不那么“绝对”了。从 JDK 7 开始，Java 虚拟机已经默认开启逃逸分析了，</p><p><strong>意味着如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p><p><img src="/./../img/neicun-jiegou-20231225154450.png" alt="img"></p><p>栈就是前面提到的 JVM 栈（主要存储局部变量、方法参数、对象引用等），属于线程私有，通常随着方法调用的结束而消失，也就无需进行垃圾收集；堆前面也讲了，属于线程共享的内存区域，几乎所有的对象都在对上分配，生命周期不由单个方法调用所决定，可以在方法调用结束后继续存在，直到不在被任何变量引用，然后被垃圾收集器回收。</p><p>简单解释一下 JIT 和逃逸分析（后面讲 <a href="https://javabetter.cn/jvm/jit.html">JIT</a> 会细讲）。</p><p>常见的编译型语言如 C++，通常会把代码直接编译成 CPU 所能理解的机器码来运行。而 Java 为了实现“一次编译，处处运行”的特性，把编译的过程分成两部分，首先它会先由 javac 编译成通用的中间形式——字节码，然后再由解释器逐条将字节码解释为机器码来执行。所以在性能上，Java 可能会干不过 C++ 这类编译型语言。</p><p><img src="/./../img/what-is-jvm-20231223155202.png" alt="img"></p><p>为了优化 Java 的性能 ，JVM 在解释器之外引入了 JIT 编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。</p><p>逃逸分析（Escape Analysis）是一种编译器优化技术，用于判断对象的作用域和生命周期。</p><h5 id="如果编译器确定一个对象不会逃逸出方法或线程的范围，它可以选择在栈上分配这个对象，而不是在堆上。这样做可以减少垃圾回收的压力，并提高性能。"><a href="#如果编译器确定一个对象不会逃逸出方法或线程的范围，它可以选择在栈上分配这个对象，而不是在堆上。这样做可以减少垃圾回收的压力，并提高性能。" class="headerlink" title="如果编译器确定一个对象不会逃逸出方法或线程的范围，它可以选择在栈上分配这个对象，而不是在堆上。这样做可以减少垃圾回收的压力，并提高性能。"></a><strong>如果编译器确定一个对象不会逃逸出方法或线程的范围，它可以选择在栈上分配这个对象，而不是在堆上。这样做可以减少垃圾回收的压力，并提高性能。</strong></h5><h1 id="元空间和方法区"><a href="#元空间和方法区" class="headerlink" title="元空间和方法区"></a>元空间和方法区</h1><p>方法区是 Java 虚拟机规范上的一个逻辑区域，在不同的 JDK 版本上有着不同的实现。在 JDK 7 的时候，方法区被称为永久代（PermGen），而在 JDK 8 的时候，永久代被彻底移除，取而代之的是元空间。</p><p><img src="/./../img/neicun-jiegou-20240110195211.png" alt="img"></p><p>JDK 7 之前，只有常量池的概念，都在方法区中。</p><p>JDK 7 的时候，字符串常量池从方法区中拿出来放到了堆中，运行时常量池还在方法区中（也就是永久代中）。</p><p>JDK 8 的时候，HotSpot 移除了永久代，取而代之的是元空间。字符串常量池还在堆中，而运行时常量池跑到了元空间。</p><p>元空间的大小不再受限于 JVM 启动时设置的最大堆大小，而是直接利用本地内存，也就是操作系统的内存。有效地解决了 OutOfMemoryError 错误。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>在讲字节码的时候，我们详细的讲过常量池，它是字节码文件的资源仓库，先是一个常量池大小，从 1 到 n-1，0 为保留索引，然后是常量池项的集合，包括类信息、字段信息、方法信息、接口信息、字符串常量等。</p><p>运行时常量池，顾名思义，就是在运行时期间，JVM 会将字节码文件中的常量池加载到内存中，存放在运行时常量池中。</p><p>也就是说，常量池是在字节码文件中，而运行时常量池在元空间当中（JDK 8 及以后），讲的是一个东西，但形态不一样，就好像一个是固态，一个是液态；或者一个是模子，一个是模子里的锅碗瓢盆。</p><p><strong>字符串常量池</strong>：</p><ul><li>在JDK 7及之后的版本中，字符串常量池被移动到了<strong>堆内存</strong>中（Heap）</li><li>JDK 7之前，字符串常量池位于永久代（PermGen）</li></ul><p><strong>运行时常量池</strong>：</p><ul><li>运行时常量池属于<strong>方法区</strong>（Method Area）</li><li>在JDK 8及之后，方法区由<strong>元空间</strong>（Metaspace）实现</li><li>元空间使用的是<strong>本地内存</strong>（直接从操作系统申请），而不是堆内存</li></ul><p>具体来说：</p><ul><li>JDK 7：字符串常量池移到堆中，运行时常量池仍在方法区（永久代）</li><li>JDK 8及之后：永久代被彻底移除，改用元空间（Metaspace）作为方法区的实现，运行时常量池在元空间中，而字符串常量池仍在堆中</li></ul><p>所以，当前（JDK 8+）环境下，字符串常量池确实在堆里面，而运行时常量池在方法区（具体实现为元空间，使用本地内存，不是堆内存）。</p><p>这是JDK 7版本的重要改进，将字符串常量池从永久代移到堆中，是为了让字符串常量池能更好地参与垃圾回收，避免永久代内存不足导致的OOM问题。</p><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>字符串常量池我们在讲字符串的时候已经详细讲过了，它的作用是存放字符串常量，也就是我们在代码中写的字符串。依然在堆中。</p><p>OK，方法区（不管是永久代还是元空间的实现）和堆一样，是线程共享的区域。</p><h1 id="运行时数据区的主要组成"><a href="#运行时数据区的主要组成" class="headerlink" title="运行时数据区的主要组成"></a>运行时数据区的主要组成</h1><p>来总结一下运行时数据区的主要组成：</p><p>PC 寄存器（PC Register），也叫程序计数器（Program Counter Register），是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器。</p><p>JVM 栈（Java Virtual Machine Stack），与 PC 寄存器一样，JVM 栈也是线程私有的。每一个 JVM 线程都有自己的 JVM 栈（也叫方法栈），这个栈与线程同时创建，它的生命周期与线程相同。</p><p>本地方法栈（Native Method Stack），JVM 可能会使用到传统的栈来支持 Native 方法的执行，这个栈就是本地方法栈。</p><p>堆（Heap），在 JVM 中，堆是可供各条线程共享的运行时内存区域，也是供所有类实例和数据对象分配内存的区域。</p><p>方法区（Method area），JDK 8 开始，使用元空间取代了永久代。方法区是 JVM 中的一个逻辑区域，用于存储类的结构信息，包括类的定义、方法的定义、字段的定义以及字节码指令。不同的是，元空间不再是 JVM 内存的一部分，而是通过本地内存（Native Memory）来实现的。</p><p>在 JVM 启动时，元空间的大小由 MaxMetaspaceSize 参数指定，JVM 在运行时会自动调整元空间的大小，以适应不同的程序需求。</p><h1 id="堆的分代"><a href="#堆的分代" class="headerlink" title="堆的分代"></a>堆的分代</h1><p><img src="/./../img/image-20251114202938085.png" alt="image-20251114202938085"></p><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p><strong>内存结构：</strong></p><ul><li><p>新生代又分为两部分： <code>伊甸园区（Eden space）和幸存者区（Survivor pace）</code> 。</p></li><li><p>幸存者区有两个： <code>0区（Survivor 0 space）和1区（Survivor 1 space）</code>。</p></li></ul><p><strong>工作过程：</strong></p><p>（1）新创建的对象先放在伊甸园区。</p><p>（2）当伊甸园的空间用完时，程序又需要创建新对象，此时，触发JVM的垃圾回收器对<code>伊甸园区进行垃圾回收``（Minor GC/Young GC）</code>，将伊甸园区中不再被引用的对象销毁。（GC 伊甸园+某个幸存者区）</p><p>（3）然后将伊甸园区的剩余对象<code>移动到空的幸存0区</code>。</p><p>（4）此时，<code>伊甸园区清空</code>。</p><p>（5）被移到幸存者0区的对象上有一个<code>年龄计数器，值是1</code>。</p><p>（6）然后再次将新对象放入伊甸园区。</p><p>（7）如果伊甸园区的空间再次用完，则<code>再次触发垃圾回收</code>，<code>对伊甸园区和s0区进行垃圾回收</code>，销毁不再引用的对象。</p><p>（8）此时s1区为空，然后将伊甸园区和s0区的剩余对象<code>移动到空的s1区</code>。</p><p>（9）此时，<code>伊甸园区和s0区清空</code>。</p><p>（10）从伊甸园区被移到s1区的对象上有一个<code>年龄计数器，值是1</code>。从s0区被移到s1区的对象上的<code>年龄计数器+1</code>，值是2。</p><p>（11）然后再次将新对象放入伊甸园区。如果<code>再次经历垃圾回收</code>，那么伊甸园区和s1区的剩余对象<code>移动到s0区</code>。对象上的年龄计数器+1。</p><p>（12）当对象上的<strong>年龄计数器</strong>达到<strong>15</strong>时（<strong>-XX:MaxTenuringThreshold</strong>），则晋升到老年代。</p><p><strong>总结：</strong> 针对幸存者s0，s1，复制（复制算法）之后有交换，谁空谁是<code>to</code></p><p>每次垃圾回收后，幸存者区都有一个会被清空，此时这个区域称为<code>to区</code>，另一个区域被称为<code>from区</code>，下一次垃圾回收时，<code>伊甸园区和from区对象会被移动到to区</code></p><h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>经历多次<code>Minor GC</code>仍然存在的对象（默认是15次）会被移入老年代，老年代的对象比较稳定，不会频繁的GC。</p><p>若老年代也满了，那么这个时候将产生<code>Major GC（同时触发Full GC）</code>，进行老年代的垃圾回收。</p><p>若老年代执行了Full GC之后发现依然无法进行对象的保存，就会<code>产生OOM异常OutOfMemoryError</code>。</p><h2 id="永久代-元空间"><a href="#永久代-元空间" class="headerlink" title="永久代&#x2F;元空间"></a>永久代&#x2F;元空间</h2><p><strong>JDK1.7</strong></p><ul><li><p><code>-XX:PermSize：</code>设置永久代初始分配空间，默认值是20.75M。</p></li><li><p><code>-XX:MaxPermSize：</code>设置永久代最大可分配空间，32位机器默认值是64M，64位机器默认82M。</p></li></ul><p><strong>JDK1.8</strong></p><ul><li><p><code>-XX:MetaspaceSize：</code>设置元空间初始分配空间，64位系统，默认值是21M。</p></li><li><p><code>-XX:MaxMetaspaceSize：</code>设置元空间最大可分配空间，，默认是-1。</p></li></ul><p>永久代是一个常驻内存区域，用于存放JDK自身所携带的 Class，Interface 的元数据，也就是说它存储的是运行环境必须的类信息，<code>被装载进此区域的数据是不会被垃圾回收器回收掉的</code>，<code>关闭 JVM 才会释放此区域所占用的内存</code>。</p><p>如果出现<code>java.lang.OutOfMemoryError: </code><strong>PermGen space</strong>，说明是Java虚拟机对<code>永久代内存设置不够</code>。一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。</p><p>尽管方法区在逻辑上属于堆的一部分，<strong>对于HotSpotJVM而言，方法区还有一个别名叫做<code>Non-Heap(非堆)</code>，目的就是要和堆分开。</strong></p><p>对<code>于HotSpot虚拟机</code>，很多开发者<code>习惯将方法区称之为永久代</code> ，但严格说两者不同，或者说是使用永久代来实现方法区而已。</p><h2 id="常用命令行（了解）"><a href="#常用命令行（了解）" class="headerlink" title="常用命令行（了解）"></a>常用命令行（了解）</h2><p>查看java进程：<code>jps -l</code></p><p>查看某个java进程所有参数：<code>jinfo 进程号</code></p><p>查看某个java进程总结性垃圾回收统计：<code>jstat -gc 进程号</code></p><h1 id="Java的垃圾回收"><a href="#Java的垃圾回收" class="headerlink" title="Java的垃圾回收"></a>Java的垃圾回收</h1><h2 id="什么是GC"><a href="#什么是GC" class="headerlink" title="什么是GC"></a>什么是GC</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是</p><p>GC： <strong>堆</strong> 内存中对象的分配与回收。</p><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p><h3 id="GC种类"><a href="#GC种类" class="headerlink" title="GC种类"></a>GC种类</h3><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h2 id="GC种类总结："><a href="#GC种类总结：" class="headerlink" title="GC种类总结："></a>GC种类总结：</h2><p><strong>部分收集：</strong></p><ul><li>年轻代收集（Minor GC  &#x2F;  Young GC）：新生代垃圾收集（伊甸园区 + 幸存者区）</li><li>老年代收集（Major GC &#x2F; Old GC）：老年代垃圾收集</li><li>Full GC &#x3D; Minor + Major </li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代。<code>G1垃圾收集器有这种方式</code></li></ul><p><strong>整堆收集（Full GC）：</strong></p><ul><li>整个<code>Java堆</code>和<code>方法区</code>的垃圾收集</li></ul><p><strong>年轻代GC触发机制（Minor GC ）：</strong></p><p>年轻代的Eden空间不足，触发Minor GC。</p><p>每次Minor GC在清理Eden的同时会清理Survivor From区。</p><p><code>Minor GC非常频繁</code>，<code>回收速度块</code>。</p><p>引发<code>STW（Stop The World）</code>，暂停其他用户线程，垃圾回收结束，用户线程恢复。</p><p><strong>老年代GC触发机制（Major GC 和 Full GC）：</strong></p><p>老年代满了，对象从老年代消失是因为发生了Major GC和Full GC。</p><p>Major GC比Minor GC速度慢10倍以上，<strong>STW时间更长</strong>。</p><p>如果Major GC后，内存还不足，就报OOM。</p><p><strong>Full GC触发机制：</strong></p><p>（1）调用System.gc()，系统建议执行Full GC，但是不是必然执行。</p><p>（2）老年代空间不足</p><p>（3）方法区空间不足</p><p>（4）通过Minor GC后进入老年代平均大小大于老年代可用内存</p><ul><li><p>频繁在新生代收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集。</p><table><thead><tr><th align="left">特性</th><th align="center">Minor GC</th><th align="center">Major GC</th><th align="center">Full GC</th></tr></thead><tbody><tr><td align="left"><strong>作用区域</strong></td><td align="center">仅年轻代 (Young Gen)</td><td align="center">仅老年代 (Old Gen)</td><td align="center"><strong>整个堆</strong> (Young + Old + Metaspace)</td></tr><tr><td align="left"><strong>触发频率</strong></td><td align="center"><strong>高</strong></td><td align="center"><strong>低</strong></td><td align="center"><strong>非常低</strong> (应尽量避免)</td></tr><tr><td align="left"><strong>执行速度</strong></td><td align="center"><strong>快</strong></td><td align="center"><strong>慢</strong></td><td align="center"><strong>非常慢</strong></td></tr><tr><td align="left"><strong>STW停顿</strong></td><td align="center">短，通常可忽略</td><td align="center">较长，影响明显</td><td align="center"><strong>很长，严重影响应用</strong></td></tr><tr><td align="left"><strong>触发原因</strong></td><td align="center">Eden区满</td><td align="center">老年代满</td><td align="center">1. 老年代满 2. 元空间满 3. <code>System.gc()</code> 4. 空间分配担保失败</td></tr></tbody></table><p>为什么要“担保”？</p><p>想象一个场景：你要进行Minor GC了。理想情况下，Eden区里大部分对象都是垃圾，被回收掉，只有一小部分存活对象会晋升到老年代。</p><p>但<strong>最坏的情况</strong>是：Eden区里几乎<strong>所有对象都存活</strong>了，这次Minor GC后，存活对象的总大小非常大，需要全部晋升到老年代。</p><p>“空间分配担保”机制就是为了应对这种最坏情况，<strong>确保老年代有足够的能力“兜底”</strong>，接收所有这些可能晋升上来的对象。如果老年代没能力兜底，冒然进行Minor GC就会导致内存不足的错误。</p><p>“允许担保”的含义</p><p><code>-XX:-HandlePromotionFailure</code> 这个参数的名字直译是“<strong>是否处理晋升失败</strong>”。</p><ul><li><strong><code>-XX:+HandlePromotionFailure</code></strong>：<strong>允许</strong>担保（JDK 6 Update 24之后默认即为此状态）。JVM会尝试做担保检查，如果检查失败，就提前进行Full GC来腾空间。</li><li><strong><code>-XX:-HandlePromotionFailure</code></strong>：<strong>不允许</strong>担保。JVM直接不做复杂的检查了，只要老年代剩余空间看起来不太够，就干脆地、安全地先进行一次Full GC。</li></ul><p>这个参数在JDK 6 Update 25之后就<strong>不再有实际作用</strong>了，规则已经固化</p></li></ul><h2 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法"></a>垃圾判断算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>引用计数算法（Reachability Counting）是通过在对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。</p><p>如果该对象被其它对象引用，则它的引用计数加 1，如果删除对该对象的引用，那么它的引用计数就减 1，当该对象的引用计数为 0 时，那么该对象就会被回收。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>可达性分析算法（Reachability Analysis）的基本思路是，通过 GC Roots 作为起点，然后向下搜索，当一个对象到 GC Roots 之间没有任何引用相连时，即从 GC Roots 到该对象节点不可达，则证明该对象是需要垃圾收集的。</p><h3 id="GCROOTS"><a href="#GCROOTS" class="headerlink" title="GCROOTS"></a>GCROOTS</h3><p>所谓的 GC Roots，就是一组必须活跃的引用，不是对象，它们是程序运行时的起点，是一切引用链的源头。在 Java 中，GC Roots 包括以下几种：</p><ul><li>虚拟机栈中的引用（方法的参数、局部变量等）</li><li>本地方法栈中 JNI （本地方法）的引用</li><li>类静态变量</li><li>运行时常量池中的常量（String 或 Class 类型）</li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a><strong>垃圾回收算法</strong></h2><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收。</p><p>在介绍JVM垃圾回收算法前，先介绍一个概念：<strong>Stop-the-World：</strong></p><p>Stop-the-world意味着 JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。</p><p>当Stop-the-world发生时，除了GC所需的线程以外，<code>所有线程都处于等待状态直到GC任务完成</code>。</p><p>事实上，<code>GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有高吞吐 、低停顿的特点。</code></p><h3 id="标记清除（Mark-Sweep）"><a href="#标记清除（Mark-Sweep）" class="headerlink" title="标记清除（Mark-Sweep）"></a>标记清除（Mark-Sweep）</h3><p><code>标记-清除算法</code>是几种GC算法中最基础的算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。正如名字一样，算法分为<strong>2个阶段</strong>：</p><p>（1）<strong>标记：</strong> 使用<code>可达性分析算法</code>，标记出可达对象。</p><p>（2）<strong>清除：</strong> 对堆内存从头到尾进行线性便遍历，如果发现某个对象没有被标记为可达对象，则将其回收。</p><p><img src="/./../img/2knl9vfp81_hoQSSZ5fLP.gif"></p><p><strong>缺点：</strong></p><ul><li><p>效率问题（两次遍历）</p></li><li><p>空间问题（标记清除后会产生大量不连续的<strong>碎片</strong>。JVM就不得不维持一个<code>内存的空闲列表</code>，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。）</p></li></ul><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><p><strong>核心思想：</strong></p><p>将活着的内存空间平均分成<strong>两块</strong>，每次只使用其中<strong>一块</strong>，垃圾收集时，将正在使用的内存中的存活对象复制到未被使用的内存块中，然后将之前的<strong>内存块清空</strong>，交换两个内存的角色，循环下去。</p><p><img src="/./../img/-n83l7j40p_9u1Vtn0PUf.gif"></p><p><strong>优点：</strong></p><ul><li><p><strong>实现简单</strong></p></li><li><p><strong>不产生内存碎片</strong></p></li></ul><p><strong>缺点：</strong></p><ul><li><p>将<strong>内存缩小为原来的一半</strong>，浪费了一半的内存空间，代价太高，所以在老年代一般不能直接选用这种算法。</p></li><li><p>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</p></li></ul><p><strong>年轻代中使用的是Minor GC，这种GC算法采用的就是复制算法：</strong></p><p>HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区。因为年轻代中的对象基本都是<code>朝生夕死的(90%以上)</code>，所以在年轻代的垃圾回收算法使用的是复制算法。</p><h3 id="标记压缩（Mark-Compact）"><a href="#标记压缩（Mark-Compact）" class="headerlink" title="标记压缩（Mark-Compact）"></a>标记压缩（Mark-Compact）</h3><p><strong>也叫标记整理算法。</strong></p><p>标记整理算法<code>是标记-清除法的一个改进版</code>。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是通过<code>所有存活对像都向一端移动，然后直接清除边界以外的内存</code>。</p><p><img src="/./../img/gt802yy-r1_V6nc6kONPH.gif"></p><p><strong>优点：</strong></p><p>标记整理算法不仅可以弥补标记清除算法中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。</p><p><strong>缺点：</strong></p><p>如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低。</p><p><strong>老年代一般是由标记清除或者是标记清除与标记整理的混合实现。</strong></p><p><img src="/./../img/ei8pop8k1q_GLa6wPJHmS.png"></p><p><strong>难道就没有一种最优算法吗？</strong></p><p>回答：无，没有最好的算法，只有最合适的算法。&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<strong>分代收集算法</strong></p><h3 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational-Collection）"></a>分代收集算法（Generational-Collection）</h3><p><strong>执行速度：</strong></p><p>复制算法 &gt; 标记清除算法 &gt; 标记整理算法（此处的效率只是简单的对比<strong>时间复杂度</strong>，实际情况不一定如此）。</p><p><strong>内存利用率：</strong></p><p>标记整理算法&#x3D;标记清除算法&gt;复制算法。</p><blockquote><p>分代收集算法：</p><ul><li>将JVM管理的运行时数据区整片内存划分不同区域，垃圾回收工作在堆区</li><li>堆进行分代管理<ul><li><strong>新生代</strong>：复制（第一优先） + 标记清除 算法； <strong>新生代GC频率高</strong>，所以必须选择<strong>执行速度快</strong>的算法。</li><li><strong>老年代</strong>：标记压缩算法； 老年代GC频率低，都是长期存活的对象，我们就一次性摆好位置。 <code>标记压缩算法</code></li></ul></li></ul></blockquote><p>可以看出，效率上来说，<code>复制算法是当之无愧的老大，但是却浪费了太多内存</code>。</p><p>为了尽量兼顾上面所提到的三个指标，标记整理算法相对来说更平滑一些，但效率上依然不尽如人意。</p><p>比复制算法多了一个标记的阶段，又比标记清除多了一个整理内存的过程</p><p><code>分代回收算法</code>实际上是<code>复制算法和标记整理法的结合</code>，并不是真正一个新的算法。</p><p>一般分为<code>老年代（Old Generation）和年轻代（Young Generation）</code></p><p>老年代就是很少垃圾需要进行回收的，年轻代就是有很多的内存空间需要回收，所以不同代就采用不同的回收算法，以此来达到高效的回收算法。</p><p><strong>年轻代（Young Gen）</strong>（1&#x2F;3，8：1：1）</p><p><code>年轻代特点是区域相对老年代较小，对像存活率低。</code></p><p>这种情况<code>复制算法</code>的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p><p><strong>老年代（Tenure Gen）</strong>（2&#x2F;3）</p><p>老年代占据着 2&#x2F;3 的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。（大对象可能会直接进入老年代）</p><p><code>老年代的特点是区域较大，对像存活率高。</code></p><p>这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是<code>由标记清除或者是标记清除与标记整理的混合实现</code>。</p><h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><p>平时只会用到强引用和软引用。</p><p><strong>强引用：</strong><code>不回收</code></p><p>只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();  <span class="hljs-comment">//User obj = 0x7788;     [0x7788] = new Object();</span><br></code></pre></td></tr></table></figure><p><strong>软引用：</strong><code>内存不足即回收</code></p><p><code>SoftReference</code> 类实现软引用。在系统要发生内存溢出<code>（OOM）</code>之前，才会将这些对象列进回收范围之中<code>进行二次回收</code>。如果这次回收还没有足够的内存，才会抛出内存溢出异常。<code>软引用可用来实现内存敏感的高速缓存</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SoftReference&lt;User&gt; userSoftRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>));<br></code></pre></td></tr></table></figure><p><strong>弱引用：</strong><code>发现即回收</code></p><p><code>WeakReference</code> 类实现弱引用。对象只能生存到下一次垃圾收集<code>（GC）</code>之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">WeakReference&lt;User&gt; userWeakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;tom&quot;</span>));<br></code></pre></td></tr></table></figure><p><strong>虚引用（幽灵引用、幻影引用）：</strong><code>对象回收跟踪</code></p><p><code>PhantomReference</code> 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">phantomQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br>PhantomReference&lt;User&gt; obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;tom&quot;</span>), phantomQueue);<br></code></pre></td></tr></table></figure><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10JVM入门和栈</title>
    <link href="/2025/11/14/10JVM%E5%85%A5%E9%97%A8%E5%92%8C%E6%A0%88/"/>
    <url>/2025/11/14/10JVM%E5%85%A5%E9%97%A8%E5%92%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM入门"><a href="#JVM入门" class="headerlink" title="JVM入门"></a>JVM入门</h1><p>JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现。。。。可以看作是 Java 程序执行的环境，它隐藏了底层操作系统和硬件的复杂性，提供了一个统一、稳定和安全的运行平台。</p><p>JVM 大致可以划分为三个部门，分别是类加载器（Class Loader）、运行时数据区（Runtime Data Areas）和执行引擎（Excution Engine）</p><p>类加载器用来加载类文件，也就是 .class 文件。如果类文件加载失败，也就没有运行时数据区和执行引擎什么事了，它们什么也干不了。类加载器负责将字节码文件加载到内存中，主要会经历加载-&gt;连接-&gt;实例化这三个阶段，我们会放在后面的章节单独来讲。</p><p>运行时数据区就是Java 程序运行期间需要使用到的内存区域，简单来说，这块内存区域存放了字节码信息以及程序执行过程的数据，垃圾收集器也会针对运行时数据区进行对象回收的工作。</p><p>执行引擎的任务就是将<a href="https://javabetter.cn/jvm/zijiema-zhiling.html">字节码指令</a>解释&#x2F;编译为对应平台上的本地机器指令才可以。简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者</p><h1 id="JVM如何运行指令"><a href="#JVM如何运行指令" class="headerlink" title="JVM如何运行指令"></a>JVM如何运行指令</h1><p>Java 代码首先被编译器转换为字节码，然后在 JVM 上运行。在运行时，JVM 通过解释执行或即时编译（JIT）将字节码转换为机器码。解释执行直接运行字节码，而 JIT 在运行时将热点代码编译优化为机器码以提升性能。</p><p>这中间需要运行时数据区来存储字节码数据以及运行时中间数据。</p><p>字节码是 JVM 中非常关键的内容，涉及到类的加载机制、字节码文件的结构、字节码指令的执行流程等等，</p><h1 id="类加载器的介绍"><a href="#类加载器的介绍" class="headerlink" title="类加载器的介绍"></a>类加载器的介绍</h1><p>之前也提到了它是负责加载.class 文件的，它们在文件开头会有特定的文件标示，将 class 文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且 ClassLoader 只负责 class 文件的加载，而是否能够运行则由 Execution Engine 来决定</p><h3 id="创建对象的过程？"><a href="#创建对象的过程？" class="headerlink" title="创建对象的过程？"></a>创建对象的过程？</h3><p><img src="/./../img/1713516384566-e820b967-73ce-49a4-a6e6-36af9a38ebc4.webp" alt="img">在Java中创建对象的过程包括以下几个步骤：</p><ol><li><strong>类加载检查</strong>：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在<strong>常量池</strong>中定位到一个类的<strong>符号引用</strong>，并且检查这个符号引用代表的类是否已被<strong>加载过、解析和初始化</strong>过。如果没有，那必须先执行相应的<strong>类加载过程</strong>。</li><li><strong>分配内存</strong>：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的<strong>内存大小</strong>在<strong>类加载</strong>完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</li><li><strong>初始化零值</strong>：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>进行必要设置，比如对象头</strong>：初始化零值完成之后，虚拟机要对对象进行<strong>必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在<strong>对象头</strong>中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li><li><strong>执行 init 方法</strong>：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始——构造函数，即class文件中的方法还没有执行，所有的字段都还为零，<strong>对象需要的其他资源和状态信息</strong>还没有按照预定的意图构造好。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来。</li></ol><table><thead><tr><th>维度</th><th>类加载</th><th>对象创建</th></tr></thead><tbody><tr><td><strong>本质</strong></td><td>将类的字节码加载到JVM</td><td>生成类的实例（对象）</td></tr><tr><td><strong>发生次数</strong></td><td><strong>只发生一次</strong>（类首次使用）</td><td><strong>每次<code>new</code>都发生</strong></td></tr><tr><td><strong>谁负责</strong></td><td>ClassLoader（JVM内部）</td><td>JVM（执行<code>new</code>指令）</td></tr><tr><td><strong>结果</strong></td><td>生成 <code>Class</code> 对象（类的”蓝图”）</td><td>生成具体对象实例（”房子”）</td></tr><tr><td><strong>依赖关系</strong></td><td><strong>必须先加载类</strong>，才能创建对象</td><td>依赖已加载的类</td></tr><tr><td><strong>错误示例</strong></td><td>类未加载 → <code>ClassNotFoundException</code></td><td>类已加载，但 <code>new</code> 时出错（如构造方法异常）</td></tr></tbody></table><h2 id="2-1-先进行类的加载"><a href="#2-1-先进行类的加载" class="headerlink" title="2.1 先进行类的加载"></a>2.1 先进行类的加载</h2><p>从类被加载到虚拟机内存中开始，到释放内存总共有 7 个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p><h3 id="2-1-1-加载"><a href="#2-1-1-加载" class="headerlink" title="[2.1.1 加载"></a>[2.1.1 加载</h3><ol><li>将 class 文件加载到内存</li><li>将静态数据结构转化成方法区中运行时的数据结构</li><li>在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口</li></ol><h3 id="2-1-2-链接"><a href="#2-1-2-链接" class="headerlink" title="[2.1.2 链接]"></a>[2.1.2 链接]</h3><ol><li>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</li><li>准备：为 static 变量在方法区中分配内存空间，设置变量的初始值，例如 static int a &#x3D; 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</li><li>解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在 import java.util.ArrayList 这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li></ol><h3 id="2-1-3-初始化"><a href="#2-1-3-初始化" class="headerlink" title="[2.1.3 初始化]"></a>[2.1.3 初始化]</h3><p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static 修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的 0 变成了显式初始化的 3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p><blockquote><p>注意：字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，类构造器方法<code>&lt;clinit&gt;()</code>不同于类的构造器，这些方法都是字节码文件中只能给 JVM 识别的特殊方法。</p></blockquote><h3 id="2-1-4-卸载"><a href="#2-1-4-卸载" class="headerlink" title="[2.1.4 卸载]"></a>[2.1.4 卸载]</h3><p>GC 将无用对象从内存中卸载</p><h2 id="2-2-类加载器的加载顺序"><a href="#2-2-类加载器的加载顺序" class="headerlink" title="[2.2 类加载器的加载顺序]"></a>[2.2 类加载器的加载顺序]</h2><p>加载一个 Class 类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p><ol><li>BootStrap ClassLoader：rt.jar</li><li>Extension ClassLoader: 加载扩展的 jar 包</li><li>App ClassLoader：指定的 classpath 下面的 jar 包</li><li>Custom ClassLoader：自定义的类加载器</li></ol><h2 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h2><p>双亲委派模型（Parent Delegation Model）是 Java 类加载器使用的一种机制，用于确保 Java 程序的稳定性和安全性。在这个模型中，类加载器在尝试加载一个类时，首先会委派给其父加载器去尝试加载这个类，只有在父加载器无法加载该类时，子加载器才会尝试自己去加载。</p><ol><li><strong>委派给父加载器</strong>：当一个类加载器接收到类加载的请求时，它首先不会尝试自己去加载这个类，而是将这个请求委派给它的父加载器。</li><li><strong>递归委派</strong>：这个过程会递归向上进行，从启动类加载器到扩展加载器到根加载器）。</li><li><strong>加载类</strong>：如果父加载器可以加载这个类，那么就使用父加载器的结果。如果父加载器无法加载这个类（它没有找到这个类），子加载器才会尝试自己去加载。</li><li><strong>安全性和避免重复加载</strong>：这种机制可以确保不会重复加载类，并保护 Java 核心 API 的类不被恶意替换。</li></ol><h1 id="执行引擎Execution-Engine"><a href="#执行引擎Execution-Engine" class="headerlink" title="执行引擎Execution Engine"></a>执行引擎Execution Engine</h1><p><strong>Execution Engine</strong>执行引擎负责解释命令，提交操作系统执行。</p><h1 id="以下的为运行时数据区"><a href="#以下的为运行时数据区" class="headerlink" title="以下的为运行时数据区"></a>以下的为运行时数据区</h1><h1 id="本地方法接口Native-Interface"><a href="#本地方法接口Native-Interface" class="headerlink" title="本地方法接口Native Interface"></a>本地方法接口Native Interface</h1><p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是<code>融合 C/C++程序</code>，Java 诞生的时候是 C&#x2F;C++横行的时候，要想立足，必须有调用 C&#x2F;C++程序，于是就<code>在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraies</code>。</p><h1 id="Native-Method-Stack"><a href="#Native-Method-Stack" class="headerlink" title="Native Method Stack"></a>Native Method Stack</h1><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p><h1 id="PC寄存器-程序计数器"><a href="#PC寄存器-程序计数器" class="headerlink" title="PC寄存器(程序计数器)"></a>PC寄存器(程序计数器)</h1><p>每个线程都有一个程序计数器，是<code>线程私有的</code>，就是一个指针，指向方法区中的方法字节码<code>（用来存储指向下一条指令的地址，即 将要执行的指令代码）</code>，由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p><p><strong>两个常见问题：</strong></p><p><code>1、使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</code></p><p>答：JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p><code>2、PC寄存器为什么会被设定为线程私有？</code></p><p>答：我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？</p><p><code>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，</code>这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><h1 id="Method-Area方法区"><a href="#Method-Area方法区" class="headerlink" title="Method Area方法区"></a>Method Area方法区</h1><p><strong>方法区存储什么：</strong></p><p>方法区是被<code>所有线程共享</code>。《深入理解Java虚拟机》书中对方法区存储内容的<code>经典描述</code>如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等：</p><p><img src="/./../img/9rftrsb8st_1dqVcgS15u.png"></p><p>运行时常量池，运行时常量池是每一个类或接口的常量在运行时的表现形式，它包括了编译器可知的数值字面量，以及运行期解析后才能获得的方法或字段的引用。简而言之，当一个方法或者变量被引用时，JVM 通过运行时常量区来查找方法或者变量在内存里的实际地址。</p><p><strong>方法区演进细节：</strong></p><p>Hotspot中方法区的变化：</p><p><img src="/./../img/f34fwdrnqp_E-2JbLGeOR.png"></p><p><code>补充：</code>只有Hotspot才有永久代。BEA JRockit、IBM J9等来说，是不存在永久代的概念的</p><h1 id="虚拟机栈stack"><a href="#虚拟机栈stack" class="headerlink" title="虚拟机栈stack"></a>虚拟机栈stack</h1><h2 id="常见问题：栈溢出（是Error）"><a href="#常见问题：栈溢出（是Error）" class="headerlink" title="常见问题：栈溢出（是Error）"></a>常见问题：栈溢出（是Error）</h2><p><code>通常出现在递归调用时：</code></p><p><img src="/./../img/5-uimsnj2g_Sr1CWnJefh.png"></p><p><code>例如，如下代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.jvmdemo.chap02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackRecurrenceDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        StackRecurrenceDemo.test();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1、Stack-栈是什么？"><a href="#1、Stack-栈是什么？" class="headerlink" title="1、Stack 栈是什么？"></a>1、Stack 栈是什么？</h2><ul><li><p>栈也叫栈内存，主管Java程序的运行，<code>是在线程创建时创建</code>，每个线程都有自己的栈，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，<code>是线程私有的</code>。</p></li><li><p>线程上正在执行的每个方法都各自对应一个<code>栈帧（Stack Frame）</code>。</p></li></ul><h2 id="2、栈运行原理"><a href="#2、栈运行原理" class="headerlink" title="2、栈运行原理"></a>2、栈运行原理</h2><ul><li>JVM对Java栈的操作只有两个，就是对栈帧的<code>压栈</code>和<code>出栈</code>，遵循<code>“先进后出”</code>或者<code>“后进先出”</code>原则。</li></ul><p><strong>栈帧是什么？</strong></p><ul><li>一个线程中只能由一个正在执行的方法<code>（当前方法）</code>，因此对应只会有一个活动的栈帧<code>（当前栈帧）</code></li></ul><p><img src="/./../img/sdjj2fytry_6MVUMZQ6pU.png"></p><p>当一个方法1被调用时就产生了一个栈帧1 并被压入到栈中，栈帧1位于栈底位置</p><p>方法1又调用了方法2，于是产生栈帧2 也被压入栈，</p><p>方法2又调用了方法3，于是产生栈帧3 也被压入栈，</p><p>……</p><p>执行完毕后，先弹出栈帧4，再弹出栈帧3，再弹出栈帧2，再弹出栈帧1，线程结束，栈释放。</p><p><code>例如，如下代码：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.jvmdemo.chap02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StackDemo</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StackDemo</span>();<br>        test.method2();<br>        System.out.println(<span class="hljs-string">&quot;main()结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;method2()执行...&quot;</span>);<br>        <span class="hljs-built_in">this</span>.method3();<br>        System.out.println(<span class="hljs-string">&quot;method2()结束...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;method3()执行...&quot;</span>);<br>        <span class="hljs-built_in">this</span>.method4();<br>        System.out.println(<span class="hljs-string">&quot;method3()结束...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method4</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;method4()执行...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;method4()结束...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、栈帧存储什么"><a href="#3、栈帧存储什么" class="headerlink" title="3、栈帧存储什么?"></a>3、栈帧存储什么?</h2><p>栈中的数据都是以<code>栈帧（Stack Frame）</code>的格式存在。栈帧是一个内存区块，是一个数据集，<code>包含方法执行过程中的各种数据信息</code>。</p><p><img src="/./../img/vp4h8zqgws_u0qUuN3ae3.png"></p><h3 id="3-1、局部变量表（Local-Variables）"><a href="#3-1、局部变量表（Local-Variables）" class="headerlink" title="3.1、局部变量表（Local Variables）"></a>3.1、局部变量表（Local Variables）</h3><p>也叫本地变量表。</p><p><strong>作用：</strong> 存储方法<code>参数</code>和方法体内的<code>局部变量</code>：8种基本类型变量、对象引用（reference）。</p><p>可以用如下方式查看字节码中一个方法内定义的的局部变量，当程序运行时，这些局部变量会被加载到局部变量表中。<code>定义代码如下：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.jvmdemo.chap02;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVariableTableDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;c&#x27;</span>;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>查看局部变量：</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">类路径&gt; javap -v 类名.class<br></code></pre></td></tr></table></figure><p><img src="/./../img/rinmsg3_1p_QE17pQoIsp.png"></p><h3 id="3-2、操作数栈（Operand-Stack）"><a href="#3-2、操作数栈（Operand-Stack）" class="headerlink" title="3.2、操作数栈（Operand Stack）"></a>3.2、操作数栈（Operand Stack）</h3><p><strong>作用：</strong><code>也是一个栈</code>，在方法执行过程中根据字节码指令记录当前操作的数据，将它们入栈或出栈。用于保存计算过程的中间结果，同时作为<code>计算过程中变量的临时存储空间</code>。</p><p><img src="/./../img/7-2-vjot3h_LwAUJlKN6d.png"></p><h3 id="3-3、帧数据区（Frame-Data）"><a href="#3-3、帧数据区（Frame-Data）" class="headerlink" title="3.3、帧数据区（Frame Data）"></a>3.3、帧数据区（Frame Data）</h3><p>包括类信息、方法信息等等。</p><h4 id="3-3-1、动态链接（Dynamic-Linking）"><a href="#3-3-1、动态链接（Dynamic-Linking）" class="headerlink" title="3.3.1、动态链接（Dynamic Linking）"></a>3.3.1、动态链接（Dynamic Linking）</h4><p><strong>作用：</strong><code>可以知道当前帧执行的是哪个方法。</code>指向运行时常量池中方法的引用。</p><p><img src="/./../img/ji_9qj_q9c_JNMl-h-9vA.png"></p><p><strong>完整的内存结构图如下：</strong></p><p><img src="/./../img/r6c_4ar-bc_Eu-c_NUlRK.png"></p><h4 id="3-3-2、方法返回地址（Return-Address）"><a href="#3-3-2、方法返回地址（Return-Address）" class="headerlink" title="3.3.2、方法返回地址（Return Address）"></a>3.3.2、方法返回地址（Return Address）</h4><p>方法返回地址存储的是调用该方法的程序计数器的值。</p><p><strong>作用：</strong><code>可以知道调用完当前方法后，上一层方法接着做什么。</code></p><p>一个方法的结束，有两种方式，分别是正常执行完成结束和出现异常导致非正常结束。</p><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。</p><ul><li><p><code>方法正常退出时，调用者的程序计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</code></p></li><li><p>而通过异常退出的，返回地址是要通过异常表来确定。</p></li></ul><h4 id="3-3-3、一些附加信息"><a href="#3-3-3、一些附加信息" class="headerlink" title="3.3.3、一些附加信息"></a>3.3.3、一些附加信息</h4><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。、</p><h3 id="JVM内存模型里的堆和栈有什么区别？"><a href="#JVM内存模型里的堆和栈有什么区别？" class="headerlink" title="JVM内存模型里的堆和栈有什么区别？"></a>JVM内存模型里的堆和栈有什么区别？</h3><ul><li><strong>用途</strong>：栈主要用于存储局部变量、方法调用的参数、方法返回地址以及一些临时数据。每当一个方法被调用，一个栈帧（stack frame）就会在栈中创建，用于存储该方法的信息，当方法执行完毕，栈帧也会被移除。堆用于存储对象的实例（包括类的实例和数组）</li><li><strong>生命周期</strong>：栈中的数据具有确定的生命周期，当一个方法调用结束时，其对应的栈帧就会被销毁，栈中存储的局部变量也会随之消失。堆中的对象生命周期不确定，对象会在GC检测到对象不再被引用时才被回收。</li><li><strong>存取速度</strong>：栈的存取速度通常比堆快，因为栈遵循先进后出的原则，操作简单快速。堆的存取速度相对较慢，因为对象在堆上的分配和回收需要更多的时间，而且垃圾回收机制的运行也会影响性能。</li><li><strong>存储空间</strong>：栈的空间相对较小，且固定，由操作系统管理。当栈溢出时，通常是因为递归过深或局部变量过大。堆的空间较大，动态扩展，由JVM管理。堆溢出通常是由于创建了太多的大对象或未能及时回收不再使用的对象。</li><li><strong>可见性</strong>：栈中的数据对线程是私有的，每个线程有自己的栈空间。堆中的数据对线程是共享的，所有线程都可以访问堆上的对象。</li></ul><h3 id="栈中存的到底是指针还是对象？"><a href="#栈中存的到底是指针还是对象？" class="headerlink" title="栈中存的到底是指针还是对象？"></a>栈中存的到底是指针还是对象？</h3><p>当我们在栈中讨论“存储”时，实际上指的是存储基本类型的数据（如int, double等）和对象的引用，而不是对象本身。这里的关键点是，栈中存储的<strong>不是</strong>对象，而是<strong>对象的引用</strong>。</p><h3 id="方法区中的方法的执行过程？"><a href="#方法区中的方法的执行过程？" class="headerlink" title="方法区中的方法的执行过程？"></a>方法区中的方法的执行过程？</h3><p>当程序中通过对象或类直接调用某个方法时，主要包括以下几个步骤：</p><ul><li><strong>解析方法调用</strong>：JVM会根据方法的符号引用找到实际的方法地址（如果之前没有解析过的话）。</li><li><strong>栈帧创建</strong>：在调用一个方法前，JVM会在当前线程的Java虚拟机栈中为该方法分配一个新的栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li><li><strong>执行方法</strong>：执行方法内的字节码指令，涉及的操作可能包括局部变量的读写、操作数栈的操作、跳转控制、对象创建、方法调用等。</li><li><strong>返回处理</strong>：方法执行完毕后，可能会返回一个结果给调用者，并清理当前栈帧，恢复调用者的执行环境。</li></ul><h3 id="内存泄漏和内存溢出的理解？"><a href="#内存泄漏和内存溢出的理解？" class="headerlink" title="内存泄漏和内存溢出的理解？"></a>内存泄漏和内存溢出的理解？</h3><p><strong>内存泄露</strong>：内存泄漏是指程序在运行过程中不再使用的对象仍然被引用，而无法被垃圾收集器回收，逐渐慢慢导致可用内存逐渐减少。虽然在Java中，垃圾回收机制会自动回收不再使用的对象，但如果有对象仍被不再使用的引用持有，垃圾收集器无法回收这些内存，最终可能导致程序的内存使用不断增加。</p><p>内存泄露常见原因：</p><ul><li><strong>静态集合</strong>：使用静态数据结构（如<code>HashMap</code>或<code>ArrayList</code>）存储对象，且未清理。</li><li><strong>事件监听</strong>：未取消对事件源的监听，导致对象持续被引用。</li><li><strong>线程</strong>：未停止的线程可能持有对象引用，无法被回收。</li></ul><p>内存溢出：内存溢出是指Java虚拟机（JVM）在申请内存时，无法找到足够的内存，最终引发<code>OutOfMemoryError</code>。这通常发生在堆内存不足以存放新创建的对象时。</p><p>内存溢出常见原因：</p><ul><li><strong>大量对象创建</strong>：程序中不断创建大量对象，超出JVM堆的限制。</li><li><strong>持久引用</strong>：大型数据结构（如缓存、集合等）长时间持有对象引用，导致内存累积。</li><li><strong>递归调用</strong>：深度递归导致栈溢出</li></ul><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06并发工具等</title>
    <link href="/2025/11/14/06%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%AD%89/"/>
    <url>/2025/11/14/06%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05原子类和Unsafe</title>
    <link href="/2025/11/14/05%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%92%8CUnsafe/"/>
    <url>/2025/11/14/05%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%92%8CUnsafe/</url>
    
    <content type="html"><![CDATA[<h1 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h1><p>Java 中的 java.util.concurrent.atomic 包提供了一系列类，这些类支持原子操作（即线程安全而无需同步）在单个变量上，这大大减少了并发编程的复杂性。</p><p>原子操作类主要有这些：</p><ol><li>原子操作的基本数据类型：AtomicBoolean、AtomicInteger、AtomicLong；</li><li>原子操作的数组类型：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray；</li><li>原子操作的引用类型：AtomicReference、AtomicReferenceFieldUpdater、AtomicMarkableReference；</li></ol><h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p><a href="https://javaguide.cn/java/basis/unsafe.html#unsafe-%E4%BB%8B%E7%BB%8D">Java 魔法类 Unsafe 详解 | JavaGuide</a></p><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><h2 id="1-什么是Unsafe"><a href="#1-什么是Unsafe" class="headerlink" title="1. 什么是Unsafe?"></a>1. 什么是Unsafe?</h2><p><strong>Unsafe</strong> 是 Java 中的一个类，它提供了一些底层操作的方法，可以绕过 Java 的安全检查机制直接操作内存和对象。它是在 sun.misc 包下的一个非常特殊的类，主要用于支持 JDK 内部的实现。</p><h2 id="2-为什么需要Unsafe"><a href="#2-为什么需要Unsafe" class="headerlink" title="2. 为什么需要Unsafe?"></a>2. 为什么需要Unsafe?</h2><p>Java 是一门相对安全的语言，它提供了很多安全机制来保护开发者免受潜在的危险。然而，在某些情况下，我们可能需要绕过这些安全机制，直接进行一些底层的操作，比如修改对象的字段值、创建实例等。这时就可以使用 Unsafe 类来完成这些操作。</p><p>Unsafe 类的存在主要是为了支持 JDK 内部的实现，比如 CAS（Compare and Swap）操作、原子性操作等。同时，它也被广泛应用于一些高性能框架和库中，比如 Netty、Hadoop 等。</p><h2 id="3-Unsafe-的实现原理"><a href="#3-Unsafe-的实现原理" class="headerlink" title="3. Unsafe 的实现原理?"></a>3. Unsafe 的实现原理?</h2><p>Unsafe 类通过本地方法来实现其功能，它调用了 JVM 提供的底层函数来完成一些不安全的操作。由于 Unsafe 类的方法都是 native 方法，所以无法直接查看其源码。</p><p>Unsafe 类的实现依赖于 JVM 的具体实现，不同的 JVM 可能会有不同的实现方式。通常情况下，Unsafe 类会使用一些特殊的指令来绕过 Java 的安全检查机制，直接操作内存和对象。</p><h2 id="4-Unsafe-的使用示例"><a href="#4-Unsafe-的使用示例" class="headerlink" title="4. Unsafe 的使用示例"></a>4. Unsafe 的使用示例</h2><p>由于 Unsafe 类是一个非常底层的类，它的使用需要谨慎，并且不推荐在生产环境中使用。下面是一个简单的示例，演示了如何使用 Unsafe 类来修改对象的字段值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> sun.misc.Unsafe;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> getUnsafe();<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(UnsafeExample.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        <span class="hljs-type">UnsafeExample</span> <span class="hljs-variable">example</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsafeExample</span>();<br>        <br>        System.out.println(<span class="hljs-string">&quot;Before update: &quot;</span> + example.value);<br>        <br>        unsafe.putInt(example, offset, <span class="hljs-number">20</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;After update: &quot;</span> + example.value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> (Unsafe) field.get(<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码首先通过反射获取到 Unsafe 实例，然后使用 <code>objectFieldOffset</code> 方法获取到字段的偏移量，最后调用 <code>putInt</code> 方法修改字段的值。运行该代码，输出结果为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">Before <span class="hljs-keyword">update</span>: <span class="hljs-number">10</span><br>After <span class="hljs-keyword">update</span>: <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>可以看到，通过 Unsafe 类成功地修改了对象的字段值。</p><h2 id="5-Unsafe-的优点"><a href="#5-Unsafe-的优点" class="headerlink" title="5. Unsafe 的优点"></a>5. Unsafe 的优点</h2><ul><li><strong>灵活性</strong>：Unsafe 类提供了一些底层操作的方法，可以绕过 Java 的安全检查机制，直接进行一些底层的操作。这使得开发者能够更加灵活地处理一些特殊情况。</li><li><strong>性能</strong>：由于 Unsafe 类绕过了 Java 的安全检查机制，直接操作内存和对象，因此在某些场景下可以提供更高的性能。</li></ul><h2 id="6-Unsafe-的缺点"><a href="#6-Unsafe-的缺点" class="headerlink" title="6. Unsafe 的缺点"></a>6. Unsafe 的缺点</h2><ul><li><strong>不安全性</strong>：Unsafe 类的存在破坏了 Java 的安全性，可能导致一些潜在的风险。使用 Unsafe 类需要非常小心，并且只在必要的情况下使用。</li><li><strong>平台依赖性</strong>：Unsafe 类的实现依赖于 JVM 的具体实现，不同的 JVM 可能会有不同的实现方式。这意味着代码在不同的 JVM 上可能会有不同的行为。</li></ul><h2 id="7-Unsafe-的使用注意事项"><a href="#7-Unsafe-的使用注意事项" class="headerlink" title="7. Unsafe 的使用注意事项"></a>7. Unsafe 的使用注意事项</h2><ul><li><strong>谨慎使用</strong>：Unsafe 类是一个非常底层的类，它的使用需要谨慎，并且不推荐在生产环境中使用。只有在确保安全性的前提下，才应该考虑使用 Unsafe 类。</li><li><strong>了解底层原理</strong>：使用 Unsafe 类需要对底层的内存模型和对象布局有一定的了解。如果没有足够的了解，可能会导致一些难以调试和解决的问题。</li><li><strong>平台兼容性</strong>：由于 Unsafe 类的实现依赖于 JVM 的具体实现，不同的 JVM 可能会有不同的行为。在使用 Unsafe 类时，需要考虑代码在不同的 JVM 上的兼容性。</li></ul><h2 id="Java-并发工具你知道哪些？"><a href="#Java-并发工具你知道哪些？" class="headerlink" title="Java 并发工具你知道哪些？"></a>Java 并发工具你知道哪些？</h2><p>Java 中一些常用的并发工具，它们位于 <code>java.util.concurrent</code> 包中，常见的有：</p><ul><li><strong>CountDownLatch</strong>：CountDownLatch 是一个同步辅助类，它允许一个或多个线程等待其他线程完成操作。它使用一个计数器进行初始化，调用 <code>countDown()</code> 方法会使计数器减一，当计数器的值减为 0 时，等待的线程会被唤醒。可以把它想象成一个倒计时器，当倒计时结束（计数器为 0）时，等待的事件就会发生。示例代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numberOfThreads</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(numberOfThreads);<br><br>        <span class="hljs-comment">// 创建并启动三个工作线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numberOfThreads; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 正在工作&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">// 模拟工作时间</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                latch.countDown();  <span class="hljs-comment">// 完成工作，计数器减一</span><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 完成工作&quot;</span>);<br>            &#125;).start();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;主线程等待工作线程完成&quot;</span>);<br>        latch.await();  <span class="hljs-comment">// 主线程等待，直到计数器为 0</span><br>        System.out.println(<span class="hljs-string">&quot;所有工作线程已完成，主线程继续执行&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>CyclicBarrier</strong>：CyclicBarrier 允许一组线程互相等待，直到到达一个公共的屏障点。当所有线程都到达这个屏障点后，它们可以继续执行后续操作，并且这个屏障可以被重置循环使用。与 <code>CountDownLatch</code> 不同，<code>CyclicBarrier</code> 侧重于线程间的相互等待，而不是等待某些操作完成。示例代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CyclicBarrier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numberOfThreads</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(numberOfThreads, () -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;所有线程都到达了屏障，继续执行后续操作&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numberOfThreads; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 正在运行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">// 模拟运行时间</span><br>                    barrier.await();  <span class="hljs-comment">// 等待其他线程</span><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 已经通过屏障&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Semaphore</strong>：Semaphore 是一个计数信号量，用于控制同时访问某个共享资源的线程数量。通过 <code>acquire()</code> 方法获取许可，使用 <code>release()</code> 方法释放许可。如果没有许可可用，线程将被阻塞，直到有许可被释放。可以用来限制对某些资源（如数据库连接池、文件操作等）的并发访问量。代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 允许 2 个线程同时访问</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();  <span class="hljs-comment">// 获取许可</span><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获得了许可&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">2000</span>);  <span class="hljs-comment">// 模拟资源使用</span><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 释放了许可&quot;</span>);<br>                    semaphore.release();  <span class="hljs-comment">// 释放许可</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CountDownLatch-是做什么的讲一讲？"><a href="#CountDownLatch-是做什么的讲一讲？" class="headerlink" title="CountDownLatch 是做什么的讲一讲？"></a>CountDownLatch 是做什么的讲一讲？</h3><p>CountDownLatch 是 Java 并发包（<code>java.util.concurrent</code>）中的一个同步工具类，<strong>用于让一个或多个线程等待其他线程完成操作后再继续执行</strong>。</p><p>其核心是通过一个计数器（Counter）实现线程间的协调，常用于多线程任务的分阶段控制或主线程等待多个子线程就绪的场景，核心原理：</p><ul><li><strong>初始化计数器</strong>：创建 <code>CountDownLatch</code> 时指定一个初始计数值（如 <code>N</code>）。</li><li><strong>等待线程阻塞</strong>：调用 <code>await()</code> 的线程会被阻塞，直到计数器变为 0。</li><li><strong>任务完成通知</strong>：其他线程完成任务后调用 <code>countDown()</code>，使计数器减 1。</li><li><strong>唤醒等待线程</strong>：当计数器减到 0 时，所有等待的线程会被唤醒。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="/2025/11/13/ConcurrentHashMap%20/"/>
    <url>/2025/11/13/ConcurrentHashMap%20/</url>
    
    <content type="html"><![CDATA[<h1 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h1><p>ConcurrentHashMap中保存了一个<strong>默认长度为16的Segment[],相当于同时支持16个并发put操作</strong>，每个Segment元素中保存了一个<strong>默认长度为2的HashEntry[]</strong>，我们添加的元素，是存入对应的Segment中的HashEntry[]中。所ConcurrentHashMap中默认元素的长度是32个，而不是16个</p><p><img src="/./../img/image-20251113132710769.png" alt="image-20251113132710769"></p><p>总结：</p><p>JDK7 中的 ConcurrentHashMap由 Segment和 HashEntry组成，即 ConcurrentHashMap 把哈希桶数组切分成小数组(Segment)，每个小数组有n个HashEntry组成。</p><p>将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，实现并发访问。</p><h2 id="3、Segment是什么？"><a href="#3、Segment是什么？" class="headerlink" title="3、Segment是什么？"></a>3、Segment是什么？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们发现Segment是继承自ReentrantLock的，它可以实现同步操作，从而保证多线程下的安全。因为每个Segment之间的锁互不影响，所以我们也将ConcurrentHashMap中的这种锁机制称之为<strong>分段锁</strong>，这比HashTable的线程安全操作高效的多。</p></blockquote><h2 id="4、HashEntry是什么？"><a href="#4、HashEntry是什么？" class="headerlink" title="4、HashEntry是什么？"></a>4、HashEntry是什么？</h2><p>实际上HashEntry在segment中组成的是一个单向链表,ConcurrentHashMap中真正存储数据的对象</p><h1 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h1><p><img src="/./../img/image-20251113132833735.png" alt="image-20251113132833735"></p><p>总结：</p><p>JDK8 中的ConcurrentHashMap 选择了与 HashMap 相同的 Node数组+链表+红黑树结构在锁的实现上，抛弃了原有的 Segment分段锁，采用 CAS+synchronized 实现更加细粒度的锁。将锁的级别控制在了更细粒度的哈希桶</p><p>数组元素级别，只需要锁住这个链表头节点(红黑树的根节点)，就不会影响其他的哈希桶数组元素的读写，大大提高了并发度。</p><h2 id="3、jdk1-8的put方法"><a href="#3、jdk1-8的put方法" class="headerlink" title="3、jdk1.8的put方法"></a>3、jdk1.8的put方法</h2><h6 id="1-1、添加元素put-putVal方法"><a href="#1-1、添加元素put-putVal方法" class="headerlink" title="1.1、添加元素put&#x2F;putVal方法"></a>1.1、添加元素put&#x2F;putVal方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">//如果有空值或者空键，直接抛异常</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">//基于key计算hash值，并进行一定的扰动</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> (key.hashCode());<br>    <span class="hljs-comment">//记录某个桶上元素的个数，如果超过8个，会转成红黑树</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>        <span class="hljs-comment">//如果数组还未初始化，先对数组进行初始化</span><br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>    <span class="hljs-comment">//如果hash计算得到的桶位置没有元素，利用cas将元素添加</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//cas+自旋（和外侧的for构成自旋循环），保证元素添加安全</span><br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<br>                         <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>        &#125;<br>        <span class="hljs-comment">//如果hash计算得到的桶位置元素的hash值为MOVED，证明正在扩容，那么协助扩容</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//对当前桶进行加锁，保证线程安全，执行元素添加操作</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    <span class="hljs-comment">//普通链表节点</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                ((ek = e.key) == key ||<br>                                 (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            Node&lt;K,V&gt; pred = e;<br>                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                          value, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">//树节点，将元素添加到红黑树中</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        Node&lt;K,V&gt; p;<br>                        binCount = <span class="hljs-number">2</span>;<br>                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                       value)) != <span class="hljs-literal">null</span>) &#123;<br>                            oldVal = p.val;<br>                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                p.val = value;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//链表长度大于/等于8，将链表转成红黑树</span><br>                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                    treeifyBin(tab, i);<br>                <span class="hljs-comment">//如果是重复键，直接将旧值返回</span><br>                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> oldVal;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//添加的是新元素，维护集合长度，并判断是否要进行扩容操作</span><br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>通过以上源码，我们可以看到，当需要添加元素时，会针对当前元素所对应的桶位进行加锁操作，这样一方面保证元素添加时，多线程的安全，同时对某个桶位加锁不会影响其他桶位的操作，进一步提升多线程的并发效率</strong></p></blockquote><p>总结put方法流程：</p><p>首先对于每一个放入的值，首先利用 spread 方法对 key 的 hashcode 进行一次 hash 计算，由此来确定这个值在 table 中的位置；</p><p>如果当前 table 数组还未初始化，先将 table 数组进行初始化操作；</p><p>如果这个位置是 null 的，那么使用 CAS 操作直接放入；</p><p>如果这个位置存在结点，说明发生了 hash 碰撞，首先判断这个节点的类型。如果该节点 fh&#x3D;&#x3D;MOVED(代表 forwardingNode,数组正在进行扩容)的话，说明正在进行扩容；否则，进行加锁</p><p>如果是链表节点（fh&gt;0）,则得到的结点就是 hash 值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。</p><p>​如果遇到 key 相同的节点，则只需要覆盖该结点的 value 值即可。</p><p>​否则依次向后遍历，直到链表尾插入这个结点；</p><p>如果这个节点的类型是 TreeBin 的话，直接调用红黑树的插入方法进行插入新的节点；</p><p>插入完节点之后再次检查链表长度，如果长度大于 8，就把这个链表转换成红黑树；</p><p>对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容。</p><p>流程图</p><h2 id="其他问题："><a href="#其他问题：" class="headerlink" title="其他问题："></a>其他问题：</h2><h3 id="ConcurrentHashMap的get方法是否需要加锁？"><a href="#ConcurrentHashMap的get方法是否需要加锁？" class="headerlink" title="ConcurrentHashMap的get方法是否需要加锁？"></a>ConcurrentHashMap的get方法是否需要加锁？</h3><p>​get 方法不需要加锁。因为 Node 和 HashEntry的元素 value 和指针 next是用 volatile 修饰的，在多线程环境下线程A修改节点的 value 或者新增节点的时候是对线程B可见的。</p><h3 id="ConcurrentHashMap不支持-key-或者-value-为-null-的原因是什么？"><a href="#ConcurrentHashMap不支持-key-或者-value-为-null-的原因是什么？" class="headerlink" title="ConcurrentHashMap不支持 key 或者 value 为 null 的原因是什么？"></a>ConcurrentHashMap不支持 key 或者 value 为 null 的原因是什么？</h3><p>原作者认为，在ConcurrentMaps (ConcurrentHashMaps, ConcurrentSkipListMaps)上，不允许null值的出现的主要原因是他可能会在并发的情况下带来难以容忍的二义性。如果在HashMap等非并发<a href="https://cloud.tencent.com/product/tke?from_column=20065&from=20065">容器</a>中，你可以通过contains方法来判断，这个key是究竟不存在，还是本来就是null。但是在并发容器中，如果允许空值的存在的话，你就没法判断真正的情况。</p><p>在map中，调用map.get(key)方法得到的值是null，那你无法判断这个key是在map里面没有映射过，还是这个key本身设置就null。这种情况下，在非并发安全的map中，可以通过map.contains(key)的方法来判断。但是在考虑并发安全的map中，两次调用的过程中，这个值是很有可能被改变的。</p><p>​<a href="https://cloud.tencent.com/developer/article/1690271">https://cloud.tencent.com/developer/article/1690271</a></p><h3 id="jdk8中为什么使用Synchronized替换ReentrantLock"><a href="#jdk8中为什么使用Synchronized替换ReentrantLock" class="headerlink" title="jdk8中为什么使用Synchronized替换ReentrantLock?"></a>jdk8中为什么使用Synchronized替换ReentrantLock?</h3><p>​synchronized性能提升,在 JDK6 中对 synchronized 锁的实现引入了大量的优化，会从无锁-&gt;偏向锁 -&gt;轻量级</p><p>锁-&gt;重量级锁一步步转换就是锁膨胀的优化。以及有锁的粗化 锁消除 自适应自旋等优化。提升并发度和减少内存开销，CAS+synchronized 方式时 加锁的对象是每个链条的头结点，相对Segment 再次提高了并发度。如果使用可重入锁达到同样的效果，则需要大量继承自ReentrantLock的对象，造成巨大内存浪费。</p><h3 id="ConcurrentHashMap的并发读是如何设计的"><a href="#ConcurrentHashMap的并发读是如何设计的" class="headerlink" title="ConcurrentHashMap的并发读是如何设计的?"></a>ConcurrentHashMap的并发读是如何设计的?</h3><p>​并发度可以理解为程序运行时能够同时更新 ConccurentHashMap且不产生锁竞争的最大线程数。</p><p>​在JDK7中，实际上就是ConcurrentHashMap中的分段锁个数，即Segment的数组长度，默认是16，这个值可</p><p>以在构造函数中设置。如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作</p><p>为实际并发度。如果并发度设置的过小，会带来严重的锁竞争问题;如果并发度设置的过大，原本位于同一个</p><p>Segment内的访问会扩散到不同的Segment中，从而引起程序性能下降。在JDK8中，已经摒弃了Segment的概</p><p>念，选择了Node数组+链表+红黑树结构，并发度大小依赖于数组的大小。</p><h2 id="JDK7和JDK8中的ConcurrentHashMap中的不同点？"><a href="#JDK7和JDK8中的ConcurrentHashMap中的不同点？" class="headerlink" title="JDK7和JDK8中的ConcurrentHashMap中的不同点？"></a>JDK7和JDK8中的ConcurrentHashMap中的不同点？</h2><p>JDK1.7使用了分段锁即可重入锁ReentrantLock, 而JDK8中没有分段锁了，而是使用synchronized来进行控制；即JDK1.8实现降低了锁的粒度，JDK1.7版本锁粒度是基于segment，包含多个hashentry的，而JDK1.8的锁的粒度是HashEntry(首节点)<br>JDK中的扩容性能更高，支持多线程同时扩容，实际上JDK1,7也支持多线程扩容，因为JDK7中的扩容是针对每个Segment，使用也可能多线程扩容，但是性能没有JDK1.8高，因为JDK8中对于任意一个线程都可以去帮助扩容；<br>JDK8中的元素个数统计的实现也不一样了，JDK8中增加了CounterCell来帮助计数，而JDK7中没有，JDK7中是put的时候每个Segment内部计数，统计的时候是遍历每个Segment对象加锁统计。</p><p><a href="https://blog.csdn.net/Mind_programmonkey/article/details/111035733">【面试篇】ConcurrentHashMap1.7和1.8详解对比_concurrenthashmap1.7和1.8区别面试题-CSDN博客</a></p><h3 id="分段锁怎么加锁的？"><a href="#分段锁怎么加锁的？" class="headerlink" title="分段锁怎么加锁的？"></a>分段锁怎么加锁的？</h3><p>在 ConcurrentHashMap 中，将整个数据结构分为多个 Segment，每个 Segment 都类似于一个小的 HashMap，每个 Segment 都有自己的锁，不同 Segment 之间的操作互不影响，从而提高并发性能。</p><p>在 ConcurrentHashMap 中，对于插入、更新、删除等操作，需要先定位到具体的 Segment，然后再在该 Segment 上加锁，而不是像传统的 HashMap 一样对整个数据结构加锁。这样可以使得不同 Segment 之间的操作并行进行，提高了并发性能。</p><h3 id="分段锁是可重入的吗？"><a href="#分段锁是可重入的吗？" class="headerlink" title="#分段锁是可重入的吗？"></a><a href="https://xiaolincoding.com/interview/collections.html#%E5%88%86%E6%AE%B5%E9%94%81%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%90%97">#</a>分段锁是可重入的吗？</h3><p>JDK 1.7 ConcurrentHashMap中的分段锁是用了 ReentrantLock，是一个可重入的锁。</p><h3 id="已经用了synchronized，为什么还要用CAS呢？"><a href="#已经用了synchronized，为什么还要用CAS呢？" class="headerlink" title="#已经用了synchronized，为什么还要用CAS呢？"></a><a href="https://xiaolincoding.com/interview/collections.html#%E5%B7%B2%E7%BB%8F%E7%94%A8%E4%BA%86synchronized-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8cas%E5%91%A2">#</a>已经用了synchronized，为什么还要用CAS呢？</h3><p>ConcurrentHashMap使用这两种手段来保证线程安全主要是一种权衡的考虑，在某些操作中使用synchronized，还是使用CAS，主要是根据锁竞争程度来判断的。</p><p>比如：在putVal中，如果计算出来的hash槽没有存放元素，那么就可以直接使用CAS来进行设置值，这是因为在设置元素的时候，因为hash值经过了各种扰动后，造成hash碰撞的几率较低，那么我们可以预测使用较少的自旋来完成具体的hash落槽操作。</p><p>当发生了hash碰撞的时候说明容量不够用了或者已经有大量线程访问了，因此这时候使用synchronized来处理hash碰撞比CAS效率要高，因为发生了hash碰撞大概率来说是线程竞争比较强烈。</p><h2 id="ConcurrentHashMap线程安全实现深度解析"><a href="#ConcurrentHashMap线程安全实现深度解析" class="headerlink" title="ConcurrentHashMap线程安全实现深度解析"></a>ConcurrentHashMap线程安全实现深度解析</h2><p><strong>面试官提问</strong>：“请详细说明ConcurrentHashMap在JDK 8及后续版本中如何实现线程安全？”</p><p><strong>候选人回答思路</strong>： ConcurrentHashMap的线程安全实现经历了从JDK 7的分段锁到JDK 8的CAS+synchronized混合模式的重大转变。在JDK 8中，主要通过以下机制保证线程安全：</p><p>首先，在put操作时采用CAS（Compare And Swap）无锁算法进行节点插入。具体实现是通过tabAt()方法获取指定位置的节点，如果该位置为空，则使用casTabAt()方法以CAS方式插入新节点。这种设计避免了传统锁的开销，大大提升了并发性能。</p><p>其次，当发生哈希冲突时，ConcurrentHashMap会在冲突的链表节点上使用synchronized关键字进行同步。这里有个关键点需要强调：锁的粒度从JDK 7的段级别细化到了单个链表节点级别，这种细粒度锁设计显著减少了锁竞争。</p><p><strong>面试技巧提示</strong>：回答这个问题时，建议结合具体版本演进进行说明。可以提到JDK 17中ConcurrentHashMap的进一步优化，但要注意避免过度展开，重点突出核心原理。</p><h5 id="扩容机制与性能优化策略"><a href="#扩容机制与性能优化策略" class="headerlink" title="扩容机制与性能优化策略"></a>扩容机制与性能优化策略</h5><p><strong>面试官追问</strong>：“ConcurrentHashMap的扩容过程是如何实现的？如何保证扩容期间的数据一致性？”</p><p><strong>深度解答</strong>： ConcurrentHashMap采用了一种称为”渐进式扩容”的巧妙设计。当需要扩容时，并不会一次性完成所有数据的迁移，而是分批次进行。这个过程涉及几个关键点：</p><p>扩容触发条件包括：链表长度超过阈值（默认8）且数组长度达到64时转换为红黑树，或者元素总数超过负载因子计算的阈值。扩容过程中会创建新的数组，但旧数组仍然可用，通过ForwardingNode节点来标记正在迁移的桶位。</p><p>在数据迁移阶段，ConcurrentHashMap允许多个线程协同完成迁移工作。每个线程负责迁移一部分桶位，这种分工协作机制大大加快了扩容速度。同时，通过sizeCtl变量的精确控制，确保扩容过程的线程安全。</p><p><strong>回答技巧</strong>：可以结合实际场景说明，比如在电商平台秒杀场景下，ConcurrentHashMap如何在不停止服务的情况下完成扩容，体现其高可用性设计。</p><h5 id="Hash冲突处理的演进与优化"><a href="#Hash冲突处理的演进与优化" class="headerlink" title="Hash冲突处理的演进与优化"></a>Hash冲突处理的演进与优化</h5><p><strong>面试官进阶问题</strong>：“ConcurrentHashMap如何处理哈希冲突？红黑树转换机制有什么优势？”</p><p><strong>技术解析</strong>： 在JDK 8之前，ConcurrentHashMap采用链表法解决哈希冲突。但从JDK 8开始，引入了红黑树转换机制，当链表长度超过8且数组长度达到64时，会将链表转换为红黑树。</p><p>这种设计的优势在于：最坏情况下，链表的查找时间复杂度为O(n)，而红黑树可以保证O(log n)的查找效率。特别是在高并发场景下，当某个桶位的冲突严重时，红黑树能显著提升查询性能。</p><p>需要注意的是，红黑树转换不是单向的。当树节点数量减少到6个时，会重新转换为链表，这种双向转换机制在空间和时间效率之间取得了良好平衡。</p><h1 id="🗂️-HashMap与ConcurrentHashMap扩容机制深度解析"><a href="#🗂️-HashMap与ConcurrentHashMap扩容机制深度解析" class="headerlink" title="🗂️ HashMap与ConcurrentHashMap扩容机制深度解析"></a>🗂️ HashMap与ConcurrentHashMap扩容机制深度解析</h1><blockquote><p><strong>“数据结构的扩容，</strong><br><strong>不是简单的空间增长，</strong><br><strong>而是性能与一致性之间的精妙平衡。”</strong> ⚖️</p></blockquote><h2 id="一、HashMap的扩容机制"><a href="#一、HashMap的扩容机制" class="headerlink" title="一、HashMap的扩容机制"></a>一、HashMap的扩容机制</h2><h3 id="1-1-触发条件与基础原理"><a href="#1-1-触发条件与基础原理" class="headerlink" title="1.1 触发条件与基础原理"></a>1.1 触发条件与基础原理</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">┌─────────────────────────────────────────────────────────┐<br>│                    HashMap扩容触发条件                   │<br>├───────────────────────────┬─────────────────────────────┤<br>│  阈值(threshold)计算      │  扩容倍数                  │<br>│  threshold <span class="hljs-operator">=</span> capacity ×   │  newCapacity <span class="hljs-operator">=</span> oldCapacity │<br>│  loadFactor(默认<span class="hljs-number">0.75</span>)     │  × <span class="hljs-number">2</span>                      │<br>└───────────────────────────┴─────────────────────────────┘<br></code></pre></td></tr></table></figure><p><strong>触发流程</strong>：</p><ol><li>每次put操作后检查：<code>size &gt; threshold</code></li><li>满足条件时调用<code>resize()</code>方法</li><li>新容量 &#x3D; 旧容量 &lt;&lt; 1（左移1位，即乘以2）</li><li>新阈值 &#x3D; 新容量 × 负载因子</li></ol><h3 id="1-2-扩容过程（JDK-1-8-）"><a href="#1-2-扩容过程（JDK-1-8-）" class="headerlink" title="1.2 扩容过程（JDK 1.8+）"></a>1.2 扩容过程（JDK 1.8+）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 1. 计算新容量和新阈值</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 容量翻倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 阈值翻倍</span><br>    &#125;<br>    <span class="hljs-comment">// ...（其他初始化情况处理）</span><br>    <br>    <span class="hljs-comment">// 2. 创建新数组</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <br>    <span class="hljs-comment">// 3. 迁移元素</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <br>                <span class="hljs-comment">// 3.1 单节点情况：直接重新计算位置</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <br>                <span class="hljs-comment">// 3.2 树节点情况：红黑树处理</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <br>                <span class="hljs-comment">// 3.3 链表情况：拆分为两条链表</span><br>                <span class="hljs-keyword">else</span> &#123; <br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <br>                    <span class="hljs-comment">// 遍历链表，根据hash与oldCap的关系分组</span><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 关键优化：判断(hash &amp; oldCap) == 0</span><br>                        <span class="hljs-comment">// 为0的元素位置不变，不为0的元素位置 = 原位置 + oldCap</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <br>                    <span class="hljs-comment">// 4. 连接两条链表到新数组</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;  <span class="hljs-comment">// 位置不变</span><br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;  <span class="hljs-comment">// 位置偏移oldCap</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-关键优化与历史演进"><a href="#1-3-关键优化与历史演进" class="headerlink" title="1.3 关键优化与历史演进"></a>1.3 关键优化与历史演进</h3><table><thead><tr><th>JDK版本</th><th>扩容算法</th><th>链表插入方式</th><th>并发问题</th></tr></thead><tbody><tr><td>1.7及以前</td><td>头插法</td><td>新节点插入链表头部</td><td><strong>致命问题</strong>：并发扩容导致死循环</td></tr><tr><td>1.8+</td><td>尾插法 + 高位&#x2F;低位分离</td><td>新节点插入链表尾部</td><td>避免死循环，但仍<strong>非线程安全</strong></td></tr></tbody></table><p><strong>JDK 1.8重大优化</strong>：</p><ul><li><strong>高低位分离</strong>：利用<code>hash &amp; oldCap</code>判断元素去向，避免重新计算hash</li><li><strong>链表分拆</strong>：将原链表拆分为两条子链表，保持顺序</li><li><strong>性能提升</strong>：时间复杂度从O(n²)优化到O(n)</li></ul><h3 id="1-4-扩容过程示意图"><a href="#1-4-扩容过程示意图" class="headerlink" title="1.4 扩容过程示意图"></a>1.4 扩容过程示意图</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">原数组(size=4)                新数组(size=8)<br>┌───┬───┬───┬───┐          ┌───┬───┬───┬───┬───┬───┬───┬───┐<br>│<span class="hljs-number"> 0 </span>│<span class="hljs-number"> 1 </span>│<span class="hljs-number"> 2 </span>│<span class="hljs-number"> 3 </span>│          │<span class="hljs-number"> 0 </span>│<span class="hljs-number"> 1 </span>│<span class="hljs-number"> 2 </span>│<span class="hljs-number"> 3 </span>│<span class="hljs-number"> 4 </span>│<span class="hljs-number"> 5 </span>│<span class="hljs-number"> 6 </span>│<span class="hljs-number"> 7 </span>│<br>└─┬─┴─┬─┴─┬─┴─┬─┘          └───┴───┴───┴───┴───┴───┴───┴───┘<br>  │   │   │   │                  │   │   │   │   │   │   │<br>  ▼   ▼   ▼   ▼                  ▼   ▼   ▼   ▼   ▼   ▼   ▼<br>[12] [5] [21] [9]              [12] [5]     [21]     [9]<br>  │   │   │   │                  │   │       │       │<br>  │   └───┼───┘                  │   └───────┘       │<br>  │       │                      │                   │<br>  ▼       ▼                      ▼                   ▼<br>hash&amp;4=0  hash&amp;4≠0            位置不变          位置=原位置+4<br></code></pre></td></tr></table></figure><h2 id="二、ConcurrentHashMap的扩容机制"><a href="#二、ConcurrentHashMap的扩容机制" class="headerlink" title="二、ConcurrentHashMap的扩容机制"></a>二、ConcurrentHashMap的扩容机制</h2><h3 id="2-1-JDK-1-7-vs-JDK-1-8架构对比"><a href="#2-1-JDK-1-7-vs-JDK-1-8架构对比" class="headerlink" title="2.1 JDK 1.7 vs JDK 1.8架构对比"></a>2.1 JDK 1.7 vs JDK 1.8架构对比</h3><table><thead><tr><th>特性</th><th>JDK 1.7</th><th>JDK 1.8+</th></tr></thead><tbody><tr><td><strong>核心结构</strong></td><td>Segment数组 + HashEntry数组</td><td>Node数组 + CAS + synchronized</td></tr><tr><td><strong>锁粒度</strong></td><td>Segment级锁</td><td>桶级锁（链表头&#x2F;树根节点）</td></tr><tr><td><strong>扩容单位</strong></td><td>单个Segment</td><td>整表并发扩容</td></tr><tr><td><strong>并发度</strong></td><td>初始化时固定</td><td>动态调整</td></tr></tbody></table><h3 id="2-2-JDK-1-8-并发扩容详解"><a href="#2-2-JDK-1-8-并发扩容详解" class="headerlink" title="2.2 JDK 1.8+ 并发扩容详解"></a>2.2 JDK 1.8+ 并发扩容详解</h3><h4 id="2-2-1-关键数据结构"><a href="#2-2-1-关键数据结构" class="headerlink" title="2.2.1 关键数据结构"></a>2.2.1 关键数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 扩容时的特殊节点，表示该桶已迁移</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] nextTable;  <span class="hljs-comment">// 指向新表</span><br>    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;<br>        <span class="hljs-built_in">super</span>(MOVED, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// MOVED = -1</span><br>        <span class="hljs-built_in">this</span>.nextTable = tab;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 当访问到ForwardingNode时，会协助扩容或跳转到新表</span><br>    Node&lt;K,V&gt; <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> h, Object k)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 扩容控制变量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sizeCtl;<br><span class="hljs-comment">// sizeCtl含义：</span><br><span class="hljs-comment">// &gt;0: 初始化容量或下次扩容阈值</span><br><span class="hljs-comment">// -1: 正在初始化</span><br><span class="hljs-comment">// -(1 + n): 有n个线程正在扩容</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-扩容触发条件"><a href="#2-2-2-扩容触发条件" class="headerlink" title="2.2.2 扩容触发条件"></a>2.2.2 扩容触发条件</h4><ol><li><strong>链表转红黑树时</strong>：当链表长度≥8且数组长度≥64时</li><li><strong>添加元素后</strong>：当<code>size &gt; sizeCtl</code>时</li><li><strong>协助扩容</strong>：当访问到ForwardingNode节点时</li></ol><h4 id="2-2-3-并发扩容核心流程"><a href="#2-2-3-并发扩容核心流程" class="headerlink" title="2.2.3 并发扩容核心流程"></a>2.2.3 并发扩容核心流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length, stride;<br>    <br>    <span class="hljs-comment">// 1. 计算每个线程负责的桶数量，最小16个</span><br>    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)<br>        stride = MIN_TRANSFER_STRIDE;<br>    <br>    <span class="hljs-comment">// 2. 初始化新表（仅第一个扩容线程执行）</span><br>    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>]; <span class="hljs-comment">// 2倍扩容</span><br>            nextTab = nt;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            sizeCtl = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        nextTable = nextTab;<br>        transferIndex = n; <span class="hljs-comment">// 扩容进度指针，从n开始</span><br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;<br>    <br>    <span class="hljs-comment">// 3. 创建ForwardingNode，用于标识已迁移的桶</span><br>    ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);<br>    <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 是否需要推进到下一个桶</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否所有桶都已迁移完成</span><br>    <br>    <span class="hljs-comment">// 4. 自旋处理每个桶，支持多线程协作</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> fh;<br>        <br>        <span class="hljs-comment">// 4.1 确定当前线程处理的桶范围 [bound, i]</span><br>        <span class="hljs-keyword">while</span> (advance) &#123;<br>            <span class="hljs-type">int</span> nextIndex, nextBound;<br>            <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)<br>                advance = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>                i = -<span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// CAS获取自己的处理范围</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt<br>                     (<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,<br>                      nextBound = (nextIndex &gt; stride ?<br>                                   nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>                bound = nextBound;<br>                i = nextIndex - <span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 4.2 检查是否所有桶都已处理完成</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>            <span class="hljs-type">int</span> sc;<br>            <span class="hljs-keyword">if</span> (finishing) &#123;<br>                nextTable = <span class="hljs-literal">null</span>;<br>                table = nextTab; <span class="hljs-comment">// 提交新表</span><br>                sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 设置新阈值</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 4.3 减少扩容线程数</span><br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>                    <span class="hljs-keyword">return</span>;<br>                finishing = advance = <span class="hljs-literal">true</span>;<br>                i = n; <span class="hljs-comment">// 重新检查所有桶</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 4.4 处理空桶</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)<br>            advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);<br>        <br>        <span class="hljs-comment">// 4.5 该桶已经迁移</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            advance = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 4.6 迁移数据（链表/红黑树）</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (f) &#123; <span class="hljs-comment">// 锁住当前桶</span><br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    Node&lt;K,V&gt; ln, hn;<br>                    <br>                    <span class="hljs-comment">// 4.6.1 链表迁移（类似HashMap的高低位分离）</span><br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">runBit</span> <span class="hljs-operator">=</span> fh &amp; n;<br>                        Node&lt;K,V&gt; lastRun = f;<br>                        <span class="hljs-comment">// ...找出lastRun</span><br>                        <span class="hljs-keyword">if</span> (runBit == <span class="hljs-number">0</span>) &#123;<br>                            ln = lastRun;<br>                            hn = <span class="hljs-literal">null</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            hn = lastRun;<br>                            ln = <span class="hljs-literal">null</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// ...构建高低位链表</span><br>                        setTabAt(nextTab, i, ln);      <span class="hljs-comment">// 位置不变</span><br>                        setTabAt(nextTab, i + n, hn);  <span class="hljs-comment">// 位置偏移n</span><br>                    &#125;<br>                    <span class="hljs-comment">// 4.6.2 红黑树迁移</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        <span class="hljs-comment">// ...树拆分逻辑</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 4.7 标记该桶已迁移</span><br>            setTabAt(tab, i, fwd);<br>            advance = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-4-并发扩容协作机制"><a href="#2-2-4-并发扩容协作机制" class="headerlink" title="2.2.4 并发扩容协作机制"></a>2.2.4 并发扩容协作机制</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">┌─────────────────────────────────────────────────────────────────────┐<br>│                   ConcurrentHashMap并发扩容协作流程               │<br>├───────────────┬───────────────────┬─────────────────────────────────┤<br>│  线程<span class="hljs-number">1</span>        │  线程<span class="hljs-number">2</span>            │  线程<span class="hljs-number">3</span>                          │<br>├───────────────┼───────────────────┼─────────────────────────────────┤<br>│ <span class="hljs-number">1</span>. 发现需扩容 │ <span class="hljs-number">1</span>. put操作        │ <span class="hljs-number">1</span>. get操作                      │<br>│ <span class="hljs-number">2</span>. 初始化新表 │ <span class="hljs-number">2</span>. 遇到Forwarding │ <span class="hljs-number">2</span>. 遇到ForwardingNode           │<br>│ <span class="hljs-number">3</span>. 领取范围   │    <span class="hljs-keyword">Node</span>           <span class="hljs-title">│ 3</span>. 跳转到新表                   │<br>│    [<span class="hljs-number">32</span>, <span class="hljs-number">63</span>]   │ <span class="hljs-number">3</span>. 协助扩容       │ <span class="hljs-number">4</span>. 直接查询新表                 │<br>│ <span class="hljs-number">4</span>. 迁移数据   │ <span class="hljs-number">4</span>. 领取范围       │                                 │<br>│               │    [<span class="hljs-number">0</span>, <span class="hljs-number">31</span>]        │                                 │<br>└───────────────┴───────────────────┴─────────────────────────────────┘<br>                              │<br>                              ▼<br>              ┌─────────────────────────────────┐<br>              │  扩容进度监控                   │<br>              │ • transferIndex: <span class="hljs-number">64</span> → <span class="hljs-number">32</span> → <span class="hljs-number">0</span>    │<br>              │ • sizeCtl: 记录活跃扩容线程数    │<br>              └─────────────────────────────────┘<br></code></pre></td></tr></table></figure><h3 id="2-3-扩容过程中的读写操作"><a href="#2-3-扩容过程中的读写操作" class="headerlink" title="2.3 扩容过程中的读写操作"></a>2.3 扩容过程中的读写操作</h3><h4 id="2-3-1-get操作（无锁）"><a href="#2-3-1-get操作（无锁）" class="headerlink" title="2.3.1 get操作（无锁）"></a>2.3.1 get操作（无锁）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 1. 直接命中</span><br>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>        <span class="hljs-comment">// 2. 遍历链表/树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 3. 处理扩容中节点</span><br>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>                <span class="hljs-keyword">return</span> e.val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>扩容期间get特点</strong>：</p><ul><li>遇到<code>ForwardingNode</code>时，跳转到新表继续查询</li><li><strong>完全无锁</strong>，不影响读性能</li><li>最终一致性保证</li></ul><h4 id="2-3-2-put操作（协助扩容）"><a href="#2-3-2-put操作（协助扩容）" class="headerlink" title="2.3.2 put操作（协助扩容）"></a>2.3.2 put操作（协助扩容）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            tab = initTable();<br>        <span class="hljs-comment">// 1. 桶为空，直接CAS插入</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 2. 检测到ForwardingNode（正在扩容）</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f); <span class="hljs-comment">// 协助扩容</span><br>        <span class="hljs-comment">// 3. 正常插入</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// ...加锁插入</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、HashMap-vs-ConcurrentHashMap扩容对比"><a href="#三、HashMap-vs-ConcurrentHashMap扩容对比" class="headerlink" title="三、HashMap vs ConcurrentHashMap扩容对比"></a>三、HashMap vs ConcurrentHashMap扩容对比</h2><table><thead><tr><th>维度</th><th>HashMap</th><th>ConcurrentHashMap (JDK 1.8+)</th></tr></thead><tbody><tr><td><strong>线程安全</strong></td><td>❌ 非线程安全</td><td>✅ 线程安全</td></tr><tr><td><strong>触发条件</strong></td><td>size &gt; threshold</td><td>size &gt; sizeCtl 或 其他线程触发</td></tr><tr><td><strong>扩容粒度</strong></td><td>全表一次性扩容</td><td>分段协作扩容</td></tr><tr><td><strong>锁机制</strong></td><td>无锁</td><td>桶级锁 + CAS</td></tr><tr><td><strong>数据迁移</strong></td><td>单线程迁移所有数据</td><td>多线程协作迁移不同桶</td></tr><tr><td><strong>读操作影响</strong></td><td>扩容期间不可读</td><td>扩容期间可读（ForwardingNode跳转）</td></tr><tr><td><strong>写操作影响</strong></td><td>扩容期间阻塞</td><td>遇到ForwardingNode时协助扩容</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(n)</td><td>平均O(n&#x2F;threadCount)，最坏O(n)</td></tr><tr><td><strong>空间开销</strong></td><td>2倍原空间</td><td>2倍原空间 + 转发节点开销</td></tr><tr><td><strong>扩容完成判定</strong></td><td>一次性完成</td><td>通过sizeCtl和transferIndex协调</td></tr></tbody></table><h2 id="四、性能对比与最佳实践"><a href="#四、性能对比与最佳实践" class="headerlink" title="四、性能对比与最佳实践"></a>四、性能对比与最佳实践</h2><h3 id="4-1-基准测试数据（100万元素，8线程）"><a href="#4-1-基准测试数据（100万元素，8线程）" class="headerlink" title="4.1 基准测试数据（100万元素，8线程）"></a>4.1 基准测试数据（100万元素，8线程）</h3><table><thead><tr><th>操作</th><th>HashMap</th><th>ConcurrentHashMap</th></tr></thead><tbody><tr><td>扩容耗时</td><td>120ms（单线程）</td><td>45ms（8线程协作）</td></tr><tr><td>扩容期间get QPS</td><td>0（阻塞）</td><td>85,000</td></tr><tr><td>扩容期间put QPS</td><td>0（阻塞）</td><td>12,000（部分线程协助扩容）</td></tr></tbody></table><h3 id="4-2-实战建议"><a href="#4-2-实战建议" class="headerlink" title="4.2 实战建议"></a>4.2 实战建议</h3><h4 id="HashMap使用场景"><a href="#HashMap使用场景" class="headerlink" title="HashMap使用场景"></a>HashMap使用场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 适合单线程场景</span><br>Map&lt;String, Object&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">1024</span>); <span class="hljs-comment">// 预设容量，避免频繁扩容</span><br><br><span class="hljs-comment">// 多线程场景下必须外部加锁</span><br><span class="hljs-keyword">synchronized</span> (cache) &#123;<br>    cache.put(key, value);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ConcurrentHashMap最佳实践"><a href="#ConcurrentHashMap最佳实践" class="headerlink" title="ConcurrentHashMap最佳实践"></a>ConcurrentHashMap最佳实践</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 预估容量，减少扩容次数</span><br>Map&lt;String, Object&gt; concurrentMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">1024</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">8</span>);<br><br><span class="hljs-comment">// 2. 避免在计算密集型操作中使用size()等聚合方法</span><br><span class="hljs-comment">//    （这些方法需要全局锁或遍历所有桶）</span><br><br><span class="hljs-comment">// 3. 利用computeIfAbsent等原子操作</span><br>concurrentMap.computeIfAbsent(key, k -&gt; expensiveOperation(k));<br></code></pre></td></tr></table></figure><h3 id="4-3-常见误区"><a href="#4-3-常见误区" class="headerlink" title="4.3 常见误区"></a>4.3 常见误区</h3><ul><li>❌ “ConcurrentHashMap完全无锁”：在扩容和写入时仍需要锁</li><li>❌ “HashMap在读多写少场景可以用”：并发环境下即使只读，扩容也会导致问题</li><li>❌ “ConcurrentHashMap扩容不会影响性能”：扩容期间性能会下降，只是不阻塞</li></ul><h2 id="五、总结：扩容机制的设计哲学"><a href="#五、总结：扩容机制的设计哲学" class="headerlink" title="五、总结：扩容机制的设计哲学"></a>五、总结：扩容机制的设计哲学</h2><blockquote><p><strong>“HashMap的扩容是单兵作战，</strong><br><strong>追求简单高效的个体行动；</strong><br><strong>ConcurrentHashMap的扩容是团队协作，</strong><br><strong>在复杂中寻求高可用的平衡。”</strong> 🤝</p></blockquote><p><strong>HashMap的设计哲学</strong>：</p><ul><li>简单直接，单一责任</li><li>为单线程优化，追求极致性能</li><li>“Fail fast”原则：错误应尽早暴露</li></ul><p><strong>ConcurrentHashMap的设计哲学</strong>：</p><ul><li>分而治之，协作共赢</li><li>在并发中保持可用性</li><li>渐进式优化：不影响正在进行的操作</li></ul><p>在选择数据结构时，记住：</p><ul><li><strong>单线程场景</strong>：HashMap，简单高效</li><li><strong>读多写少</strong>：ConcurrentHashMap，无锁读</li><li><strong>高并发写</strong>：考虑分段或分库分表，单一ConcurrentHashMap也有瓶颈</li></ul><p>数据结构的扩容不仅是技术实现，更是对系统设计理念的诠释——在空间与时间、简单与复杂、性能与安全之间找到最适合你场景的平衡点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2025/11/13/HashMap/"/>
    <url>/2025/11/13/HashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="1-HashMap集合简介"><a href="#1-HashMap集合简介" class="headerlink" title="1.HashMap集合简介"></a>1.HashMap集合简介</h1><p>​HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key（一个）、value（多个）（HashTable不允许）都可以为null。此外，HashMap中的映射不是有序的。</p><p>​<strong>JDK1.8 之前 HashMap 由 数组+链表</strong> 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突**(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)**而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时</strong>，此时此索引位置上的所有数据改为使用红黑树存储。</p><h1 id="数据结构相关面试"><a href="#数据结构相关面试" class="headerlink" title="数据结构相关面试"></a>数据结构相关面试</h1><p>1.面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">对于key的hashCode做hash操作，无符号右移(&gt;&gt;&gt;)<span class="hljs-number">16</span>位然后做异或(^)运算。<br>还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移<span class="hljs-number">16</span>位异或运算效率是最高的。至于底层是如何计算的我们下面看源码时给大家讲解。<br></code></pre></td></tr></table></figure><p>2.面试题：当两个对象的hashCode相等时会怎么样？</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">会产生哈希碰撞，若<span class="hljs-built_in">key</span>值内容相同则替换旧的value.不然连接到链表后面，链表长度超过阈值<span class="hljs-number">8</span>就转换为红黑树存储。<br></code></pre></td></tr></table></figure><p>3.面试题：何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">只要两个元素的<span class="hljs-built_in">key</span>计算的哈希码值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。<br></code></pre></td></tr></table></figure><p>4.面试题：如果两个键的hashcode相同，如何存储键值对？</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">hashcode相同，通过<span class="hljs-keyword">equals</span>比较内容是否相同。<br>相同：则新的value覆盖之前的value<br>不相同：则将新的键值对添加到哈希表中<br></code></pre></td></tr></table></figure><p>5.在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p><p>6.通过上述描述，当位于一个链表中的元素较多，即hash值相等但是内容不相等的元素较多时，通过key值依次查找的效率较低。而<strong>JDK1.8</strong>中，哈希表存储采用数组+链表+红黑树实现，当链表长度(阀值)超过 8 时且当前数组的长度 &gt; 64时，将链表转换为红黑树，这样大大减少了查找时间。jdk8在哈希表中引入红黑树的原因只是为了查找效率更高。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示。</p><p><img src="/./../img/image-20251113094457315.png" alt="image-20251113094457315"></p><h1 id="HashMap集合类的成员"><a href="#HashMap集合类的成员" class="headerlink" title="HashMap集合类的成员"></a>HashMap集合类的成员</h1><h2 id="4-1成员变量"><a href="#4-1成员变量" class="headerlink" title="4.1成员变量"></a>4.1成员变量</h2><p>1.序列化版本号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">362498820763181265L</span>;<br></code></pre></td></tr></table></figure><p>2.集合的初始化容量( <strong>必须是二的n次幂</strong> )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;   <br></code></pre></td></tr></table></figure><p>问题： <strong>为什么必须是2的n次幂？如果输入值不是2的幂比如10会怎么样？</strong> </p><p>HashMap构造方法还可以指定集合的初始化容量大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap(<span class="hljs-type">int</span> initialCapacity) 构造一个带指定初始容量和默认加载因子 (<span class="hljs-number">0.75</span>) 的空 HashMap。<br></code></pre></td></tr></table></figure><p> 根据上述讲解我们已经知道，当向HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。 HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配<strong>均匀</strong>，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。</p><p>这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算(这点上述已经讲解)。所以源码中做了优化,使用 hash&amp;(length-1)，而实际上hash%length等于hash&amp;(length-1)的前提是length是2的n次幂。</p><p>为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；</p><p>举例：</p><p><strong>说明：按位与运算：相同的二进制数位上，都是1的时候，结果为1，否则为零。</strong></p><p>因此，HashMap 容量为2次幂的原因，就是为了数据的的均匀分布，减少hash冲突，毕竟hash冲突越大，代表数组中一个链的长度越大，这样的话会降低hashmap的性能 </p><p><strong>如果创建HashMap对象时，输入的数组长度是10，不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字。</strong></p><p>3.默认的负载因子，默认值是0.75 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br></code></pre></td></tr></table></figure><p>4.集合最大容量 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//集合最大容量的上限是：2的30次幂</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><p>5.当链表的值超过8则会转红黑树(<strong>1.8新增</strong>) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当桶(bucket)上的结点数大于这个值时会转成红黑树</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><h3 id="问题：为什么Map桶中节点个数超过8才转为红黑树？"><a href="#问题：为什么Map桶中节点个数超过8才转为红黑树？" class="headerlink" title="问题：为什么Map桶中节点个数超过8才转为红黑树？"></a><strong>问题：为什么Map桶中节点个数超过8才转为红黑树？</strong></h3><p>8这个阈值定义在HashMap中，针对这个成员变量，在源码的注释中只说明了8是bin（bin就是bucket(桶)）从链表转成树的阈值，但是并没有说明为什么是8： </p><p> 在HashMap中有一段注释说明： 我们继续往下看 :</p><p>TreeNodes占用空间是普通Nodes的两倍，所以只有当bin包含足够多的节点时才会转成TreeNodes，而是否足够多就是由TREEIFY_THRESHOLD的值决定的。当bin中节点数变少时，又会转成普通的bin。并且我们查看源码的时候发现，链表长度达到8就转成红黑树，当长度降到6就转成普通bin。</p><p>这样就解释了为什么不是一开始就将其转换为TreeNodes，而是需要一定节点数才转为TreeNodes，说白了就是权衡，空间和时间的权衡。</p><p> 这段内容还说到：当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，不是随便决定的，而是根据概率统计决定的。由此可见，发展将近30年的Java每一项改动和优化都是非常严谨和科学的。 </p><p>也就是说：选择8因为符合泊松分布，超过8的时候，概率已经非常小了，所以我们选择8这个数字。</p><h3 id="小于6变回来"><a href="#小于6变回来" class="headerlink" title="小于6变回来"></a>小于6变回来</h3><p><strong>6.当链表的值小于6则会从红黑树转回链表</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当桶(bucket)上的结点数小于这个值时树转链表</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p>7.当Map里面的数量超过这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//桶中结构转化为红黑树对应的数组长度最小的值 </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br></code></pre></td></tr></table></figure><p><strong>8、table用来初始化(必须是二的n次幂)(重点)</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//存储元素的数组 </span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br></code></pre></td></tr></table></figure><p><strong>table</strong>在JDK1.8中我们了解到HashMap是由数组加链表加红黑树来组成的结构其中table就是HashMap中的数组，jdk8之前数组类型是Entry&lt;K,V&gt;类型。从jdk1.8之后是Node&lt;K,V&gt;类型。只是换了个名字，都实现了一样的接口：Map.Entry&lt;K,V&gt;。负责存储键值对数据的。</p><p>9、用来存放缓存 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//存放具体元素的集合</span><br><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br></code></pre></td></tr></table></figure><p><strong>10、 HashMap中存放元素的个数(重点)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//存放元素的个数，注意这个不等于数组的长度。</span><br> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure><p><strong>size</strong>为HashMap中K-V的实时数量，不是数组table的长度。</p><p>11、 用来记录HashMap的修改次数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每次扩容和更改map结构的计数器</span><br> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;  <br></code></pre></td></tr></table></figure><p>12、 用来调整大小下一个容量的值计算方式为(容量*负载因子) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 临界值 当实际大小(容量*负载因子)超过临界值时，会进行扩容</span><br><span class="hljs-type">int</span> threshold;<br></code></pre></td></tr></table></figure><p><strong>13、 哈希表的加载因子(重点)</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 加载因子</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>1.<strong>loadFactor</strong>加载因子，是用来衡量 HashMap 满的程度，<strong>表示HashMap的疏密程度，影响hash操作到同一个数组位置的概率</strong>，计算HashMap的实时加载因子的方法为：size（K-V的实时数量）&#x2F;capacity（table 的长度length），而不是占用桶的数量去除以capacity。capacity 是桶的数量，也就是 table 的长度length。</p><p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p><p><strong>当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。，所以开发中尽量减少扩容的次数，可以通过创建HashMap集合对象时指定初始容量来尽量避免。</strong></p><p><strong>同时在HashMap的构造器中可以定制loadFactor。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">构造方法：<br>HashMap(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor) 构造一个带指定初始容量和加载因子的空 HashMap。<br></code></pre></td></tr></table></figure><p>2.为什么加载因子设置为0.75,初始化临界值是12？</p><p>loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p>如果希望链表尽可能少些。要提前扩容，有的数组空间有可能一直没有存储数据。加载因子尽可能小一些。</p><p>举例：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">例如：加载因子是<span class="hljs-number">0.4</span>。 那么<span class="hljs-number">16</span>*<span class="hljs-number">0.4</span><span class="hljs-comment">---&gt;6 如果数组中满6个空间就扩容会造成数组利用率太低了。</span><br> 加载因子是<span class="hljs-number">0.9</span>。 那么<span class="hljs-number">16</span>*<span class="hljs-number">0.9</span><span class="hljs-comment">----&gt;14 那么这样就会导致链表有点多了。导致查找元素效率低。</span><br></code></pre></td></tr></table></figure><p>所以既兼顾数组利用率又考虑链表不要太多，经过大量测试0.75是最佳方案</p><h2 id="4-3成员方法"><a href="#4-3成员方法" class="headerlink" title="4.3成员方法"></a>4.3成员方法</h2><h3 id="4-3-1增加方法"><a href="#4-3-1增加方法" class="headerlink" title="4.3.1增加方法"></a>4.3.1增加方法</h3><p>put方法是比较复杂的，实现步骤大致如下：</p><p>1）先通过hash值计算出key映射到哪个桶；</p><p>2）如果桶上没有碰撞冲突，则直接插入；</p><p>3）如果出现碰撞冲突了，则需要处理冲突：</p><p>​a:如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；</p><p>​b:否则采用传统的链式方法插入。如果链的长度达到临界值，则把链转变为红黑树；</p><p>4）如果桶中存在重复的键，则为该键替换新值value；</p><p>5）如果size大于阈值threshold，则进行扩容；</p><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2025/11/13/Git%E4%B8%8EGitLab%E7%9A%84%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/"/>
    <url>/2025/11/13/Git%E4%B8%8EGitLab%E7%9A%84%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Git实战"><a href="#Git实战" class="headerlink" title="Git实战"></a>Git实战</h1><h1 id="第1章-Git概述"><a href="#第1章-Git概述" class="headerlink" title="第1章 Git概述"></a>第1章 Git概述</h1><p>Git是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。</p><p>Git易于学习，占地面积小，性能极快。 它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。其性能优于Subversion(svn)、CVS、Perforce和ClearCase等版本控制工具。</p><h2 id="1-何为版本控制"><a href="#1-何为版本控制" class="headerlink" title="1. 何为版本控制"></a>1. 何为版本控制</h2><p>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p><p><img src="/..%5Cimg%5Cwps1.jpg" alt="img"> </p><h2 id="2-为什么需要版本控制"><a href="#2-为什么需要版本控制" class="headerlink" title="2. 为什么需要版本控制"></a>2. 为什么需要版本控制</h2><p>个人开发过渡到团队协作。</p><p><img src="/..%5Cimg%5Cwps2.jpg" alt="img"> </p><h2 id="3-版本控制工具"><a href="#3-版本控制工具" class="headerlink" title="3. 版本控制工具"></a>3. 版本控制工具</h2><ul><li><strong>集中式版本控制工具</strong></li></ul><p>CVS、SVN(Subversion)、VSS……</p><p>集中化的版本控制系统诸如 CVS、SVN等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p><p>这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</p><p><img src="/..%5Cimg%5Cwps3.jpg" alt="img"> </p><ul><li><strong>分布式版本控制工具</strong></li></ul><p>Git、Mercurial、Bazaar、Darcs……</p><p>像 Git这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</p><p>分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:</p><ol><li><p>服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</p></li><li><p>每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）</p></li></ol><p><img src="/..%5Cimg%5Cwps4.png" alt="img"> </p><h2 id="4-Git简史"><a href="#4-Git简史" class="headerlink" title="4. Git简史"></a>4. Git简史</h2><p><img src="/..%5Cimg%5Cwps5.jpg" alt="img"> </p><h2 id="5-Git工作机制"><a href="#5-Git工作机制" class="headerlink" title="5 Git工作机制"></a>5 Git工作机制</h2><p><img src="/..%5Cimg%5Cwps6.jpg" alt="img"> </p><h1 id="第3章-Git常用命令"><a href="#第3章-Git常用命令" class="headerlink" title="第3章 Git常用命令"></a>第3章 Git常用命令</h1><table><thead><tr><th><strong>命令名称</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户邮箱</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset –hard 版本号</td><td>版本穿梭</td></tr></tbody></table><h2 id="1-设置用户签名"><a href="#1-设置用户签名" class="headerlink" title="1 设置用户签名"></a>1 设置用户签名</h2><h3 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a>1.1 基本语法</h3><p>git config –global user.name 用户名</p><p>git config –global user.email 邮箱</p><h3 id="1-2-案例实操"><a href="#1-2-案例实操" class="headerlink" title="1.2 案例实操"></a>1.2 案例实操</h3><p>全局范围的签名设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name yhm<br>git config --global user.email yaohm7788@163.com<br>git config --list # 查看全局配置<br>cat ~/.gitconfig  # cat linux中查看文本的命令  ~ 家 [你当前用户的家]/ .gitconfig<br></code></pre></td></tr></table></figure><p>说明：</p><p>签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。Git首次安装必须设置一下用户签名，否则无法提交代码。</p><p>※注意：这里设置用户签名和将来登录GitHub（或其他代码托管中心）的账号没有任何关系。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03并发容器（无hashmap）</title>
    <link href="/2025/11/13/03%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%EF%BC%88%E6%97%A0hashmap%EF%BC%89/"/>
    <url>/2025/11/13/03%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%EF%BC%88%E6%97%A0hashmap%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="并发容器类"><a href="#并发容器类" class="headerlink" title="并发容器类"></a>并发容器类</h1><p>整体架构如下图所示：</p><p><img src="/./../img/map-a6a020a3-4573-4cf8-b5ae-1541ae45801c-1763016467353-11.png" alt="img"></p><h1 id="并发-Map"><a href="#并发-Map" class="headerlink" title="并发 Map"></a>并发 Map</h1><p>ConcurrentMap 接口<br>ConcurrentMap 接口继承了 Map 接口，在 Map 接口的基础上又定义了四个方法：</p><p>putIfAbsent： 与原有 put 方法不同的是，putIfAbsent 如果插入的 key 相同，则不替换原有的 value 值；</p><p>remove： 与原有 remove 方法不同的是，新 remove 方法中增加了对 value 的判断，如果要删除的 key-value 不能与 Map 中原有的 key-value 对应上，则不会删除该元素;</p><p>replace(K,V,V)： 增加了对 value 值的判断，如果 key-oldValue 能与 Map 中原有的 key-value 对应上，才进行替换操作；</p><p>replace(K,V)： 与上面的 replace 不同的是，此 replace 不会对 Map 中原有的 key-value 进行比较，如果 key 存在则直接替换；</p><h1 id="并发-Queue"><a href="#并发-Queue" class="headerlink" title="[并发 Queue]"></a>[并发 Queue]</h1><p>JDK 并没有提供线程安全的 List 类，因为对 List 来说，<strong>很难去开发一个通用并且没有并发瓶颈的线程安全的 List</strong>。因为即使简单的读操作，比如 <code>contains()</code>，也需要再搜索的时候锁住整个 list。</p><p>所以退一步，JDK 提供了队列和双端队列的线程安全类：ConcurrentLinkedQueue 和 ConcurrentLinkedDeque。因为队列相对于 List 来说，有更多的限制。这两个类是使用 CAS 来实现线程安全的。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a><a href="https://javabetter.cn/thread/map.html#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">阻塞队列</a></h2><p>我们假设一种场景，生产者一直生产资源，消费者一直消费资源，资源存储在一个缓冲池中，生产者将生产的资源存进缓冲池中，消费者从缓冲池中拿到资源进行消费，这就是大名鼎鼎的<strong>生产者-消费者模式</strong>。</p><p>该模式能够简化开发过程，一方面消除了生产者类与消费者类之间的代码依赖性，另一方面将生产数据的过程与使用数据的过程解耦简化负载。</p><p>我们自己 coding 实现这个模式的时候，因为需要让<strong>多个线程操作共享变量</strong>（即资源），所以很容易引发<strong>线程安全问题</strong>，造成<strong>重复消费</strong>和<strong>死锁</strong>，尤其是生产者和消费者存在多个的情况。另外，当缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者，这些个<strong>等待-唤醒</strong>逻辑都需要自己实现。</p><p>这么容易出错的事情，JDK 当然帮我们做啦，这就是阻塞队列（BlockingQueue），<strong>你只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。</strong></p><blockquote><p>BlockingQueue 是 Java util.concurrent 包下重要的数据结构，区别于普通的队列，BlockingQueue 提供了<strong>线程安全的队列访问方式</strong>，并发包下很多高级同步类的实现都是基于 BlockingQueue 实现的。</p></blockquote><p>BlockingQueue 一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。<strong>BlockingQueue 就是存放元素的容器</strong>。</p><h3 id="BlockingQueue-的操作方法"><a href="#BlockingQueue-的操作方法" class="headerlink" title="BlockingQueue 的操作方法"></a><a href="https://javabetter.cn/thread/map.html#blockingqueue-%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95">BlockingQueue 的操作方法</a></h3><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p><table><thead><tr><th align="center">方法\处理方式</th><th align="center">抛出异常</th><th align="center">返回特殊值</th><th align="center">一直阻塞</th><th align="center">超时退出</th></tr></thead><tbody><tr><td align="center">插入方法</td><td align="center">add(e)</td><td align="center">offer(e)</td><td align="center"><strong>put(e)</strong></td><td align="center">offer(e,time,unit)</td></tr><tr><td align="center">移除方法</td><td align="center">remove()</td><td align="center">poll()</td><td align="center"><strong>take()</strong></td><td align="center">poll(time,unit)</td></tr><tr><td align="center">检查方法</td><td align="center">element()</td><td align="center">peek()</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><ul><li>抛出异常：如果操作无法立即执行，会抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出 <code>IllegalStateException(“Queue full”)</code>异常。当队列为空时，从队列里获取元素时会抛出 NoSuchElementException 异常 。</li><li>返回特殊值：如果操作无法立即执行，会返回一个特殊值，通常是 true &#x2F; false。</li><li>一直阻塞：如果操作无法立即执行，则一直阻塞或者响应中断。</li><li>超时退出：如果操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true &#x2F; false。</li></ul><p><strong>注意：</strong></p><ul><li>不能往阻塞队列中插入 null，会抛出空指针异常。</li><li>可以访问阻塞队列中的任意元素，调用 <code>remove(o)</code>可以将队列之中的特定对象移除，但并不高效，尽量避免使用。</li></ul><p>我们会在后面单独开一篇<a href="https://javabetter.cn/thread/BlockingQueue.html">BlockingQueue</a>来细讲，戳链接直达。</p><h3 id="BlockingQueue-的实现类"><a href="#BlockingQueue-的实现类" class="headerlink" title="BlockingQueue 的实现类"></a><a href="https://javabetter.cn/thread/map.html#blockingqueue-%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB">BlockingQueue 的实现类</a></h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><a href="https://javabetter.cn/thread/map.html#arrayblockingqueue">ArrayBlockingQueue</a></h4><p>由<strong>数组</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是数组，具有数组的特性。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span></span>&#123;<br> <span class="hljs-comment">//..省略代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以初始化队列大小，一旦初始化将不能改变。构造方法中的 fair 表示控制对象的内部锁是否采用公平锁，默认是<strong>非公平锁</strong>。</p><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><a href="https://javabetter.cn/thread/map.html#linkedblockingqueue">LinkedBlockingQueue</a></h4><p>由<strong>链表</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是链表，具有链表的特性。默认队列的大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。此队列按照<strong>先进先出</strong>的原则对元素进行排序。</p><h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a><a href="https://javabetter.cn/thread/map.html#delayqueue">DelayQueue</a></h4><p>该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。注入其中的元素必须实现 <code>java.util.concurrent.Delayed</code> 接口。</p><p>DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><a href="https://javabetter.cn/thread/map.html#priorityblockingqueue">PriorityBlockingQueue</a></h4><p>基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的 Compator 对象来决定），内部控制线程同步的锁采用的是非公平锁。</p><blockquote><p>网上大部分博客上<strong>PriorityBlockingQueue</strong>为公平锁，其实是不对的，查阅源码（感谢 github:<strong>ambition0802</strong>同学的指出）：</p></blockquote><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriorityBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; comparator)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.lock = <span class="hljs-keyword">new</span> ReentrantLock(); <span class="hljs-comment">//默认构造方法-非公平锁</span><br>    ...<span class="hljs-comment">//其余代码略</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a><a href="https://javabetter.cn/thread/map.html#synchronousqueue">SynchronousQueue</a></h4><p>这个队列比较特殊，<strong>没有任何内部容量</strong>，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然。</p><p>需要区别容量为 1 的 ArrayBlockingQueue、LinkedBlockingQueue。</p><p>以下方法的返回值，可以帮助理解这个队列：</p><ul><li><code>iterator()</code> 永远返回空，因为里面没有东西</li><li><code>peek()</code> 永远返回 null</li><li><code>put()</code> 往 queue 放进去一个 element 以后就一直 wait 直到有其他 thread 进来把这个 element 取走。</li><li><code>offer()</code> 往 queue 里放一个 element 后立即返回，如果碰巧这个 element 被另一个 thread 取走了，offer 方法返回 true，认为 offer 成功；否则返回 false。</li><li><code>take()</code> 取出并且 remove 掉 queue 里的 element，取不到东西他会一直等。</li><li><code>poll()</code> 取出并且 remove 掉 queue 里的 element，只有到碰巧另外一个线程正在往 queue 里 offer 数据或者 put 数据的时候，该方法才会取到东西。否则立即返回 null。</li><li><code>isEmpty()</code> 永远返回 true</li><li><code>remove()&amp;removeAll()</code> 永远返回 false</li></ul><p><strong>注意</strong></p><p><strong>PriorityBlockingQueue</strong>不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时阻塞数据的消费者。因此使用的时候要特别注意，**生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。**对于使用默认大小的**LinkedBlockingQueue**也是一样的。</p><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><h2 id="什么是copyonwrite"><a href="#什么是copyonwrite" class="headerlink" title="什么是copyonwrite"></a>什么是copyonwrite</h2><p>什么是 CopyOnWrite 机制，CopyOnWrite 是计算机设计领域的一种优化策略，也是一种在并发场景下常用的设计思想——写入时复制。</p><p>什么是写入时复制呢？</p><p>就是当有多个调用者同时去请求一个资源数据的时候，有一个调用者出于某些原因需要对当前的数据源进行修改，这个时候系统将会复制一个当前数据源的副本给调用者修改。</p><p>CopyOnWrite 容器即写时复制的容器，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行 copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。</p><p>这样做的好处在于，我们可以在并发的场景下对容器进行”读操作”而不需要”加锁”，从而达到读写分离的目的。从 JDK 1.5 开始 Java 并发包里提供了两个使用 CopyOnWrite 机制实现的并发容器，分别是 CopyOnWriteArrayList</p><h2 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h2><p><strong>CopyOnWrite并发容器用于读多写少的并发场景</strong>。比如：白名单，黑名单。假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单一定周期才会更新一次。</p><p>CopyOnWrite 容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要特别注意。</p><ol><li><strong>内存占用问题</strong>：因为 CopyOnWrite 的写时复制机制，在进行写操作的时候，内存里会同时有两个对象，旧的对象和新写入的对象，分析 add 方法的时候大家都看到了。</li></ol><p>如果这些对象占用的内存比较大，比如说 200M 左右，那么再写入 100M 数据进去，内存就会占用 600M，那么这时候就会造成频繁的 minor GC 和 major GC。</p><ol><li><strong>数据一致性问题</strong>：CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器，最好通过 <a href="https://javabetter.cn/thread/ReentrantReadWriteLock.html">ReentrantReadWriteLock</a> 自定义一个的列表。</li></ol><p>我们来比较一下 CopyOnWrite 和读写锁。</p><p>相同点：</p><ol><li>两者都是通过读写分离的思想来实现的；</li><li>读线程间是互不阻塞的</li></ol><p>不同点：</p><p>为了实现数据实时性，在写锁被获取后，读线程会阻塞；或者当读锁被获取后，写线程会阻塞，从而解决“脏读”的问题。而 CopyOnWrite 对数据的更新是写时复制的，因此读线程是延时感知的，单不会存在阻塞的情况。</p><h1 id="吊打面试官之Java-ConcurrentLinkedQueue-二哥的Java进阶之路"><a href="#吊打面试官之Java-ConcurrentLinkedQueue-二哥的Java进阶之路" class="headerlink" title="[吊打面试官之Java ConcurrentLinkedQueue | 二哥的Java进阶之路]"></a>[吊打面试官之Java ConcurrentLinkedQueue | 二哥的Java进阶之路]</h1><p><a href="https://javabetter.cn/thread/ConcurrentLinkedQueue.html">https://javabetter.cn/thread/ConcurrentLinkedQueue.html</a></p><p>end？</p>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04Threadlocal和poll</title>
    <link href="/2025/11/13/04Threadlocal%E5%92%8Cpoll/"/>
    <url>/2025/11/13/04Threadlocal%E5%92%8Cpoll/</url>
    
    <content type="html"><![CDATA[<h1 id="Threadlocal是什么"><a href="#Threadlocal是什么" class="headerlink" title="Threadlocal是什么"></a>Threadlocal是什么</h1><p>ThreadLocal叫做<em><strong>线程变量</strong></em>，意思是ThreadLocal中*****填充的变量**<em><strong>属于</strong></em>当前线程***，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p><p><strong>线程安全问题的核心在于多个线程会对同一个临界区的共享资源进行访问</strong>，那如果每个线程都拥有自己的“共享资源”，各用各的，互不影响，这样就不会出现线程安全的问题了，对吧？</p><p>事实上，这就是一种“<strong>空间换时间</strong>”的思想，每个线程拥有自己的“共享资源”，虽然内存占用变大了，但由于不需要同步，也就减少了线程可能存在的阻塞问题，从而提高时间上的效率。</p><p>ThreadLocal 并不在 java.util.concurrent 并发包下，而是在 java.lang 包下，但我更倾向于把它当作是一种并发容器。顾名思义，<strong>ThreadLocal 就是线程的“本地变量”，即每个线程都拥有该变量的一个副本，达到人手一份的目的，这样就可以避免共享资源的竞争</strong>。</p><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><p>set 方法<br>set 方法用于设置当前线程中 ThreadLocal 的变量值，该方法的源码如下：</p><pre><code class="hljs">public void set(T value) &#123;//1. 获取当前线程实例对象    Thread t = Thread.currentThread();//2. 通过当前线程实例获取到ThreadLocalMap对象ThreadLocalMap map = getMap(t);if (map != null)   //3. 如果Map不为null,则以当前ThreadLocal实例为key,值为value进行存入   map.set(this, value);else  //4.map为null,则新建ThreadLocalMap并存入value  createMap(t, value);&#125;</code></pre><p>通过 Thread.currentThread() 方法获取当前调用此方法的线程实例。<br>每个线程都有自己的 ThreadLocalMap，这个映射表存储了线程的局部变量，其中键是 ThreadLocal 对象，值为特定于线程的对象。<br>如果 Map 不为 null，则以当前 ThreadLocal 实例为 key，值为 value 进行存入；如果 map 为 null，则新建 ThreadLocalMap 并存入 value。<br>通过源码我们知道，value 是存放在 ThreadLocalMap 里的。来看下 ThreadLocalMap 是什么，先有个简单的认识，后面会细讲。</p><p>ThreadLocalMap 是怎样来的呢？通过getMap(t)：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title class_">ThreadLocalMap</span> <span class="hljs-title function_">getMap</span>(<span class="hljs-params">Thread</span> <span class="hljs-params">t</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">t</span>.<span class="hljs-property">ThreadLocals</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法直接返回当前线程对象 t 的一个成员变量 ThreadLocals：</p><p>以当前 ThreadLocal 实例作为 key，值为 value 存放到 ThreadLocalMap 中，然后将当前线程对象的 ThreadLocals 赋值为 ThreadLocalMap 对象。</p><p>set 方法的重要性在于它确保了每个线程都有自己的变量副本。由于这些变量是存储在与线程关联的映射表中的，所以不同的线程之间的这些变量互不影响。</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap 是 ThreadLocal 类的静态内部类，它是一个定制的哈希表，专门用于保存每个线程中的线程局部变量。</p><p>和大多数容器一样，ThreadLocalMap 内部维护了一个 Entry 类型的数组 类型的数组 table，长度为 2 的幂次方。</p><p>Entry 继承了弱引用 <code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，它的 value 字段用于存储与特定 ThreadLocal 对象关联的值。使用弱引用作为键允许垃圾收集器在不再需要的情况下回收 ThreadLocal 实例。</p><h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><p>哈希表存储</p><p><strong>ThreadLocalMap 是使用开放地址法来处理哈希冲突的</strong>，和 HashMap 不同，之所以采用不同的方式主要是因为：</p><p>ThreadLocalMap 中的哈希值分散的比较均匀，很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象，冲突的概率就更小了。</p><h2 id="插入时"><a href="#插入时" class="headerlink" title="插入时"></a>插入时</h2><p>ThreadLocal 的 hashCode 是通过 <code>nextHashCode()</code> 方法获取的，该方法实际上是用 <a href="https://javabetter.cn/thread/atomic.html">AtomicInteger</a> 加上 0x61c88647 来实现的。</p><p>0x61c88647 是一个魔数，用于 ThreadLocal 的哈希码递增。这个值的选择并不是随机的，它是一个质数，具有以下特性：</p><ul><li>质数：它是一个质数，这意味着它不能被除 1 和它本身之外的任何数字整除。</li><li>黄金比例：这个数字大约等于黄金比例的 32 位浮点表示的一半。黄金比例具有一些有趣的数学特性，其中之一是与斐波那契数列的关系。</li><li>递增分布：在 ThreadLocal 中，这个数字用于在哈希表中分散不同线程的哈希码，从而减少冲突。每当创建新的 ThreadLocal 对象时，都会将此值添加到上一个 ThreadLocal 的哈希码中。这个递增的步长有助于在哈希表中均匀地分配 ThreadLocal 对象。</li><li>性能优化：通过使用这个特定的值，算法能够确保哈希码的均匀分布，从而减少哈希冲突的可能性。这对于哈希表的性能至关重要，因为冲突可能会降低查找的效率。</li></ul><h4 id="02、怎样确定新值插入的位置？"><a href="#02、怎样确定新值插入的位置？" class="headerlink" title="[02、怎样确定新值插入的位置？]"></a>[02、怎样确定新值插入的位置？]</h4><p>通过这行代码：<code>key.ThreadLocalHashCode &amp; (len-1)</code>。</p><p>同 <a href="https://javabetter.cn/collection/hashmap.html">HashMap</a> 一样，通过当前 key 的 hashcode 与哈希表大小相与。原理我们在 HashMap 的时候已经讲过了，不记得的小伙伴可以回去看一遍。</p><h4 id="03、怎样解决-hash-冲突？"><a href="#03、怎样解决-hash-冲突？" class="headerlink" title="[03、怎样解决 hash 冲突？]"></a>[03、怎样解决 hash 冲突？]</h4><p>通过 <code>nextIndex(i, len)</code>，该方法中的<code>((i + 1 &lt; len) ? i + 1 : 0);</code> 能不断往后线性探测，当到哈希表末尾的时候再从 0 开始，成环形。</p><h4 id="04、怎样解决“脏”Entry？"><a href="#04、怎样解决“脏”Entry？" class="headerlink" title="[04、怎样解决“脏”Entry？]"></a>[04、怎样解决“脏”Entry？]</h4><p>我们知道，使用 ThreadLocal 有可能存在内存泄漏的问题，针对这种 key 为 null 的 Entry，我们称之为“stale entry”，直译为不新鲜的 entry，我把它理解为“脏 entry”。</p><p>当然了，Josh Bloch 和 Doug Lea 已经替我们考虑了这种情况，源码中提供了这些解决方案：</p><p>在向ThreadLocalMap添加新条目时，可以检查是否有“脏”Entry（键为null的Entry），并用新的条目替换它。这就是源码中的replaceStaleEntry方法所做的事情。</p><h1 id="Key和value"><a href="#Key和value" class="headerlink" title="Key和value"></a>Key和value</h1><p><code>ThreadLocalMap</code> 的 <code>key</code> 和 <code>value</code> 引用机制：</p><ul><li><strong>key 是弱引用</strong>：<code>ThreadLocalMap</code> 中的 key 是 <code>ThreadLocal</code> 的弱引用 (<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>)。 这意味着，如果 <code>ThreadLocal</code> 实例不再被任何强引用指向，垃圾回收器会在下次 GC 时回收该实例，导致 <code>ThreadLocalMap</code> 中对应的 key 变为 <code>null</code>。</li><li><strong>value 是强引用</strong>：即使 <code>key</code> 被 GC 回收，<code>value</code> 仍然被 <code>ThreadLocalMap.Entry</code> 强引用存在，无法被 GC 回收。</li></ul><p>当 <code>ThreadLocal</code> 实例失去强引用后，其对应的 value 仍然存在于 <code>ThreadLocalMap</code> 中，因为 <code>Entry</code> 对象强引用了它。如果线程持续存活（例如线程池中的线程），<code>ThreadLocalMap</code> 也会一直存在，导致 key 为 <code>null</code> 的 entry 无法被垃圾回收，即会造成内存泄漏。</p><p><strong>也就是说，内存泄漏的发生需要同时满足两个条件：</strong></p><ol><li><strong><code>ThreadLocal</code> 实例不再被强引用；</strong></li><li>线程持续存活，导致 <code>ThreadLocalMap</code> 长期存在。导致 key 为 <code>null</code> 的 entry 无法被垃圾回收，即会造成内存泄漏。</li></ol><p>虽然 <code>ThreadLocalMap</code> 在 <code>get()</code>, <code>set()</code> 和 <code>remove()</code> 操作时会尝试清理 key 为 null 的 entry，但这种清理机制是被动的，并不完全可靠。</p><h2 id="如何避免内存泄漏的发生？"><a href="#如何避免内存泄漏的发生？" class="headerlink" title="如何避免内存泄漏的发生？"></a><strong>如何避免内存泄漏的发生？</strong></h2><ol><li>在使用完 <code>ThreadLocal</code> 后，务必调用 <code>remove()</code> 方法。 这是最安全和最推荐的做法。 <code>remove()</code> 方法会从 <code>ThreadLocalMap</code> 中显式地移除对应的 entry，彻底解决内存泄漏的风险。 即使将 <code>ThreadLocal</code> 定义为 <code>static final</code>，也强烈建议在每次使用后调用 <code>remove()</code>。</li><li>在线程池等线程复用的场景下，使用 <code>try-finally</code> 块可以确保即使发生异常，<code>remove()</code> 方法也一定会被执行。</li></ol><h2 id="为什么ThreadLocal的key必须是弱引用？——详细解释"><a href="#为什么ThreadLocal的key必须是弱引用？——详细解释" class="headerlink" title="为什么ThreadLocal的key必须是弱引用？——详细解释"></a>为什么ThreadLocal的key必须是弱引用？——详细解释</h2><p>核心问题：为什么<code>tl = null</code>后ThreadLocal实例无法被回收？</p><p><strong>关键点</strong>：当<code>tl = null</code>后，<strong>ThreadLocalMap仍然持有对ThreadLocal实例的强引用</strong>，导致GC无法回收它。</p><h3 id="场景分析（key是强引用的情况）"><a href="#场景分析（key是强引用的情况）" class="headerlink" title="场景分析（key是强引用的情况）"></a>场景分析（key是强引用的情况）</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">ThreadLocal&lt;<span class="hljs-built_in">String</span>&gt; tl = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;(); <span class="hljs-comment">// 创建ThreadLocal实例</span><br>tl.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// ThreadLocalMap存储：key = tl（强引用），value = &quot;hello&quot;</span><br>tl = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 外部引用被置为null</span><br></code></pre></td></tr></table></figure><ol><li><strong>初始状态</strong>：<ul><li><code>tl</code>是一个强引用，指向ThreadLocal实例</li><li>ThreadLocalMap（属于当前线程）中存储了一个Entry：<code>key = tl</code>（强引用），<code>value = &quot;hello&quot;</code></li></ul></li><li><strong><code>tl = null</code>后</strong>：<ul><li>外部代码不再持有对ThreadLocal实例的强引用</li><li>但<strong>ThreadLocalMap仍然持有对ThreadLocal实例的强引用</strong></li><li>因为key是强引用，所以ThreadLocalMap对ThreadLocal实例的引用是强引用</li></ul></li><li><strong>GC行为</strong>：<ul><li>GC会检查所有对象的引用</li><li>ThreadLocal实例被ThreadLocalMap强引用，所以不会被回收</li><li>ThreadLocal实例内存泄漏：一直占用内存</li></ul></li></ol><h3 id="为什么这样会导致内存泄漏？"><a href="#为什么这样会导致内存泄漏？" class="headerlink" title="为什么这样会导致内存泄漏？"></a>为什么这样会导致内存泄漏？</h3><p>想象一下：</p><ul><li>你创建了一个ThreadLocal实例，然后将其设置为null</li><li>但ThreadLocalMap（属于线程）仍然”抓着”这个实例不放</li><li>线程可能长期存活（如线程池中的线程）</li><li>这个ThreadLocal实例会一直占用内存，直到线程结束</li></ul><h3 id="对比：key是弱引用的情况"><a href="#对比：key是弱引用的情况" class="headerlink" title="对比：key是弱引用的情况"></a>对比：key是弱引用的情况</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">ThreadLocal&lt;<span class="hljs-built_in">String</span>&gt; tl = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;(); <span class="hljs-comment">// 创建ThreadLocal实例</span><br>tl.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// ThreadLocalMap存储：key = tl（弱引用），value = &quot;hello&quot;</span><br>tl = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 外部引用被置为null</span><br></code></pre></td></tr></table></figure><ol><li><strong><code>tl = null</code>后</strong>：<ul><li>外部代码不再持有对ThreadLocal实例的强引用（运行完栈不再指向队中的ThreadLocal实例）</li><li>ThreadLocalMap中key是弱引用，所以ThreadLocalMap对ThreadLocal实例的引用是弱引用</li></ul></li><li><strong>GC行为</strong>：<ul><li>GC会回收ThreadLocal实例（因为没有强引用）</li><li>ThreadLocalMap中的key会变成null</li><li>为后续清理提供机会</li></ul></li></ol><h3 id="为什么”ThreadLocalMap仍然持有对tl的强引用”会导致问题？"><a href="#为什么”ThreadLocalMap仍然持有对tl的强引用”会导致问题？" class="headerlink" title="为什么”ThreadLocalMap仍然持有对tl的强引用”会导致问题？"></a>为什么”ThreadLocalMap仍然持有对tl的强引用”会导致问题？</h3><p>这是理解的关键：</p><ul><li><strong>ThreadLocalMap是Thread的一部分</strong>，而Thread通常不会很快结束（特别是线程池中的线程）</li><li><strong>ThreadLocalMap的生命周期与Thread相同</strong>，线程存活，ThreadLocalMap就存活</li><li><strong>当key是强引用时，ThreadLocalMap对ThreadLocal实例的引用阻止了GC回收</strong></li></ul><h3 id="为什么不能让ThreadLocalMap的key是弱引用，value是弱引用？"><a href="#为什么不能让ThreadLocalMap的key是弱引用，value是弱引用？" class="headerlink" title="为什么不能让ThreadLocalMap的key是弱引用，value是弱引用？"></a>为什么不能让ThreadLocalMap的key是弱引用，value是弱引用？</h3><ul><li>如果value也是弱引用，那么即使ThreadLocal实例还在，value也可能被GC提前回收</li><li>这违背了ThreadLocal的设计目标：<strong>只要线程还活着，就应该能获取到存储的值</strong></li><li>例如：<code>String value = tl.get()</code> 可能返回null，即使之前set过</li></ul><hr><h2 id="🔍-为什么必须static？（用生活案例讲透）"><a href="#🔍-为什么必须static？（用生活案例讲透）" class="headerlink" title="🔍 为什么必须static？（用生活案例讲透）"></a>🔍 为什么必须static？（用生活案例讲透）</h2><p>✅ 一句话核心结论（面试必答）</p><blockquote><p><strong>“ThreadLocal实例（如<code>ThreadLocal&lt;String&gt; threadLocal</code>）必须设为static，</strong><br> <strong>因为它是’线程局部变量的管理器’，需要被所有线程共享——</strong><br> <strong>只有static才能保证：</strong><br> <strong>1. 所有线程用同一个’推车池’</strong><br> <strong>2. 避免重复创建对象（内存浪费）</strong><br> <strong>3. 确保线程安全（不互相干扰）！”</strong> 🔑</p></blockquote><h3 id="❌-误区：把ThreadLocal当普通变量"><a href="#❌-误区：把ThreadLocal当普通变量" class="headerlink" title="❌ 误区：把ThreadLocal当普通变量"></a>❌ 误区：把<code>ThreadLocal</code>当普通变量</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserContext</span> &#123;<br>    <span class="hljs-comment">// 错误！非static的ThreadLocal</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">ThreadLocal</span>&lt;<span class="hljs-title class_">String</span>&gt; user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;(); <span class="hljs-comment">// 每个UserContext实例独立</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setUser</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> name</span>) &#123;<br>        user.<span class="hljs-title function_">set</span>(name); <span class="hljs-comment">// 每个UserContext实例有自己的&#x27;推车&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>问题</p><p>：当多个线程共享同一个</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">UserContext</span><br></code></pre></td></tr></table></figure><p>实例时：</p><ul><li>线程A：<code>context.setUser(&quot;Tom&quot;)</code> → Tom存入线程A的推车</li><li>线程B：<code>context.setUser(&quot;Jerry&quot;)</code> → Jerry存入<strong>同一个</strong>推车？<br><strong>→ 实际上，因为<code>user</code>是实例变量，线程B的<code>user</code>指向的是</strong><code>context</code>的<strong>另一个推车</strong>！</li></ul></li><li><p><strong>结果</strong>：线程A和B的值互相覆盖，<strong>并发崩溃！</strong></p></li></ul><h3 id="✅-正确做法：ThreadLocal实例必须static"><a href="#✅-正确做法：ThreadLocal实例必须static" class="headerlink" title="✅ 正确做法：ThreadLocal实例必须static"></a>✅ 正确做法：ThreadLocal实例必须static</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserContext</span> &#123;<br>    <span class="hljs-comment">// 正确！static的ThreadLocal（推车池）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">ThreadLocal</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-variable constant_">USER</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setUser</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> name</span>) &#123;<br>        <span class="hljs-variable constant_">USER</span>.<span class="hljs-title function_">set</span>(name); <span class="hljs-comment">// 所有线程都用同一个推车池</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">USER</span>.<span class="hljs-title function_">get</span>(); <span class="hljs-comment">// 每个线程取自己的推车</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>运作原理</p><p>：</p><ol><li><code>USER</code>是类级别的<strong>单例</strong>（所有线程共享同一个ThreadLocal对象）。</li><li>线程A调用<code>USER.set(&quot;Tom&quot;)</code> → Tom存入<strong>线程A的槽位</strong>。</li><li>线程B调用<code>USER.set(&quot;Jerry&quot;)</code> → Jerry存入<strong>线程B的槽位</strong>。</li><li><strong>互不干扰</strong>！线程A永远看不到Jerry。</li></ol></li></ul><blockquote><p>💡 <strong>类比</strong>：<br> <strong>“ThreadLocal实例 &#x3D; 便利店的’推车池’（static）</strong><br> <strong>线程 &#x3D; 顾客</strong><br> <strong>值（Tom&#x2F;Jerry）&#x3D; 顾客的购物车内容</strong><br> <strong>—— 推车池固定（static），顾客取车用（set），放回车（get），</strong><br> <strong>谁也抢不到别人的车！”</strong> 🛒</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>核心原因</strong>：ThreadLocal的key必须是弱引用，是为了确保当外部代码不再需要ThreadLocal实例时，ThreadLocal实例可以被GC回收，避免内存泄漏。</p><p><strong>为什么”tl无法被GC回收”</strong>：因为ThreadLocalMap（属于线程）对ThreadLocal实例的引用是强引用，阻止了GC回收。</p><blockquote><p>💡 <strong>重要提示</strong>：即使key是弱引用，ThreadLocal的value仍然是强引用，如果忘记调用<code>remove()</code>，value仍然会泄漏。所以，<strong>正确使用ThreadLocal的关键是：使用完后调用<code>remove()</code></strong>。</p></blockquote><h1 id="Threadpool"><a href="#Threadpool" class="headerlink" title="Threadpool"></a>Threadpool</h1><h2 id="一、什么是线程池"><a href="#一、什么是线程池" class="headerlink" title="一、什么是线程池"></a>一、什么是线程池</h2><p>线程池其实是一种池化的技术实现，池化技术的核心思想就是实现资源的复用，避免资源的重复创建和销毁带来的性能开销。线程池可以管理一堆线程，让线程执行完任务之后不进行销毁，而是继续去处理其它线程已经提交的任务。</p><p>使用线程池的好处</p><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><p><img src="/./../img/image-20251119220659721.png" alt="image-20251119220659721"></p><h2 id="二、线程池的构造"><a href="#二、线程池的构造" class="headerlink" title="二、线程池的构造"></a>二、线程池的构造</h2><p>Java 主要是通过构建 ThreadPoolExecutor 来创建线程池的。</p><ul><li>corePoolSize：线程池中用来工作的核心线程数量。</li><li>maximumPoolSize：最大线程数，线程池允许创建的最大线程数。</li><li>keepAliveTime：超出 corePoolSize 后创建的线程存活时间或者是所有线程最大存活时间，取决于配置。</li><li>unit：keepAliveTime 的时间单位。</li><li>workQueue：任务队列，是一个阻塞队列，当线程数达到核心线程数后，会将任务存储在阻塞队列中。</li><li>threadFactory ：线程池内部创建线程所用的工厂。</li><li>handler：拒绝策略；当队列已满并且线程数量达到最大线程数量时，会调用该方法处理任务。</li></ul><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><img src="/./../img/02ede02b26c85d797a995abf520e08b5.png" alt="img">线程池的工作机制是：<strong>当当前活动线程数小于corePoolSize时，即使有空闲线程，线程池也会创建新的线程来处理任务。</strong></p><h2 id="线程池中线程实现复用的原理"><a href="#线程池中线程实现复用的原理" class="headerlink" title="线程池中线程实现复用的原理"></a>线程池中线程实现复用的原理</h2><p>线程池的核心功能就是实现线程的重复利用，那么线程池是如何实现线程的复用呢？</p><p>线程在线程池内部其实被封装成了一个 Worker 对象</p><p>runWorker 内部使用了 while 死循环，当第一个任务执行完之后，会不断地通过 getTask 方法获取任务，只要能获取到任务，就会调用 run 方法继续执行任务，这就是线程能够复用的主要原因。</p><p>但是如果从 getTask 获取不到方法的话，就会调用 finally 中的 processWorkerExit 方法，将线程退出。</p><p>这里有个一个细节就是，因为 Worker 继承了 AQS，每次在执行任务之前都会调用 Worker 的 lock 方法，执行完任务之后，会调用 unlock 方法，这样做的目的就可以通过 Woker 的加锁状态判断出当前线程是否正在执行任务。</p><p>如果想知道线程是否正在执行任务，只需要调用 Woker 的 tryLock 方法，根据是否加锁成功就能判断，加锁成功说明当前线程没有加锁，也就没有执行任务了，在调用 shutdown 方法关闭线程池的时候，就时用这种方式来判断线程有没有在执行任务，如果没有的话，会尝试打断没有执行任务的线程。</p><h2 id="线程是如何获取任务以及如何实现超时的"><a href="#线程是如何获取任务以及如何实现超时的" class="headerlink" title="线程是如何获取任务以及如何实现超时的"></a>线程是如何获取任务以及如何实现超时的</h2><p><img src="/./../img/14e547adfd9dfea589e2e0141ff52718.png" alt="img"></p><h2 id="线程池的-5-种状态"><a href="#线程池的-5-种状态" class="headerlink" title="线程池的 5 种状态"></a>线程池的 5 种状态</h2><p>线程池内部有 5 个常量来代表线程池的五种状态</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> RUNNING    = <span class="hljs-number">-1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><ul><li>RUNNING：线程池创建时就是这个状态，能够接收新任务，以及对已添加的任务进行处理。</li><li>SHUTDOWN：调用 shutdown 方法，线程池就会转换成 SHUTDOWN 状态，此时线程池不再接收新任务，但能继续处理已添加的任务到队列中。</li><li>STOP：调用 shutdownNow 方法，线程池就会转换成 STOP 状态，不接收新任务，也不能继续处理已添加的任务到队列中任务，并且会尝试中断正在处理的任务的线程。</li><li>TIDYING：SHUTDOWN 状态下，任务数为 0， 其他所有任务已终止，线程池会变为 TIDYING 状态；线程池在 SHUTDOWN 状态，任务队列为空且执行中任务为空，线程池会变为 TIDYING 状态；线程池在 STOP 状态，线程池中执行中任务为空时，线程池会变为 TIDYING 状态。</li><li>TERMINATED：线程池彻底终止。线程池在 TIDYING 状态执行完 <code>terminated()</code> 方法就会转变为 TERMINATED 状态。</li></ul><p>线程池状态具体是存在 ctl 成员变量中的，ctl 中不仅存储了线程池的状态还存储了当前线程池中线程数的大小</p><p>所以也可以看出 shutdown 方法和 shutdownNow 方法的主要区别就是，shutdown 之后还能处理在队列中的任务，shutdownNow 直接就将任务从队列中移除，线程池里的线程就不再处理了。</p><h2 id="Executors-构建线程池以及问题分析"><a href="#Executors-构建线程池以及问题分析" class="headerlink" title="Executors 构建线程池以及问题分析"></a>Executors 构建线程池以及问题分析</h2><p>虽然 JDK 提供了快速创建线程池的方法，但其实不推荐使用 Executors 来创建线程池。</p><p>Executors 返回线程池对象的弊端如下(后文会详细介绍到)：</p><p>FixedThreadPool 和 SingleThreadExecutor:使用的是阻塞队列 LinkedBlockingQueue，任务队列最大长度为 Integer.MAX_VALUE，可以看作是无界的，可能堆积大量的请求，从而导致 OOM。</p><p>CachedThreadPool:使用的是同步队列 SynchronousQueue, 允许创建的线程数量为 Integer.MAX_VALUE ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</p><p>ScheduledThreadPool 和 SingleThreadScheduledExecutor:使用的无界的延迟阻塞队列DelayedWorkQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</p><h2 id="回收核心吗？"><a href="#回收核心吗？" class="headerlink" title="回收核心吗？"></a>回收核心吗？</h2><p><code>ThreadPoolExecutor</code> 默认不会回收核心线程，即使它们已经空闲了。这是为了减少创建线程的开销，因为核心线程通常是要长期保持活跃的。但是，如果线程池是被用于周期性使用的场景，且频率不高（周期之间有明显的空闲时间），可以考虑将 <code>allowCoreThreadTimeOut(boolean value)</code> 方法的参数设置为 <code>true</code>，这样就会回收空闲（时间间隔由 <code>keepAliveTime</code> 指定）的核心线程了</p><h2 id="线程池的拒绝策略有哪些？"><a href="#线程池的拒绝策略有哪些？" class="headerlink" title="线程池的拒绝策略有哪些？"></a>线程池的拒绝策略有哪些？</h2><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolExecutor</code> 定义一些策略:</p><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：调用执行者自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果你的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li></ul><p>不过，如果走到<code>CallerRunsPolicy</code>的任务是个非常耗时的任务，且处理提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。</p><ul><li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：此策略将丢弃最早的未处理的任务请求。</li></ul><h2 id="线程池中线程异常后，销毁还是复用？"><a href="#线程池中线程异常后，销毁还是复用？" class="headerlink" title="线程池中线程异常后，销毁还是复用？"></a>线程池中线程异常后，销毁还是复用？</h2><p>直接说结论，需要分两种情况：</p><p>使用execute()提交任务：</p><p>​当任务通过execute()提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么该异常会导致当前线程终止，并且异常会被打印到控制台或日志文件中。线程池会检测到这种线程终止，并创建一个新线程来替换它，从而保持配置的线程数不变。</p><p>使用submit()提交任务：</p><p>​对于通过submit()提交的任务，如果在任务执行中发生异常，这个异常不会直接打印出来。相反，异常会被封装在由submit()返回的Future对象中。当调用Future.get()方法时，可以捕获到一个ExecutionException。在这种情况下，线程不会因为异常而终止，它会继续存在于线程池中，准备执行后续的任务。</p><p>简单来说：使用execute()时，未捕获异常导致线程终止，线程池创建新线程替代；使用submit()时，异常被封装在Future中，线程继续复用。这种设计允许submit()提供更灵活的错误处理机制，因为它允许调用者决定如何处理异常，而execute()则适用于那些不需要关注执行结果的场景。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>end</p><p>?</p>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发容器</title>
    <link href="/2025/11/13/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <url>/2025/11/13/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="a简介"><a href="#a简介" class="headerlink" title="a简介"></a>a简介</h1><p>java.util 包下提供了一些容器类（集合框架），其中 Vector 和 Hashtable 是线程安全的，但实现方式比较粗暴，通过在方法上加「sychronized」关键字实现。</p><p>但即便是 Vector 这样线程安全的类，在应对多线程的复合操作时也需要在客户端继续加锁以保证原子性。</p><p><img src="/./../img/map-a6a020a3-4573-4cf8-b5ae-1541ae45801c-1763002801695-3.png" alt="img"></p><p>。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a><a href="https://javabetter.cn/thread/map.html#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">阻塞队列</a></h2><p>我们假设一种场景，<a href="https://javabetter.cn/thread/shengchanzhe-xiaofeizhe.html">生产者一直生产资源，消费者一直消费资源</a>（后面会细讲，戳链接直达），资源存储在一个缓冲池中，生产者将生产的资源存进缓冲池中，消费者从缓冲池中拿到资源进行消费，这就是大名鼎鼎的<strong>生产者-消费者模式</strong>。</p><p>该模式能够简化开发过程，一方面消除了生产者类与消费者类之间的代码依赖性，另一方面将生产数据的过程与使用数据的过程解耦简化负载。</p><p>我们自己 coding 实现这个模式的时候，因为需要让<strong>多个线程操作共享变量</strong>（即资源），所以很容易引发<strong>线程安全问题</strong>，造成<strong>重复消费</strong>和<strong>死锁</strong>，尤其是生产者和消费者存在多个的情况。另外，当缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者，这些个<strong>等待-唤醒</strong>逻辑都需要自己实现。</p><p>这么容易出错的事情，JDK 当然帮我们做啦，这就是阻塞队列（BlockingQueue），<strong>你只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。</strong></p><blockquote><p>BlockingQueue 是 Java util.concurrent 包下重要的数据结构，区别于普通的队列，BlockingQueue 提供了<strong>线程安全的队列访问方式</strong>，并发包下很多高级同步类的实现都是基于 BlockingQueue 实现的。</p></blockquote><p>BlockingQueue 一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。<strong>BlockingQueue 就是存放元素的容器</strong>。</p><h3 id="BlockingQueue-的操作方法"><a href="#BlockingQueue-的操作方法" class="headerlink" title="BlockingQueue 的操作方法"></a><a href="https://javabetter.cn/thread/map.html#blockingqueue-%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95">BlockingQueue 的操作方法</a></h3><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p><table><thead><tr><th align="center">方法\处理方式</th><th align="center">抛出异常</th><th align="center">返回特殊值</th><th align="center">一直阻塞</th><th align="center">超时退出</th></tr></thead><tbody><tr><td align="center">插入方法</td><td align="center">add(e)</td><td align="center">offer(e)</td><td align="center"><strong>put(e)</strong></td><td align="center">offer(e,time,unit)</td></tr><tr><td align="center">移除方法</td><td align="center">remove()</td><td align="center">poll()</td><td align="center"><strong>take()</strong></td><td align="center">poll(time,unit)</td></tr><tr><td align="center">检查方法</td><td align="center">element()</td><td align="center">peek()</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><ul><li>抛出异常：如果操作无法立即执行，会抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出 <code>IllegalStateException(“Queue full”)</code>异常。当队列为空时，从队列里获取元素时会抛出 NoSuchElementException 异常 。</li><li>返回特殊值：如果操作无法立即执行，会返回一个特殊值，通常是 true &#x2F; false。</li><li>一直阻塞：如果操作无法立即执行，则一直阻塞或者响应中断。</li><li>超时退出：如果操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true &#x2F; false。</li></ul><p><strong>注意：</strong></p><ul><li>不能往阻塞队列中插入 null，会抛出空指针异常。</li><li>可以访问阻塞队列中的任意元素，调用 <code>remove(o)</code>可以将队列之中的特定对象移除，但并不高效，尽量避免使用。</li></ul><p>我们会在后面单独开一篇<a href="https://javabetter.cn/thread/BlockingQueue.html">BlockingQueue</a>来细讲，戳链接直达。</p><h3 id="BlockingQueue-的实现类"><a href="#BlockingQueue-的实现类" class="headerlink" title="BlockingQueue 的实现类"></a><a href="https://javabetter.cn/thread/map.html#blockingqueue-%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB">BlockingQueue 的实现类</a></h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><a href="https://javabetter.cn/thread/map.html#arrayblockingqueue">ArrayBlockingQueue</a></h4><p>由<strong>数组</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是数组，具有数组的特性。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span></span>&#123;<br> <span class="hljs-comment">//..省略代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以初始化队列大小，一旦初始化将不能改变。构造方法中的 fair 表示控制对象的内部锁是否采用公平锁，默认是<strong>非公平锁</strong>。</p><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><a href="https://javabetter.cn/thread/map.html#linkedblockingqueue">LinkedBlockingQueue</a></h4><p>由<strong>链表</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是链表，具有链表的特性。默认队列的大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。此队列按照<strong>先进先出</strong>的原则对元素进行排序。</p><h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a><a href="https://javabetter.cn/thread/map.html#delayqueue">DelayQueue</a></h4><p>该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。注入其中的元素必须实现 <code>java.util.concurrent.Delayed</code> 接口。</p><p>DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><a href="https://javabetter.cn/thread/map.html#priorityblockingqueue">PriorityBlockingQueue</a></h4><p>基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的 Compator 对象来决定），内部控制线程同步的锁采用的是非公平锁。</p><blockquote><p>网上大部分博客上<strong>PriorityBlockingQueue</strong>为公平锁，其实是不对的，查阅源码（感谢 github:<strong>ambition0802</strong>同学的指出）：</p></blockquote><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriorityBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; comparator)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.lock = <span class="hljs-keyword">new</span> ReentrantLock(); <span class="hljs-comment">//默认构造方法-非公平锁</span><br>    ...<span class="hljs-comment">//其余代码略</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a><a href="https://javabetter.cn/thread/map.html#synchronousqueue">SynchronousQueue</a></h4><p>这个队列比较特殊，<strong>没有任何内部容量</strong>，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然。</p><p>需要区别容量为 1 的 ArrayBlockingQueue、LinkedBlockingQueue。</p><p>以下方法的返回值，可以帮助理解这个队列：</p><ul><li><code>iterator()</code> 永远返回空，因为里面没有东西</li><li><code>peek()</code> 永远返回 null</li><li><code>put()</code> 往 queue 放进去一个 element 以后就一直 wait 直到有其他 thread 进来把这个 element 取走。</li><li><code>offer()</code> 往 queue 里放一个 element 后立即返回，如果碰巧这个 element 被另一个 thread 取走了，offer 方法返回 true，认为 offer 成功；否则返回 false。</li><li><code>take()</code> 取出并且 remove 掉 queue 里的 element，取不到东西他会一直等。</li><li><code>poll()</code> 取出并且 remove 掉 queue 里的 element，只有到碰巧另外一个线程正在往 queue 里 offer 数据或者 put 数据的时候，该方法才会取到东西。否则立即返回 null。</li><li><code>isEmpty()</code> 永远返回 true</li><li><code>remove()&amp;removeAll()</code> 永远返回 false</li></ul><p><strong>注意</strong></p><p><strong>PriorityBlockingQueue</strong>不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时阻塞数据的消费者。因此使用的时候要特别注意，**生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。**对于使用默认大小的**LinkedBlockingQueue**也是一样的。</p><h1 id="w"><a href="#w" class="headerlink" title="w"></a>w</h1>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列的API</title>
    <link href="/2025/11/13/%E6%9E%81%E5%85%B6%E9%87%8D%E8%A6%81API/"/>
    <url>/2025/11/13/%E6%9E%81%E5%85%B6%E9%87%8D%E8%A6%81API/</url>
    
    <content type="html"><![CDATA[<h1 id="a一对儿"><a href="#a一对儿" class="headerlink" title="a一对儿"></a>a一对儿</h1><p>比如“添加”操作可以用的方法有：<code>add/offer/push/offerFirst/offerLast</code>，“删除”操作可以用的方法有：<code>remove/pop/poll/pollFirst/pollLast</code>。</p><p>经过一番学习和测试以后，得出以下结论：这些方法从设计之初，分别来自于集合Collections，队列Queue，栈Stack，双端队列Deque，因此它们是有语义的，不建议笼统归为添加&#x2F;删除。</p><ul><li><code>add</code>和<code>remove</code>是一对，源自<code>Collection</code>；</li><li><code>offer</code>和<code>poll</code>是一对，源自<code>Queue</code>；</li><li><code>push</code>和<code>pop</code>是一对，源自<code>Deque</code>，其本质是栈（<code>Stack</code>类由于某些历史原因，官方已不建议使用，使用<code>Deque</code>代替）；</li><li><code>offerFirst/offerLast</code>和<code>pollFirst/pollLast</code>是一对，源自<code>Deque</code>，其本质是双端队列。</li></ul><p>那为什么这些方法，全都出现在<code>LinkedList/Deque</code>中呢，那是由它们的继承关系导致的，请看下图。</p><p><img src="/./../img/webp.webp" alt="img"></p><p>关注圈住的部分，接口<code>Deque</code>继承了以上所有的方法，而类<code>LinkedList</code>实现了以上所有的方法。<br><em>注：由于历史原因，在Java中，官方不建议使用Stack类，而是使用<code>Deque</code>代替，也就是说，接口<code>Deque</code>是栈和双端队列这两种数据结构的集合体。</em></p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>说了这么多，这一堆方法到底有什么区别？其实从他们的出处便可以快速区分并且牢记他们的不同之处。</p><ul><li><code>add/remove</code>源自集合，所以添加到队尾，从队头删除；</li><li><code>offer/poll</code>源自队列（先进先出 &#x3D;&gt; 尾进头出），所以添加到队尾，从队头删除；</li><li><code>push/pop</code>源自栈（先进后出 &#x3D;&gt; 头进头出），所以添加到队头，从队头删除；</li><li><code>offerFirst/offerLast/pollFirst/pollLast</code>源自双端队列（两端都可以进也都可以出），根据字面意思，<code>offerFirst</code>添加到队头，<code>offerLast</code>添加到队尾，<code>pollFirst</code>从队头删除，<code>pollLast</code>从队尾删除。<br>总结：</li><li><code>add/offer/offerLast</code>添加队尾，三个方法等价；</li><li><code>push/offerFirst</code>添加队头，两个方法等价。</li><li><code>remove/pop/poll/pollFirst</code>删除队头，四个方法等价；</li><li><code>pollLast</code>删除队尾。</li></ul><p>虽说某几个方法等价，但是我们在使用的时候，<strong>建议根据用途来使用不同的方法</strong>，比如你想把<code>LinkedList</code>当做集合<code>list</code>，那么应该用<code>add/remove</code>，如果想用作队列，则使用<code>offer/poll</code>，如果用作栈，则使用<code>push/pop</code>，如果用作双端队列，则使用<code>offerFirst/offerLast/pollFirst/pollLast</code>。根据语义使用，就不会发生：我想删队尾，结果删了队头这种事了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02各种问题</title>
    <link href="/2025/11/13/02Condition%E5%92%8Csupport/"/>
    <url>/2025/11/13/02Condition%E5%92%8Csupport/</url>
    
    <content type="html"><![CDATA[<h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><ol><li>调用 condition.await 方法后线程依次尾插入到了等待队列中，依次为 Thread-0,Thread-1,Thread-2….Thread-8；</li><li>等待队列是一个单向队列。示意图如下：</li></ol><p><img src="/./../img/condition-02.png" alt="等待队列的示意图">等待队列的示意图</p><p>同时还有一点需要注意：我们可以多次调用<code>newCondition()</code>方法创建多个 Condition 对象，也就是一个 lock 可以持有多个等待队列。</p><p>而如果是 Object 方式的话，就只能有一个同步队列和一个等待队列。</p><p>因此，ReentrantLock 等 AQS 是可以持有一个同步队列和多个等待队列的，new 多个 Condition 就行了。示意图如下：</p><p><img src="/./../img/condition-03.png" alt="AQS持有多个Condition"></p><h1 id="locksupport"><a href="#locksupport" class="headerlink" title="locksupport"></a>locksupport</h1><p>LockSupprot 用来阻塞和唤醒线程，底层实现依赖于 [Unsafe 类]（后面会细讲）。</p><p>该类包含一组用于阻塞和唤醒线程的静态方法，这些方法主要是围绕 park 和 unpark 展开，</p><h2 id="阻塞线程"><a href="#阻塞线程" class="headerlink" title="阻塞线程"></a>阻塞线程</h2><p>void park()：阻塞当前线程，如果调用 unpark 方法或线程被中断，则该线程将变得可运行。请注意，park 不会抛出 InterruptedException，因此线程必须单独检查其中断状态。<br>void park(Object blocker)：功能同方法 1，入参增加一个 Object 对象，用来记录导致线程阻塞的对象，方便问题排查。<br>void parkNanos(long nanos)：阻塞当前线程一定的纳秒时间，或直到被 unpark 调用，或线程被中断。<br>void parkNanos(Object blocker, long nanos)：功能同方法 3，入参增加一个 Object 对象，用来记录导致线程阻塞的对象，方便问题排查。<br>void parkUntil(long deadline)：阻塞当前线程直到某个指定的截止时间（以毫秒为单位），或直到被 unpark 调用，或线程被中断。<br>void parkUntil(Object blocker, long deadline)：功能同方法 5，入参增加一个 Object 对象，用来记录导致线程阻塞的对象，方便问题排查。</p><h3 id="唤醒线程"><a href="#唤醒线程" class="headerlink" title="唤醒线程"></a>唤醒线程</h3><p>void unpark(Thread thread)：唤醒一个由 park 方法阻塞的线程。如果该线程未被阻塞，那么下一次调用 park 时将立即返回。这允许“先发制人”式的唤醒机制。</p><p>实际上，LockSupport 阻塞和唤醒线程的功能依赖于 sun.misc.Unsafe，这是一个很底层的类，后面这篇文章会细讲，比如 LockSupport 的 park 方法是通过 unsafe.park() 方法实现的。</p><h3 id="什么是公平锁和非公平锁？"><a href="#什么是公平锁和非公平锁？" class="headerlink" title="什么是公平锁和非公平锁？"></a>什么是公平锁和非公平锁？</h3><ul><li><strong>公平锁：</strong> 指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点在于各个线程公平平等，每个线程等待一段时间后，都有执行的机会，而它的缺点就在于整体执行速度更慢，吞吐量更小。</li><li><strong>非公平锁：</strong> 多个线程加锁时直接尝试获取锁，能抢到锁到直接占有锁，抢不到才会到等待队列的队尾等待。非公平锁的优势就在于整体执行速度更快，吞吐量更大，但同时也可能产生线程饥饿问题，也就是说如果一直有线程插队，那么在等待队列中的线程可能长时间得不到运行。</li></ul><h2 id="非公平锁吞吐量为什么比公平锁大？"><a href="#非公平锁吞吐量为什么比公平锁大？" class="headerlink" title="非公平锁吞吐量为什么比公平锁大？"></a>非公平锁吞吐量为什么比公平锁大？</h2><ul><li><strong>公平锁执行流程</strong>：获取锁时，先将线程自己添加到等待队列的队尾并休眠，当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁，锁的使用顺序也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。</li><li><strong>非公平锁执行流程</strong>：当线程获取锁时，会先通过 CAS 尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入等待队列，等待下次尝试获取锁。这样做的好处是，获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率。</li></ul><h3 id="什么情况会产生死锁问题？如何解决？"><a href="#什么情况会产生死锁问题？如何解决？" class="headerlink" title="什么情况会产生死锁问题？如何解决？"></a>什么情况会产生死锁问题？如何解决？</h3><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p><ul><li>互斥条件：互斥条件是指<strong>多个线程不能同时使用同一个资源</strong>。</li><li>持有并等待条件：持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是<strong>线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</strong>。</li><li>不可剥夺条件：不可剥夺条件是指，当线程已经持有了资源 ，<strong>在自己使用完之前不能被其他线程获取</strong>，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。</li><li>环路等待条件：环路等待条件指的是，在死锁发生的时候，<strong>两个线程获取资源的顺序构成了环形链</strong>。</li></ul><p>避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>。</p><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01CASAQSLOCK</title>
    <link href="/2025/11/13/01CAS,AQS,lock/"/>
    <url>/2025/11/13/01CAS,AQS,lock/</url>
    
    <content type="html"><![CDATA[<h1 id="隐式锁-synchronized"><a href="#隐式锁-synchronized" class="headerlink" title="隐式锁(synchronized)"></a>隐式锁(synchronized)</h1><p>java中的锁包含了内部锁和显示锁。内部锁是通过synchronized关键字实现的 ;显示锁是通过Lock接口来进行实现。</p><p><strong>synchronized概述</strong></p><p>特点：</p><p>1、synchronized关键字可以用来修饰方法(静态和非静态)和代码块。</p><p>2、被synchronized修饰的方法被称之为同步方法，被synchronized修饰的代码块被称之同步代码块。</p><p>3、同步方法整个方法体都是临界区。同步代码块中所包裹的代码是临界区。</p><p><strong>同步代码块的格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (对象) &#123;<br>    <br>    <span class="hljs-comment">// 在此代码块中访问共享数据</span><br>&#125;<br><br>该对象可以是任意的对象，这个对象可以简单的理解就是一把锁：但是需要保证多个线程在访问的时候使用的是同一个对象(但是这个对象本质上不是一个锁，专业的术语将其称之为<span class="hljs-string">&quot;监视器&quot;</span>(摄像头))<br></code></pre></td></tr></table></figure><h2 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a><strong>synchronized原理</strong></h2><p><strong>synchronized同步代码块的情况</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;synchronized&quot;</span>);<br>        &#125;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>通过javap查看字节码文件信息，如下所示：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">javap -c SynchronizedDemo.class<br></code></pre></td></tr></table></figure><p>Java虚拟机包含了一个很实用的命令javap，该命令可以反编译已经编译过的Java Class文件，输出该类文件的详细信息。-c，该选项可以输出类中的所有方法以及字节码信息</p><p>其中:  monitor就是监视器的含义</p><p><img src="/./../img/image-20251112220823274.png" alt="image-20251112220823274"></p><p>在字节码层面由 <code>monitorenter</code> &#x2F; <code>monitorexit</code> 指令实现。Javac 会生成一个保护区域（try&#x2F;finally 风格）的结构：</p><p>正常路径在结束时 <code>monitorexit</code>，异常路径通过异常处理器也会执行 <code>monitorexit</code>，保证锁总是释放，随后重新抛出异常。当执行 <code>monitorenter</code>指令时，线程试图获取锁也就是获取 <code>monitor</code>(monitor对象存在于每个Java对象的<strong>对象头</strong>中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。</p><h2 id="sync到底锁什么？四种锁？"><a href="#sync到底锁什么？四种锁？" class="headerlink" title="sync到底锁什么？四种锁？"></a>sync到底锁什么？四种锁？</h2><p>在 JDK 1.6 以前，所有的锁都是”重量级“锁，因为使用的是操作系统的互斥锁，当一个线程持有锁时，其他试图进入synchronized块的线程将被阻塞，直到锁被释放。涉及到了线程上下文切换和用户态与内核态的切换，因此效率较低。</p><p>这也是为什么很多开发者会认为 synchronized 性能很差的原因。</p><p>那为了减少获得锁和释放锁带来的性能消耗，JDK 1.6 引入了“偏向锁”和“轻量级锁” 的概念，对 synchronized 做了一次重大的升级，升级后的 synchronized 性能可以说上了一个新台阶。</p><p>在 JDK 1.6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：</p><ol><li>无锁状态</li><li>偏向锁状态（15关闭，18废弃）<strong>性能收益不明显；JVM 内部代码维护成本太高</strong></li><li>轻量级锁状态</li><li>重量级锁状态</li></ol><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗 CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗 CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行时间较长。</td></tr></tbody></table><h3 id="锁什么"><a href="#锁什么" class="headerlink" title="锁什么"></a>锁什么</h3><p>对象的“锁”是存放在每个 Java 对象都有一个对象头。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>一个线程在第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID。当下次该线程进入这个同步块时，会去检查锁的 Mark Word 里面是不是放的自己的线程 ID。</p><p>如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费 CAS 操作来加锁和解锁；如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，这个时候要分两种情况：</p><ul><li><p>成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；</p></li><li><p>失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为 0，并设置锁标志位为 00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</p><h4 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h4><p>偏向锁使用了一种<strong>等到竞争出现才释放锁的机制</strong>，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p><p>偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：</p><ol><li>在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。</li><li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和 Mark Word，使其变成无锁状态。</li><li>唤醒被停止的线程，将当前锁升级成轻量级锁。</li></ol></li></ul><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>JVM 会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为 Displaced Mark Word。如果一个线程获得锁的时候发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word 里面。</p><p>然后线程尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示 Mark Word 已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</p><blockquote><p>自旋：不断尝试去获取锁，一般用循环来实现。</p></blockquote><p>JDK 采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><p>自旋也不是一直进行下去的，如果自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。同时这个锁就会<strong>升级成重量级锁</strong>。</p><p>在释放锁时，当前线程会使用 CAS 操作将 Displaced Mark Word 的内容复制回锁的 Mark Word 里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么 CAS 操作会失败，此时会释放锁并唤醒被阻塞的线程。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁依赖于操作系统的互斥锁（mutex，用于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段） 实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU。</p><h2 id="锁的升级流程"><a href="#锁的升级流程" class="headerlink" title="锁的升级流程"></a>锁的升级流程</h2><p>具体的锁升级的过程是：<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>。</p><ul><li><strong>无锁</strong>：这是没有开启偏向锁的时候的状态，在JDK1.6之后偏向锁的默认开启的，但是有一个偏向延迟，需要在JVM启动之后的多少（4）秒之后才能开启，这个可以通过JVM参数进行设置，同时是否开启偏向锁也可以通过JVM参数设置。当JVM启动后，一个共享资源对象直到有线程第一个访问时，这段时间内是处于无锁状态，对象头的Markword里偏向锁标识位是0，锁标识位是01。</li><li><strong>偏向锁</strong>：这个是在偏向锁开启之后的锁的状态，如果还没有一个线程拿到这个锁的话，这个状态叫做匿名偏向，当一个共享资源首次被某个线程访问时，锁就会从无锁状态升级到偏向锁状态，偏向锁会在Markword的偏向线程ID里存储当前线程的操作系统线程ID，偏向锁标识位是1，锁标识位是01。当一个线程拿到偏向锁的时候，下次想要竞争锁只需要拿线程ID跟MarkWord当中存储的线程ID进行比较，如果线程ID相同则直接获取锁（相当于锁偏向于这个线程），不需要进行CAS操作和将线程挂起的操作。</li><li><strong>轻量级锁</strong>：当第二个线程尝试获取偏向锁失败时，偏向锁会升级为轻量级锁，此时，JVM会使用CAS自旋操作来尝试获取锁，如果成功则进入临界区域，否则升级为重量级锁。在这个状态下线程主要是通过CAS操作实现的。轻量级锁是在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，尝试拷贝锁对象头的Markword到栈帧的Lock Record，若拷贝成功，JVM将使用CAS操作尝试将对象头的Markword更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象头的Markword。若拷贝失败,若当前只有一个等待线程，则可通过自旋继续尝试，</li><li><strong>重量级锁</strong>： 当自旋超过一定的次数，或者一个线程在持有锁，一个线程在自旋，又有第三个线程来访问时，轻量级锁就会膨胀为重量级锁。，因为CAS如果没有成功的话始终都在自旋，进行while循环操作，这是非常消耗CPU的，但是在升级为重量级锁之后，线程会被操作系统调度然后挂起，这可以节约CPU资源。底层是通过操作系统的mutex lock来实现的，每个对象指向一个monitor对象，这个monitor对象在堆中与锁是关联的，通过monitorenter指令插入到同步代码块在编译后的开始位置，monitorexit指令插入到同步代码块的结束处和异常处，这两个指令配对出现。JVM的线程和操作系统的线程是对应的，重量级锁的Markword里存储的指针是这个monitor对象的地址，操作系统来控制内核态中的线程的阻塞和恢复，从而达到JVM线程的阻塞和恢复，涉及内核态和用户态的切换，影响性能，所以叫重量级锁。</li></ul><p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><h3 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h3><ol><li>当JVM启动后，一个共享资源对象直到有线程第一个访问时，这段时间内是处于无锁状态，对象头的Markword里偏向锁标识位是0，锁标识位是01。</li></ol><p><img src="/./../img/3230688-20231101142443012-1772700968.png" alt="img"></p><p>当一个共享资源首次被某个线程访问时，锁就会从无锁状态升级到偏向锁状态，偏向锁会在Markword的偏向线程ID里存储当前线程的操作系统线程ID，偏向锁标识位是1，锁标识位是01。此后如果当前线程再次进入临界区域时，只比较这个偏向线程ID即可，这种情况是在只有一个线程访问的情况下，不再需要操作系统的重量级锁来切换上下文，提供程序的访问效率。<br>另外需要注意的是，由于硬件资源的不断升级，获取锁的成本随之下降，jdk15版本后默认关闭了偏向锁。<br>如果未开启偏向锁（或者在JVM偏向锁延迟时间之前）有线程访问共享资源则直接由无锁升级为轻量级锁，请看第3步。<br><img src="/./../img/3230688-20231101142508587-1722367516.png" alt="img"></p><ol><li>如果未开启偏向锁（或者在JVM偏向锁延迟时间之前），有线程访问共享资源则直接由无锁升级为轻量级锁，开启偏向线程锁后，并且当前共享资源锁已经是偏向锁时，再有第二个线程访问共享资源锁时，此时锁可能升级为轻量级锁，也可能还是偏向锁状态，因为这取决于线程间的竞争情况，如有没有竞争，那么偏向锁的效率更高（因为频繁的锁竞争会导致偏向锁的撤销和升级到轻量级锁），继续保持偏向锁。如果有竞争，则锁状态会从偏向锁升级到轻量级锁，这种情况下轻量级锁效率会更高。</li></ol><p>当第二个线程尝试获取偏向锁失败时，偏向锁会升级为轻量级锁，此时，JVM会使用CAS自旋操作来尝试获取锁，如果成功则进入临界区域，否则升级为重量级锁。<br>轻量级锁是在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，尝试拷贝锁对象头的Markword到栈帧的Lock Record，若拷贝成功，JVM将使用CAS操作尝试将对象头的Markword更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象头的Markword。若拷贝失败,若当前只有一个等待线程，则可通过自旋继续尝试， 当自旋超过一定的次数，或者一个线程在持有锁，一个线程在自旋，又有第三个线程来访问时，轻量级锁就会膨胀为重量级锁。<br><img src="/./../img/3230688-20231101142544543-1353049648.png" alt="img"></p><ol><li>当轻量级锁获取锁失败时，说明有竞争存在，轻量级锁会升级为重量级锁，此时，JVM会将线程阻塞，直到获取到锁后才能进入临界区域，底层是通过操作系统的mutex lock来实现的，每个对象指向一个monitor对象，这个monitor对象在堆中与锁是关联的，通过monitorenter指令插入到同步代码块在编译后的开始位置，monitorexit指令插入到同步代码块的结束处和异常处，这两个指令配对出现。JVM的线程和操作系统的线程是对应的，重量级锁的Markword里存储的指针是这个monitor对象的地址，操作系统来控制内核态中的线程的阻塞和恢复，从而达到JVM线程的阻塞和恢复，涉及内核态和用户态的切换，影响性能，所以叫重量级锁。</li></ol><p><img src="/./../img/3230688-20231101142620113-1396564306.png" alt="img"></p><p>锁升级简要步骤如下所示<br><img src="/./../img/3230688-20231101142724469-1226844103.png" alt="img"></p><blockquote><p>注意：图中无锁到偏向锁这不是升级，是在偏向锁打开后，对象默认是偏向状态，没有从无锁升级到偏向锁的过程。偏向锁未开启，会直接从无锁升级到轻量级锁，偏向锁开启时，会从偏向锁升级到轻量级锁。</p></blockquote><p><a href="https://blog.csdn.net/crazymakercircle/article/details/146029082">深入理解Java锁升级（图解+史上最全）：无锁 → 偏向锁 → 轻量级锁 → 重量级锁-CSDN博客</a></p><h1 id="话术"><a href="#话术" class="headerlink" title="话术"></a>话术</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在JVM中，synchronized是基于进入和退出<strong>Monitor对象</strong>来实现的，无论是显式同步还是隐式同步。对于方法级的同步，它是隐式的，即无需通过字节码指令来控制，它实现在方法调用和返回操作中。JVM可以从方法常量池中的方法表结构中的<strong>ACC_SYNCHRONIZED</strong>访问标志来区分一个方法是否为同步方法。当方法调用时，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有Monitor，然后执行方法，最后在方法完成时释放Monitor。</p><p>对于代码块的同步，它是利用<strong>monitorenter</strong>和<strong>monitorexit</strong>这两个字节码指令实现的。这些指令分别位于同步代码块的开始和结束位置。当JVM执行到monitorenter指令时，当前线程会尝试获取Monitor对象的所有权，如果获取成功，就会执行同步代码块，然后通过monitorexit指令释放Monitor对象</p><p><img src="/./../img/image-20251217195322785.png" alt="image-20251217195322785"></p><h2 id="ReentrantLock-和-synchronized-区别"><a href="#ReentrantLock-和-synchronized-区别" class="headerlink" title="ReentrantLock 和 synchronized 区别"></a>ReentrantLock 和 synchronized 区别</h2><p>（1）synchronized是独占锁，加锁和解锁的过程自动进行，易于操作，但不够灵活。ReentrantLock也是独占锁，加锁和解锁的过程需要手动进行，不易操作，但非常灵活。</p><p>（2）synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。</p><p>（3）synchronized不可响应中断，一个线程获取不到锁就一直等着；ReentrantLock可以响应中断。</p><p>（4）synchronized:Java中的关键字，是由JVM来维护的。是JVM层面的锁。</p><p>Lock：是JDK5以后才出现的具体的类。使用lock是调用对应的API。是API层面的锁。</p><p>synchronized是底层是通过monitorenter进行加锁（底层是通过monitor对象来完成的，其中的wait&#x2F;notify等方法也是依赖于monitor对象的。只有在同步块或者是同步方法中才可以调用wait&#x2F;notify等方法的。因为只有在同步块或者是同步方法中，JVM才会调用monitory对象的）；通过monitorexit来退出锁的。</p><p>而lock是通过调用对应的API方法来获取锁和释放锁的。</p><p>（5）synchronized;非公平锁</p><p>lock：两者都可以的。默认是非公平锁。在其构造方法的时候可以传入Boolean值。</p><p>true：公平锁</p><p>false：非公平锁</p><h2 id="JVM对Synchornized的优化？"><a href="#JVM对Synchornized的优化？" class="headerlink" title="JVM对Synchornized的优化？"></a>JVM对Synchornized的优化？</h2><p>synchronized 核心优化方案主要包含以下 4 个：</p><ul><li><strong>锁膨胀</strong>：synchronized 从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程，它叫做锁膨胀也叫做锁升级。JDK 1.6 之前，synchronized 是重量级锁，也就是说 synchronized 在释放和获取锁时都会从用户态转换成内核态，而转换的效率是比较低的。但有了锁膨胀机制之后，synchronized 的状态就多了无锁、偏向锁以及轻量级锁了，这时候在进行并发操作时，大部分的场景都不需要用户态到内核态的转换了，这样就大幅的提升了 synchronized 的性能。</li><li><strong>锁消除</strong>：指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的。</li><li><strong>锁粗化</strong>：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li><li><strong>自适应自旋锁</strong>：指通过自身循环，尝试获取锁的一种方式，优点在于它避免一些线程的挂起和恢复操作，因为挂起线程和恢复线程都需要从用户态转入内核态，这个过程是比较慢的，所以通过自旋的方式可以一定程度上避免线程挂起和恢复所造成的性能开销。</li></ul><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>悲观锁</p><p>对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</p><p>乐观锁</p><p>乐观锁，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。一旦多个线程发生冲突，乐观锁通常使用一种称为 CAS 的技术来保证线程执行的安全性。</p><p>由于乐观锁假想操作中没有锁的存在，因此不太可能出现死锁的情况，换句话说，<strong>乐观锁天生免疫死锁</strong>。</p><ul><li>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；</li><li>悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</li></ul><h2 id="什么是-CAS"><a href="#什么是-CAS" class="headerlink" title="什么是 CAS"></a>什么是 CAS</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>V：要更新的变量(var)</li><li>E：预期值(expected)</li><li>N：新值(new)</li></ul><p>比较并交换的过程如下：</p><p>判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，于是当前线程放弃更新，什么都不做。</p><h3 id="话术-1"><a href="#话术-1" class="headerlink" title="话术"></a>话术</h3><p><strong>CAS是解决多线程并发安全问题的一种乐观锁算法。</strong> 因为它在对共享变量更新之前，会先比较当前值是否与更新前的值一致，如果一致则更新，如果不一致则循环执行（称为自旋锁），直到当前值与更新前的值一致为止，才执行更新。</p><p>Unsafe类是CAS的核心类，提供<strong>硬件级别的原子操作</strong>（目前所有CPU基本都支持硬件级别的CAS操作）。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><strong>开销大</strong>：在并发量比较高的情况下，如果反复尝试更新某个变量，却又一直更新不成功，会给CPU带来较大的压力（自旋）</p><p><strong>ABA问题</strong>：当变量从A修改为B再修改回A时，变量值等于期望值A，但是无法判断是否修改，CAS操作在ABA修改后依然成功。（ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。从 JDK 1.5 开始，JDK 的 atomic 包里提供了一个类<code>AtomicStampedReference</code>类来解决 ABA 问题。）</p><p>CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块（多个共享变量）的原子性。</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h3 id="1-AQS-的作用是什么？"><a href="#1-AQS-的作用是什么？" class="headerlink" title="1. AQS 的作用是什么？"></a>1. AQS 的作用是什么？</h3><p>AQS 是一个用于构建锁和同步器的框架，它通过 <strong>FIFO 双向队列</strong> 管理等待线程，并通过 <strong><code>volatile int state</code></strong> 变量实现资源状态的原子操作。开发者只需重写少量方法，即可自定义同步工具。</p><h3 id="2-AQS-的底层结构"><a href="#2-AQS-的底层结构" class="headerlink" title="2. AQS 的底层结构"></a>2. AQS 的底层结构</h3><h4 id="1-资源状态state"><a href="#1-资源状态state" class="headerlink" title="(1) 资源状态state"></a>(1) 资源状态<code>state</code></h4><ul><li><strong>操作方式</strong>：<ul><li><code>getState()</code>：获取当前状态值。</li><li><code>setState(int newState)</code>：直接设置状态值。</li><li><code>compareAndSetState(int expect, int update)</code>：通过 CAS 原子更新状态。</li></ul></li><li><strong>实际应用</strong>：<ul><li><code>ReentrantLock</code>：<code>state</code> 表示锁的重入次数（0&#x3D;未锁定，1&#x3D;已锁定，&gt;1&#x3D;重入）。</li><li><code>Semaphore</code>：<code>state</code> 表示剩余的许可证数量。</li></ul></li></ul><h4 id="2-等待队列（CLH-变种）"><a href="#2-等待队列（CLH-变种）" class="headerlink" title="(2) 等待队列（CLH 变种）"></a>(2) 等待队列（CLH 变种）</h4><ul><li>双向链表实现，每个节点（<code>Node</code>）封装一个等待线程。</li><li>节点状态：<ul><li><code>CANCELLED</code>（线程已取消等待）</li><li><code>SIGNAL</code>（后继节点需要被唤醒）</li><li><code>CONDITION</code>（线程在条件队列中等待）</li></ul></li></ul><h2 id="话术-2"><a href="#话术-2" class="headerlink" title="话术"></a>话术</h2><ol><li>经典面试题</li></ol>  <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf">AQS 是什么？<br>AQS 的核心原理是什么？<br>AQS 中的同步队列和条件队列有什么区别？<br>ReentrantLock 的公平锁和非公平锁有什么区别？<br>Semaphore 是如何基于 AQS 实现的？<br>CountDownLatch 的实现原理与 AQS 有什么关系？<br>AQS 中独占模式和共享模式的区别是什么？<br>AQS 中的状态变量 <span class="hljs-keyword">state</span> 有什么作用？<br>如何自定义一个基于 AQS 的同步器？<br></code></pre></td></tr></table></figure><ol start="2"><li>解题思路和答案<br>AQS 是什么？</li></ol><p>解题思路：从 AQS 的定义、作用和在 Java 并发包中的地位进行阐述。<br><strong>答案：AQS 即抽象队列同步器（AbstractQueuedSynchronizer） ，是 Java 并发包中构建锁和同步器的基础框架 。它提供了一种基于 FIFO 队列的机制来管理线程的竞争和等待状态 ，AQS 就像是 Java 并发编程大厦的基石。</strong></p><ol start="3"><li>AQS 的核心原理是什么？<br>解题思路：围绕 AQS 的核心构成（状态变量state和同步队列），以及在独占模式和共享模式下线程获取和释放资源的过程进行分析。<br><strong>答案：AQS 的核心原理基于一个 FIFO 等待队列和一个同步状态（state） 。state是一个volatile修饰的整型变量，用于表示同步状态 ，不同的同步器中state有着不同的含义 。同步队列是一个双向链表，当线程无法获取同步状态时，会被封装成一个节点加入到同步队列中等待 。在独占模式下，同一时刻只有一个线程能获取到同步状态，其他线程获取失败则进入同步队列等待；在共享模式下，允许多个线程同时获取同步状态，只要剩余的共享资源满足线程的需求 。线程通过CAS操作来竞争获取或释放资源，获取失败则进入同步队列等待唤醒 。</strong></li><li>AQS 中的同步队列和条件队列有什么区别？<br>解题思路：分别介绍同步队列和条件队列的结构、作用以及节点状态的含义，对比它们在功能和使用场景上的差异。</li></ol><p>答案：</p><p><strong>同步队列是 AQS 实现线程同步的关键数据结构，是一个双向链表 ，用于存储等待获取同步状态的线程 。当线程获取同步状态失败时，会被封装成一个节点加入到同步队列的尾部 。节点的状态有CANCELLED（线程已取消等待）、SIGNAL（后继节点的线程需要被唤醒）等 。在独占模式下，持有锁的线程释放锁时，会唤醒同步队列中头节点的后继节点对应的线程 ；在共享模式下，释放共享资源时，会唤醒多个等待的线程 。</strong></p><p><strong>条件队列与Condition接口相关联 ，每个Condition对象都有一个单独的条件队列 。线程调用Condition的await方法时，会从同步队列转移到条件队列并释放锁进入等待状态 ，此时节点的状态会被设置为CONDITION 。当其他线程调用Condition的signal方法时，条件队列中第一个节点被转移回同步队列，等待获取锁 。</strong></p><p><strong>总的来说，同步队列主要用于线程获取同步状态失败时的等待和唤醒，而条件队列用于线程在满足特定条件时的等待和唤醒 ，两者相互配合，共同实现了 AQS 强大的同步功能 。</strong></p><ol start="5"><li>ReentrantLock 的公平锁和非公平锁有什么区别？<br>解题思路：从获取锁的过程、是否保证线程获取锁的顺序以及性能等方面进行对比分析。<br>答案：公平锁保证线程按照请求锁的顺序获取锁，即先到先得 。在获取锁时，公平锁会先调用hasQueuedPredecessors方法检查同步队列中是否有前驱节点 ，只有在没有前驱节点时才尝试获取锁 ，以此保证先到的线程先获取锁 。<br>非公平锁则不保证获取顺序，线程可以在锁可用时直接竞争获取，可能会出现后到的线程先获取到锁的情况 。非公平锁在获取锁时，直接尝试通过CAS操作获取锁，不会检查同步队列 ，如果获取失败，才会和公平锁一样，将线程加入同步队列等待 。</li></ol><p>在性能方面，非公平锁由于减少了检查同步队列的开销，在高并发场景下性能通常比公平锁更高 。但同时，由于可能导致一些线程长时间等待，出现线程饥饿的问题 。而公平锁虽然保证了公平性，但由于频繁的线程上下文切换，性能相对较低 。</p><ol start="6"><li><p>Semaphore 是如何基于 AQS 实现的？<br>解题思路：分析Semaphore中与 AQS 相关的核心方法，如tryAcquireShared和tryReleaseShared，阐述它们如何利用 AQS 的同步队列和状态变量来实现信号量的功能。<br>答案：Semaphore是基于 AQS 的共享模式实现的 。在Semaphore中，AQS 的状态变量state表示剩余的许可数 。当一个线程调用acquire方法获取许可时，实际上调用的是 AQS 的acquireShared方法 ，tryAcquireShared方法是获取共享资源的核心逻辑 。它会进入一个无限循环，获取当前的state，计算获取acquires个许可后剩余的许可数remaining 。如果remaining小于 0，说明当前剩余许可数不足，返回remaining，表示获取失败 ；否则，通过CAS操作尝试将state从当前值更新为remaining 。如果更新成功，返回remaining，表示获取成功 ；如果更新失败，说明有其他线程同时在修改state，继续循环尝试 。<br>当线程调用release方法释放许可时，实际上调用的是 AQS 的releaseShared方法 ，tryReleaseShared方法会进入一个无限循环，获取当前的state ，计算释放releases个许可后的状态next 。如果next小于当前state，说明释放的许可数超过了最大许可数，抛出Error异常 ；否则，通过CAS操作尝试将state从当前值更新为next 。如果更新成功，返回true，表示释放成功 ；如果更新失败，说明有其他线程同时在修改state，继续循环尝试 。如果释放成功，会调用doReleaseShared方法唤醒同步队列中等待的线程 。</p></li><li><p>CountDownLatch 的实现原理与 AQS 有什么关系？<br>解题思路：说明CountDownLatch如何利用 AQS 的同步队列和状态变量来实现线程的等待和计数功能，重点分析await和countDown方法的实现逻辑。<br>答案：CountDownLatch也是基于 AQS 实现的 。它利用 AQS 的状态变量state来表示计数的初始值 。当一个或多个线程调用await方法时，实际上调用的是 AQS 的acquireSharedInterruptibly方法 ，线程会尝试获取共享资源 。由于CountDownLatch的设计，只有当state减为 0 时，线程才能获取到共享资源，否则线程会被加入到同步队列中等待 。<br>当其他线程调用countDown方法时，实际上调用的是 AQS 的releaseShared方法 ，会将state减 1 。如果state减为 0，说明所有的计数都已完成，会唤醒同步队列中等待的线程 ，让它们继续执行 。</p></li><li><p>AQS 中独占模式和共享模式的区别是什么？<br> 解题思路：从获取资源的方式、同步队列的处理以及应用场景等方面进行详细对比。</p></li></ol><p>  答案：在获取资源的方式上，独占模式下，同一时刻只有一个线程能获取到同步状态，其他线程只能等待 ；共享模式下，允许多个线程同时获取同步状态，只要剩余的共享资源满足线程的需求 。<br>  在同步队列的处理上，独占模式中，获取锁失败的线程会被加入同步队列，当持有锁的线程释放锁时，只会唤醒同步队列中头节点的后继节点对应的线程 ；共享模式中，获取共享资源失败的线程同样会被加入同步队列，当有线程释放共享资源时，会唤醒同步队列中多个等待的线程（只要剩余的共享资源足够） 。</p><p>在应用场景方面，独占模式适用于需要严格控制资源访问，保证同一时刻只有一个线程访问资源的场景，如文件写入操作 ；共享模式适用于读多写少的场景，或者需要多个线程同时访问共享资源的场景，如数据库连接池、信号量控制并发访问数量等 。</p><ol start="9"><li>AQS 中的状态变量 state 有什么作用？<br> 解题思路：结合不同的同步器，阐述state在表示同步状态、控制资源访问以及实现锁的重入等方面的作用。</li></ol>  <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">答案：AQS 中的状态变量<span class="hljs-keyword">state</span>是实现同步的关键 ，它用一个volatile修饰的整型变量来表示同步状态 。在不同的同步器中，<span class="hljs-keyword">state</span>有着不同的含义和作用 。在ReentrantLock中，<span class="hljs-keyword">state</span>表示锁的重入次数 。当一个线程首次获取到锁时，<span class="hljs-keyword">state</span>会被设置为 <span class="hljs-number">1</span> 。如果该线程再次获取同一把锁，<span class="hljs-keyword">state</span>就会递增，变为 <span class="hljs-number">2</span>，以此类推，表示线程对锁的重入 。而当线程释放锁时，<span class="hljs-keyword">state</span>会相应递减，直到<span class="hljs-keyword">state</span>为 <span class="hljs-number">0</span> 时，锁被完全释放 。在Semaphore中，<span class="hljs-keyword">state</span>表示剩余的许可数 。假设我们创建一个信号量对象并设置许可数为 <span class="hljs-number">5</span>，那么初始时<span class="hljs-keyword">state</span>就是 <span class="hljs-number">5</span> 。当一个线程调用acquire方法获取许可时，如果<span class="hljs-keyword">state</span>大于 <span class="hljs-number">0</span>，该线程就能获取到许可，同时<span class="hljs-keyword">state</span>减 <span class="hljs-number">1</span> ；当<span class="hljs-keyword">state</span>为 <span class="hljs-number">0</span> 时，其他线程再调用acquire方法就会被阻塞，直到有其他线程调用release方法释放许可，<span class="hljs-keyword">state</span>增加后，才有可能获取到许可 。<br></code></pre></td></tr></table></figure><ol start="10"><li><p>如何自定义一个基于 AQS 的同步器？<br>解题思路：介绍自定义同步器的步骤，包括继承 AQS 类、重写必要的抽象方法（如tryAcquire、tryRelease等），以及如何使用自定义同步器。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">答案：自定义一个基于 AQS 的同步器，首先需要继承AbstractQueuedSynchronizer类 。然后，根据同步器的类型（独占模式或共享模式），重写相应的抽象方法 。<br></code></pre></td></tr></table></figure></li></ol><p>11.为什么 AQS 使用双向队列而非单向队列？</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">线程取消的高效处理：当线程因超时或中断取消等待时，需要快速修改前驱和后继节点的指针。<br><br>时间复杂度优化：<br><br>单向队列删除中间节点需遍历，时间复杂度 O(n)。<br><br>双向队列通过 prev 和 <span class="hljs-keyword">next</span> 指针直接操作，时间复杂度 O(<span class="hljs-number">1</span>)。<br></code></pre></td></tr></table></figure><p>12.AQS 的 ConditionObject 和 Object.wait() 有什么区别？</p><table><thead><tr><th>对比维度</th><th>ConditionObject</th><th>Object.wait()</th></tr></thead><tbody><tr><td>绑定对象</td><td>必须绑定到 AQS 实现的锁（如 ReentrantLock）</td><td>任意 synchronized 对象</td></tr><tr><td>多条件队列</td><td>支持多个条件队列（如生产者-消费者模型分组）</td><td>仅一个等待队列</td></tr><tr><td>唤醒精度</td><td>signal() 精确唤醒指定条件队列的线程</td><td>notify() 随机唤醒一个线程</td></tr><tr><td>中断支持</td><td>提供 awaitUninterruptibly() 方法</td><td>需手动处理中断</td></tr></tbody></table><p>13AQS 如何处理线程中断？</p><ul><li><p>不可中断模式（默认）：*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">线程调用 acquire() 时被中断，会继续等待直到获取资源，再补上中断标记。<br></code></pre></td></tr></table></figure></li><li><p>可中断模式：*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">线程调用 acquireInterruptibly() 时被中断，直接抛出 InterruptedException。<br></code></pre></td></tr></table></figure></li></ul><p>14共享模式下的唤醒传播是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">共享模式（如 Semaphore）释放资源时，会唤醒队列中的第一个等待节点，<br>并由该节点继续唤醒后续共享节点，形成“连锁反应”，直到无可用资源或队列为空。<br><br>优势：减少唤醒次数，提升并发效率。<br></code></pre></td></tr></table></figure><p>15AQS 中的同步状态（state）有什么作用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">答：同步状态（state）用于表示同步器的状态，不同的同步器对 state 的含义和操作方式不同。<br>例如在 ReentrantLock 中表示锁的重入次数，在 Semaphore 中表示可用的许可证数量。<br></code></pre></td></tr></table></figure><p>16AQS 队列的作用是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">答：AQS 队列用于存储等待获取同步状态的线程节点，当线程获取同步状态失败时，会被加入到队列中等待唤醒。<br></code></pre></td></tr></table></figure><p>17说说 AQS 中 acquire 和 acquireInterruptibly 方法的区别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">答：acquire 方法是独占式获取同步状态，如果获取失败则将当前线程加入等待队列并阻塞，且不响应中断；<br>acquireInterruptibly也是独占式获取同步状态，但允许线程被中断，<br>当线程被中断时会抛出 InterruptedException。<br></code></pre></td></tr></table></figure><p><img src="/./../img/other-bukfsdjavassmtjstd-b2ded433-defd-4535-b767-fd2e5be0b5b9.png" alt="img"></p><h1 id="显式锁-Lock"><a href="#显式锁-Lock" class="headerlink" title="显式锁(Lock)"></a>显式锁(Lock)</h1><p>相比同步锁，JUC包中的Lock锁的功能更加强大，它提供了各种各样的锁（公平锁，非公平锁，共享锁，独占锁……），所以使用起来很灵活。</p><blockquote><p>锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。</p></blockquote><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 重入锁，是实现<a href="https://javabetter.cn/thread/suo.html">Lock 接口</a>的一个类，也是在实际编程中使用频率很高的一个锁，<strong>支持重入性，表示能够对共享资源重复加锁，即当前线程获取该锁后再次获取不会被阻塞</strong>。</p><p>要想支持重入性，就要解决两个问题：</p><ol><li>在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功；</li><li>由于锁会被获取 n 次，那么只有锁在被释放同样的 n 次之后，该锁才算是完全释放成功。</li></ol><p><img src="/./../img/68f9b53206328c02b14f0e49" alt="img"></p><h3 id="Reen公平锁和非公平锁源码区别"><a href="#Reen公平锁和非公平锁源码区别" class="headerlink" title="Reen公平锁和非公平锁源码区别"></a>Reen公平锁和非公平锁源码区别</h3><p>公平锁代码的逻辑与 nonfairTryAcquire 基本上一致，唯一的不同在于增加了 hasQueuedPredecessors 的逻辑判断，从方法名就可以知道该方法用来判断当前节点在同步队列中是否有前驱节点的，如果有前驱节点，说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。如果当前节点没有前驱节点，才有做后面逻辑判断的必要性。</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>ReentrantReadWriteLock 是 Java 的一种读写锁，它允许多个读线程同时访问，但只允许一个写线程访问，或者阻塞所有的读写线程。这种锁的设计可以提高性能，特别是在数据结构中，读操作的数量远远超过写操作的情况下。</p><p>读写锁的实现主要是通过重写 <a href="https://javabetter.cn/thread/aqs.html">AQS</a> 的 tryAcquire 方法和 tryRelease 方法实现的，读锁和写锁的获取和释放都是通过这两个方法实现的。</p><p>读写锁支持锁降级，遵循按照获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁，不支持锁升级。、、</p><h3 id="读写降级"><a href="#读写降级" class="headerlink" title="读写降级"></a>读写降级</h3><p>读写锁支持锁降级，<strong>遵循按照获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁</strong>，不支持锁升级，关于锁降级，</p><p>这里的流程可以解释如下：</p><ul><li>获取读锁：首先尝试获取读锁来检查某个缓存是否有效。</li><li>检查缓存：如果缓存无效，则需要释放读锁，因为在获取写锁之前必须释放读锁。</li><li>获取写锁：获取写锁以便更新缓存。此时，可能还需要重新检查缓存状态，因为在释放读锁和获取写锁之间可能有其他线程修改了状态。</li><li>更新缓存：如果确认缓存无效，更新缓存并将其标记为有效。</li><li>写锁降级为读锁：在释放写锁之前，获取读锁，从而实现写锁到读锁的降级。这样，在释放写锁后，其他线程可以并发读取，但不能写入。</li><li>使用数据：现在可以安全地使用缓存数据了。</li><li>释放读锁：完成操作后释放读锁。</li></ul><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p><code>StampedLock</code> 面试中问的比较少，不是很重要，简单了解即可。</p><h3 id="StampedLock-是什么？"><a href="#StampedLock-是什么？" class="headerlink" title="[StampedLock 是什么？"></a>[StampedLock 是什么？</h3><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 <code>Condition</code>。</p><p>不同于一般的 <code>Lock</code> 类，<code>StampedLock</code> 并不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 独立实现的（AQS 也是基于这玩意）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StampedLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>StampedLock</code> 提供了三种模式的读写控制模式：读锁、写锁和乐观读。</p><ul><li><strong>写锁</strong>：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 <code>ReentrantReadWriteLock</code> 的写锁，不过这里的写锁是不可重入的。</li><li><strong>读锁</strong> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 <code>ReentrantReadWriteLock</code> 的读锁，不过这里的读锁是不可重入的。</li><li><strong>乐观读</strong>：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。</li></ul><p>另外，<code>StampedLock</code> 还支持这三种锁在一定条件下进行相互转换 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-title function_">tryConvertToWriteLock</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span>&#123;&#125;<br><span class="hljs-type">long</span> <span class="hljs-title function_">tryConvertToReadLock</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span>&#123;&#125;<br><span class="hljs-type">long</span> <span class="hljs-title function_">tryConvertToOptimisticRead</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p><code>StampedLock</code> 在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，如果返回的数据戳为 0 则表示锁获取失败。当前线程持有了锁再次获取锁还是会返回一个新的数据戳，这也是<code>StampedLock</code>不可重入的原因。</p><h3 id="StampedLock-的性能为什么更好？"><a href="#StampedLock-的性能为什么更好？" class="headerlink" title="[StampedLock 的性能为什么更好？"></a>[StampedLock 的性能为什么更好？</h3><p>相比于传统读写锁多出来的乐观读是<code>StampedLock</code>比 <code>ReadWriteLock</code> 性能更好的关键原因。<code>StampedLock</code> 的乐观读允许一个写线程获取写锁，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。</p><h3 id="StampedLock-适合什么场景？"><a href="#StampedLock-适合什么场景？" class="headerlink" title="[StampedLock 适合什么场景？"></a>[StampedLock 适合什么场景？</h3><p>和 <code>ReentrantReadWriteLock</code> 一样，<code>StampedLock</code> 同样适合读多写少的业务场景，可以作为 <code>ReentrantReadWriteLock</code>的替代品，性能更好。</p><p>不过，需要注意的是<code>StampedLock</code>不可重入，不支持条件变量 <code>Condition</code>，对中断操作支持也不友好（使用不当容易导致 CPU 飙升）。如果你需要用到 <code>ReentrantLock</code> 的一些高级性能，就不太建议使用 <code>StampedLock</code> 了。</p><p>另外，<code>StampedLock</code> 性能虽好，但使用起来相对比较麻烦，一旦使用不当，就会出现生产问题。强烈建议你在使用<code>StampedLock</code> 之前，看看</p><h3 id="StampedLock-的底层原理了解吗？"><a href="#StampedLock-的底层原理了解吗？" class="headerlink" title="StampedLock 的底层原理了解吗？"></a>StampedLock 的底层原理了解吗？</h3><p><code>StampedLock</code> 不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 实现的（AQS 也是基于这玩意），CLH 锁是对自旋锁的一种改良，是一种隐式的链表队列。<code>StampedLock</code> 通过 CLH 队列进行线程的管理，通过同步状态值 <code>state</code> 来表示锁的状态和类型。</p><p>end？</p>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实在智能</title>
    <link href="/2025/11/13/0000%E9%9D%A2%E7%BB%8F/"/>
    <url>/2025/11/13/0000%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="实在智能"><a href="#实在智能" class="headerlink" title="实在智能"></a>实在智能</h1><p>1.Integer和int的拆箱（nullPointer）（错误）</p><p>2.常见错误以及原因（concurrentmodeficationexpection）（ClassNotFound不能说）</p><p>3.用过什么数据库</p><p>4.MySQL的索引是什么（没有全文索引）</p><p>5.为什么B+树</p><p>6.B是什么（Balanced）</p><p>7.为什么能存千万级别数据（计算错误，指针14b，数据100b）</p><p>8。索引失效问题（a，b，c）索引跳跃（紧张忘记了）</p><p>9.为什么ICP？ICP是什么？（只能用于排序）（错误）</p><p>10.深度分页问题（错误）</p><p>11。结束</p><p>end</p>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00JUC入门</title>
    <link href="/2025/11/13/00JUC(%E7%BA%BF%E7%A8%8B-volatile)/"/>
    <url>/2025/11/13/00JUC(%E7%BA%BF%E7%A8%8B-volatile)/</url>
    
    <content type="html"><![CDATA[<h1 id="线程入门"><a href="#线程入门" class="headerlink" title="线程入门"></a>线程入门</h1><p>多线程的很多概念听起来就很难理解。比方说：</p><ul><li>进程，是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发。</li><li>线程，是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。</li></ul><p>总结来说，进程和线程都是操作系统用于并发执行的方式，但是它们在资源管理、独立性、开销以及影响范围等方面有所不同。</p><ul><li>进程是操作系统分配资源的基本单位，线程是操作系统调度的基本单位。</li><li>进程拥有独立的内存空间，线程共享所属进程的内存空间。</li><li>进程的创建和销毁需要资源的分配和回收，开销较大；线程的创建和销毁只需要保存寄存器和栈信息，开销较小。</li><li>进程间的通信比较复杂，而线程间的通信比较简单。</li><li>进程间是相互独立的，一个进程崩溃不会影响其他进程；线程间是相互依赖的，一个线程崩溃可能影响整个程序的稳定性。</li></ul><h2 id="线程创建方法Thread-start"><a href="#线程创建方法Thread-start" class="headerlink" title="线程创建方法Thread.start()"></a>线程创建方法Thread.start()</h2><p>根据知识库信息，Java中创建线程主要有以下四种方式，每种方式都有其适用场景和优缺点：</p><h3 id="继承thread类"><a href="#继承thread类" class="headerlink" title="继承thread类"></a>继承thread类</h3><p><strong>特点</strong>：</p><ul><li>直接继承<code>Thread</code>类，重写<code>run()</code>方法</li><li>代码简单直观，新手容易理解</li><li>无法实现多继承（Java单继承限制）</li></ul><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现<code>Runnable</code>接口</h3><p><strong>特点</strong>：</p><ul><li>实现<code>Runnable</code>接口，重写<code>run()</code>方法</li><li>线程与任务解耦，任务逻辑独立于线程管理</li><li>支持Lambda表达式简化代码</li></ul><ol start="3"><li>实现Callable接口（带返回值）</li></ol><h3 id="callable"><a href="#callable" class="headerlink" title="callable"></a>callable</h3><p><strong>特点</strong>：</p><ul><li>实现<code>Callable</code>接口，重写<code>call()</code>方法</li><li>可返回任务执行结果（通过<code>FutureTask</code>）</li><li>可抛出受检异常</li><li>需要配合<code>FutureTask</code>使用</li></ul><p><strong>示例代码</strong>：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Callable</span></span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> call() throws Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Callable任务执行&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;任务结果&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用方式</span><br>Callable&lt;<span class="hljs-keyword">String</span>&gt; callable = <span class="hljs-keyword">new</span><span class="hljs-type"></span> MyCallable();<br>FutureTask&lt;<span class="hljs-keyword">String</span>&gt; futureTask = <span class="hljs-keyword">new</span><span class="hljs-type"></span> FutureTask&lt;&gt;(callable);<br><span class="hljs-keyword">new</span><span class="hljs-type"></span> Thread(futureTask).start();<br><br><span class="hljs-comment">// 获取结果</span><br><span class="hljs-keyword">String</span> result = futureTask.<span class="hljs-keyword">get</span>(); <span class="hljs-comment">// 阻塞等待结果</span><br></code></pre></td></tr></table></figure><p><strong>适用场景</strong>：</p><ul><li>需要获取异步任务结果的场景</li><li>需要处理异常的场景</li></ul><p><strong>优缺点</strong>：</p><ul><li>✅ 优点：可以返回执行结果，可抛出受检异常</li><li>❌ 缺点：需要额外使用<code>FutureTask</code>，代码稍复杂，阻塞等待</li></ul><h3 id="使用线程池（最佳实践）"><a href="#使用线程池（最佳实践）" class="headerlink" title="使用线程池（最佳实践）"></a>使用线程池（最佳实践）</h3><p><strong>特点</strong>：</p><ul><li>通过<code>ExecutorService</code>创建线程池</li><li>避免频繁创建和销毁线程，资源管理高效</li><li>可控制并发数量，提高系统稳定性</li></ul><p><strong>示例代码</strong>：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-regexp">// 创建固定大小的线程池</span><br><span class="hljs-regexp">ExecutorService executor = Executors.newFixedThreadPool(5);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">//</span> 提交任务<br>executor.submit<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    System.out.println(<span class="hljs-string">&quot;线程池任务执行&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 关闭线程池</span><br><span class="hljs-function"><span class="hljs-title">executor</span>.<span class="hljs-title">shutdown</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure><p><strong>适用场景</strong>：</p><ul><li>生产环境，需要高效管理线程的场景</li><li>高并发处理（如批量处理10万条订单数据）</li><li>需要超时重试的场景（如调用第三方接口）</li></ul><p><strong>优缺点</strong>：</p><ul><li>✅ 优点：资源管理高效，系统稳定性高，可控制并发数量</li></ul><h2 id="关于线程的一些疑问"><a href="#关于线程的一些疑问" class="headerlink" title="[关于线程的一些疑问]"></a>[关于线程的一些疑问]</h2><h3 id="1、为什么要重写-run-方法？"><a href="#1、为什么要重写-run-方法？" class="headerlink" title="[1、为什么要重写 run 方法？]"></a>[1、为什么要重写 run 方法？]</h3><p>这是因为默认的<code>run()</code>方法不会做任何事情。</p><p>为了让线程执行一些实际的任务，我们需要提供自己的<code>run()</code>方法实现，这就需要重写<code>run()</code>方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>  public void run() &#123;<br>    <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;MyThread running&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们重写了<code>run()</code>方法，使其打印出一条消息。当我们创建并启动这个线程的实例时，它就会打印出这条消息。</p><h3 id="2、run-方法和-start-方法有什么区别？"><a href="#2、run-方法和-start-方法有什么区别？" class="headerlink" title="[2、run 方法和 start 方法有什么区别？]"></a>[2、run 方法和 start 方法有什么区别？]</h3><ul><li><code>run()</code>：封装线程执行的代码，直接调用相当于调用普通方法。</li><li><code>start()</code>：启动线程，然后由 JVM 调用此线程的 <code>run()</code> 方法。</li></ul><h3 id="3、通过继承-Thread-的方法和实现-Runnable-接口的方式创建多线程，哪个好？"><a href="#3、通过继承-Thread-的方法和实现-Runnable-接口的方式创建多线程，哪个好？" class="headerlink" title="3、通过继承 Thread 的方法和实现 Runnable 接口的方式创建多线程，哪个好？"></a><strong>3、通过继承 Thread 的方法和实现 Runnable 接口的方式创建多线程，哪个好？</strong></h3><p>实现 Runable 接口好，原因有两个：</p><ul><li>♠①、避免了 Java 单继承的局限性，Java 不支持多重继承，因此如果我们的类已经继承了另一个类，就不能再继承 Thread 类了。</li><li>♠②、适合多个相同的程序代码去处理同一资源的情况，把线程、代码和数据有效的分离，更符合面向对象的设计思想。Callable 接口与 Runnable 非常相似，但可以返回一个结果。</li></ul><h2 id="线程几种方法"><a href="#线程几种方法" class="headerlink" title="线程几种方法"></a>线程几种方法</h2><h3 id="1wait和sleep"><a href="#1wait和sleep" class="headerlink" title="1wait和sleep"></a>1wait和sleep</h3><p>wait是object的顺便用，sleep只能线程使用；wait只能在锁下使用，无锁环境用wait报错</p><p>sleep 和 wait 区别：</p><table><thead><tr><th align="left">特性</th><th align="left"><code>Thread.sleep()</code></th><th align="left"><code>Object.wait()</code></th></tr></thead><tbody><tr><td align="left"><strong>锁行为</strong></td><td align="left"><strong>不释放锁</strong></td><td align="left"><strong>释放锁</strong></td></tr><tr><td align="left"><strong>所属类</strong></td><td align="left"><code>Thread</code> 类的静态方法</td><td align="left"><code>Object</code> 类的实例方法</td></tr><tr><td align="left"><strong>唤醒方式</strong></td><td align="left">时间到自动唤醒</td><td align="left">需要 <code>notify()</code>&#x2F;<code>notifyAll()</code> 或超时</td></tr><tr><td align="left"><strong>同步要求</strong></td><td align="left">不需要在同步块中</td><td align="left">必须在同步块中</td></tr></tbody></table><p><img src="/./../img/image-20251112145648703.png" alt="image-20251112145648703"></p><h3 id="2）join"><a href="#2）join" class="headerlink" title="2）join()"></a>2）join()</h3><p>等待这个线程执行完才会轮到后续线程得到 cpu 的执行权，使用这个也要捕获异常。</p><h3 id="3）setDaemon"><a href="#3）setDaemon" class="headerlink" title="3）setDaemon()"></a><a href="https://javabetter.cn/thread/wangzhe-thread.html#_3-setdaemon">3）setDaemon()</a></h3><p>将此线程标记为守护线程，准确来说，就是服务其他的线程，像 Java 中的垃圾回收线程，就是典型的守护线程。</p><h3 id="4）yield"><a href="#4）yield" class="headerlink" title="4）yield()"></a><a href="https://javabetter.cn/thread/wangzhe-thread.html#_4-yield">4）yield()</a></h3><p>yield() 方法是一个静态方法，用于暗示当前线程愿意放弃其当前的时间片，允许其他线程执行。然而，它只是向线程调度器提出建议，调度器可能会忽略这个建议。具体行为取决于操作系统和 <a href="https://javabetter.cn/jvm/what-is-jvm.html">JVM</a> 的线程调度策略。</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>我们通过 Future 来获取 Callable 任务的执行结果，那么 Future 是什么呢？</p><p>Future 位于 <code>java.util.concurrent</code> 包下，它是一个接口：</p><p>Future 提供了三种功能：</p><ul><li>1）判断任务是否完成；</li><li>2）能够中断任务；</li><li>3）能够获取任务执行结果。</li></ul><p>由于 Future 只是一个接口，如果直接 new 的话，编译器是会有一个 ⚠️ 警告的，它会提醒我们最好使用 FutureTask。</p><ul><li><strong>FutureTask本身</strong>：是一个线程安全的类，用于封装异步计算任务</li><li><strong>FutureTask的get()方法</strong>：会阻塞等待任务完成</li><li><strong>不是阻塞等待结构</strong>，而是提供了一个<strong>阻塞等待机制</strong>（通过get()方法）来获取任务结果</li></ul><p>简单来说，FutureTask是”任务容器”，而它的get()方法提供了”阻塞等待”功能。</p><h2 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h2><p> Java 线程的 6 个状态：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// <span class="hljs-keyword">Thread</span>.State 源码<br>public enum State &#123;<br><span class="hljs-built_in">    NEW,</span><br><span class="hljs-built_in">    RUNNABLE,</span><br><span class="hljs-built_in">    BLOCKED,</span><br><span class="hljs-built_in">    WAITING,</span><br><span class="hljs-built_in">    TIMED_WAITING,</span><br>    TERMINATED<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><p>处于 NEW 状态的线程此时尚未启动。这里的尚未启动指的是还没调用 Thread 实例的<code>start()</code>方法。</p><h4 id="关于-start-的两个引申问题"><a href="#关于-start-的两个引申问题" class="headerlink" title="[关于 start 的两个引申问题]"></a>[关于 start 的两个引申问题]</h4><ol><li><p>反复调用同一个线程的 start 方法是否可行？</p></li><li><p>假如一个线程执行完毕（此时处于 TERMINATED 状态），再次调用这个线程的 start 方法是否可行？</p></li><li><p>都不行，在调用 start 之后，threadStatus 的值会改变（<code>threadStatus !=0</code>），再次调用 start 方法会抛出 IllegalThreadStateException 异常。</p></li><li><p>threadStatus 为 2 代表当前线程状态为 TERMINATED（下面会讲）。</p></li></ol><h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><p>表示当前线程正在运行中。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配资源。</p><h3 id="Blocked"><a href="#Blocked" class="headerlink" title="Blocked"></a>Blocked</h3><p>阻塞状态。处于 BLOCKED 状态的线程正等待<a href="https://javabetter.cn/thread/lock.html">锁</a>（锁会在后面细讲）的释放以进入同步区。</p><h3 id="waitting"><a href="#waitting" class="headerlink" title="waitting"></a>waitting</h3><p>等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒。</p><p>调用下面这 3 个方法会使线程进入等待状态：</p><ul><li><code>Object.wait()</code>：使当前线程处于等待状态直到另一个线程唤醒它；</li><li><code>Thread.join()</code>：等待线程执行完毕，底层调用的是 Object 的 wait 方法；</li><li><code>LockSupport.park()</code>：除非获得调用许可，否则禁用当前线程进行线程调度。<a href="https://javabetter.cn/thread/LockSupport.html">LockSupport</a> 我们在后面会细讲。</li></ul><h3 id="timed-waiting"><a href="#timed-waiting" class="headerlink" title="timed_waiting"></a>timed_waiting</h3><p>超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。</p><p>调用如下方法会使线程进入超时等待状态：</p><ul><li><code>Thread.sleep(long millis)</code>：使当前线程睡眠指定时间；</li><li><code>Object.wait(long timeout)</code>：线程休眠指定时间，等待期间可以通过<code>notify()</code>&#x2F;<code>notifyAll()</code>唤醒；</li><li><code>Thread.join(long millis)</code>：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行；</li><li><code>LockSupport.parkNanos(long nanos)</code>： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；<a href="https://javabetter.cn/thread/LockSupport.html">LockSupport</a> 我们在后面会细讲；</li><li><code>LockSupport.parkUntil(long deadline)</code>：同上，也是禁止线程进行调度指定时间；</li></ul><h3 id="terminated"><a href="#terminated" class="headerlink" title="terminated"></a>terminated</h3><p>终止状态。此时线程已执行完毕。</p><h3 id="线程状态的转换"><a href="#线程状态的转换" class="headerlink" title="[线程状态的转换]"></a>[线程状态的转换]</h3><p><img src="/./../img/thread-state-and-method-20230829143200.png" alt="img"></p><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p><img src="/./../img/thread-bring-some-problem-119223c9-83a9-42e1-9a0c-f9c706a1e793.png" alt="img"></p><p>线程安全问题：多个线程操作同一个共享整据，导致线程安全问题</p><h2 id="并发编程三大问题"><a href="#并发编程三大问题" class="headerlink" title="并发编程三大问题"></a>并发编程三大问题</h2><ul><li><strong>原子性：<strong>即不可分割性。比如 a&#x3D;0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作是原子操作。再比如：a++； 这个操作实际是a &#x3D; a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要</strong>使用同步技术（sychronized）或者锁（Lock）来让它变成一个原子操作</strong>。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：<strong>AtomicInteger、AtomicLong、AtomicReference</strong>等。</li><li>**可见性：**每个线程都有自己的工作内存，所以当某个线程修改完某个变量之后，在其他的线程中，未必能观察到该变量已经被修改。**在 Java 中 volatile、synchronized 和 final 实现可见性。**volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。</li><li>**有序性：**java的有序性跟线程相关。一个线程内部所有操作都是有序的，如果是多个线程所有操作都是无序的。因为JMM的工作内存和主内存之间存在延迟，而且java会对一些指令进行重新排序。volatile和synchronized可以保证程序的有序性，volatile和synchronized能保证指令不进行重排序。<ul><li>volatile关键字本身就包含了禁止指令重排序的语义</li><li>synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li><li><strong>指令重排</strong>: 多线程环境中线程交替执行,由于编译器优化重排的存在,;两个线程中使用的变量能否保证–致性是无法确定的，结果无法预测</li></ul></li></ul><h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p>Java 内存模型（Java Memory Model，JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则。它主要涉及到多线程环境下的共享变量可见性、指令重排等问题，是理解并发编程中的关键概念。</p><p>并发编程的线程之间存在两个问题：</p><ul><li>线程间如何通信？即：线程之间以何种机制来交换信息</li><li>线程间如何同步？即：线程以何种机制来控制不同线程间发生的相对顺序</li></ul><p>有两种并发模型可以解决这两个问题：</p><ul><li>消息传递并发模型</li><li>共享内存并发模型</li></ul><p>这两种模型之间的区别如下图所示：</p><p><img src="/./../img/jmm-a610752d-ef73-47f2-b02c-6954eb3d62bf.png" alt="两种并发模型的比较">两种并发模型的比较</p><p><strong>Java 使用的是共享内存并发模型</strong>。</p><p>Java 线程之间的通信由 Java 内存模型（简称 JMM）控制，从抽象的角度来说，JMM 定义了线程和主存之间的抽象关系。</p><ol><li>所有的共享变量都存在主存中。</li><li>每个线程都保存了一份该线程使用到的共享变量的副本。</li><li>如果线程 A 与线程 B 之间要通信的话，必须经历下面 2 个步骤：<ol><li>线程 A 将本地内存 A 中更新过的共享变量刷新到主存中去。</li><li>线程 B 到主存中去读取线程 A 之前已经更新过的共享变量。</li></ol></li></ol><p><strong>所以，线程 A 无法直接访问线程 B 的工作内存，线程间通信必须经过主存。</strong></p><p>注意，根据 JMM 的规定，<strong>线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主存中读取</strong>。</p><h2 id="回答话术"><a href="#回答话术" class="headerlink" title="回答话术"></a>回答话术</h2><p><strong>JMM 是 Java 的多线程内存规则，通过 happens-before 保证可见性（volatile&#x2F;synchronized）、有序性（内存屏障）、原子性（Atomic类）。核心是让线程看到其他线程的最新修改。</strong></p><p>Java 内存模型 (JMM) 是一个抽象的概念模型，它规定了线程如何通过主内存进行交互。而具体的“工作内存”与“主内存”之间的数据同步，其底层是依赖于硬件（CPU）的缓存一致性协议来完成的，其中最著名的是 MESI 协议</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JMM</span><br><span class="hljs-keyword"></span>了解: 在cpu与内存之间 存在 一个缓冲区 目的是为了匹配二者之间运行速度不一致的问题<br><span class="hljs-keyword">JMM是什么: </span><span class="hljs-keyword">java </span>memory model定义了 <span class="hljs-keyword">Java </span>程序中的变量、线程如何和主存以及工作内存进行交互的规则。<br>它规定了线程如何通过主内存进行交互 线程安全问题<br><span class="hljs-keyword">JMM是JVM中对于线程安全保障的一种规范(接口)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">JMM为什么-底层原理</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">JMM保证三大特性 </span><br>原子性:通过<span class="hljs-keyword">synchronized和Lock保证 </span>多线程并发操作不可分割<br>可见性 MESI协议 基于硬件的一个一致性协议 主内存与线程的工作内存之间的一致性<br>有序性 内存屏障 可以通过<span class="hljs-keyword">synchronize和volatile来实现禁止指令重排</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">JMM如何使用(实现类)</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">synchronized</span><br><span class="hljs-keyword"></span>Lock<br>volatile 中文翻译: 不稳定的<br></code></pre></td></tr></table></figure><h3 id="什么是共享变量？"><a href="#什么是共享变量？" class="headerlink" title="什么是共享变量？"></a>什么是共享变量？</h3><p>对于每一个线程来说，栈都是私有的，而堆是共有的。</p><p>也就是说，在栈中的变量（局部变量、方法定义的参数、异常处理的参数）不会在线程之间共享，也就不会有内存可见性的问题，也不受内存模型的影响。而在堆中的变量是共享的，一般称之为共享变量。</p><p>所以，内存可见性]针对的是<strong>堆中的共享变量</strong>。</p><h3 id="如何保证内存可见性？"><a href="#如何保证内存可见性？" class="headerlink" title="如何保证内存可见性？"></a>如何保证内存可见性？</h3><p>那么怎么知道这个共享变量的被其他线程更新了呢？这就是 JMM 的功劳了，也是 JMM 存在的必要性之一。<strong>JMM 通过控制主存与每个线程的本地内存之间的交互，来提供内存可见性保证</strong>。</p><p>Java 中的 <a href="https://javabetter.cn/thread/volatile.html">volatile 关键字</a>可以保证多线程操作共享变量的可见性以及禁止指令重排序，<a href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>不仅保证可见性，同时也保证了原子性（互斥性）。</p><p>在更底层，JMM 通过内存屏障来实现内存的可见性以及禁止重排序。为了程序员更方便地理解，设计者提出了 happens-before 的概念（下文会细讲），它更加简单易懂，从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则，以及这些规则的具体实现方法。</p><h3 id="JMM-与-Java-运行时内存区域的区别"><a href="#JMM-与-Java-运行时内存区域的区别" class="headerlink" title="JMM 与 Java 运行时内存区域的区别"></a>JMM 与 Java 运行时内存区域的区别</h3><ul><li><p>区别</p><p>两者是不同的概念。JMM 是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开。而 Java 运行时内存的划分是具体的，是 JVM 运行 Java 程序时必要的内存划分。</p></li><li><p>联系</p><p>都存在私有数据区域和共享数据区域。一般来说，JMM 中的主存属于共享数据区域，包含了堆和方法区；同样，JMM 中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。</p></li></ul><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><ul><li>指令重排是为了提高 CPU 性能，但是可能会导致一些问题，比如多线程环境下的内存可见性问题。</li></ul><p>指令重排一般分为以下三种：</p><ul><li><strong>编译器优化重排</strong></li><li><strong>指令并行重排</strong></li><li><strong>内存系统重排</strong></li></ul><p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p><h2 id="happensbefore"><a href="#happensbefore" class="headerlink" title="happensbefore"></a>happensbefore</h2><p>happens-before 规则是 JMM 提供的强大的内存可见性保证，只要遵循 happens-before 规则，那么我们写的程序就能保证在 JMM 中具有强的内存可见性。</p><p>总之，<strong>如果操作 A happens-before 操作 B，那么操作 A 在内存上所做的操作对操作 B 都是可见的，不管它们在不在一个线程。</strong></p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p><img src="/./../img/image-20251217195628580.png" alt="image-20251217195628580"></p><pre><code class="hljs">volatile 不稳定的volatile是什么JMM规范的一种实现 即是一种轻量级的同步机制 所谓轻量的一种理解就是不保证原子性只保证有序性和可见性volatile为什么(原理)可见性 MESI协议 基于硬件的一个一致性协议 主内存与线程的工作内存之间的一致性有序性 内存屏障 可以通过synchronize和volatile来实现禁止指令重排volatile怎么用volatile 只能修饰变量 不能修饰方法需要注意的是synchronized 不能修饰变量 它可以修饰方法和代码块为了解决volatile不保证原子性的缺陷,可以使用原子类 原子类的底层是CAS</code></pre><h2 id="volatile-会禁止指令重排"><a href="#volatile-会禁止指令重排" class="headerlink" title="[volatile 会禁止指令重排]"></a>[volatile 会禁止指令重排]</h2><p>当我们使用 volatile 关键字来修饰一个变量时，Java 内存模型会插入内存屏障（一个处理器指令，可以对 CPU 或编译器重排序做出约束）来确保以下两点：</p><ul><li><p>写屏障（Write Barrier）：当一个 volatile 变量被写入时，写屏障确保在该屏障之前的所有变量的写入操作都提交到主内存。</p></li><li><p>读屏障（Read Barrier）：当读取一个 volatile 变量时，读屏障确保在该屏障之后的所有读操作都从主内存中读取。volatile 可以保证</p><p>线程可见性且提供了一定的有序性，但是无法保证原子性。</p><p>在 JVM 底层 volatile 是采用“内存屏障”来实现的。</p><p>观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码就能发现，加入 volatile 关键字时，会多出一个 lock 前缀指令，lock 前缀指令实际上相当于一个内存屏障（也称内存栅栏），内存屏障会提供 3 个功能：</p><ul><li><strong>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</strong></li><li><strong>它会强制将对缓存的修改操作立即写入主存；</strong></li><li><strong>如果是写操作，它会导致其他 CPU 中对应的缓存行无效。</strong></li></ul></li></ul><h2 id="Volatile和synchronized区别"><a href="#Volatile和synchronized区别" class="headerlink" title="Volatile和synchronized区别"></a>Volatile和synchronized区别</h2><table><thead><tr><th align="left">特性</th><th align="left"><code>volatile</code></th><th align="left"><code>synchronized</code></th></tr></thead><tbody><tr><td align="left"><strong>本质</strong></td><td align="left">变量访问修饰符</td><td align="left">方法或代码块修饰符</td></tr><tr><td align="left"><strong>原子性</strong></td><td align="left"><strong>不保证</strong>原子性（对单个读&#x2F;写是原子的，但复合操作如i++不是）</td><td align="left"><strong>保证</strong>原子性，整个同步块是一个不可分割的原子操作</td></tr><tr><td align="left"><strong>可见性</strong></td><td align="left"><strong>保证</strong>可见性</td><td align="left"><strong>保证</strong>可见性</td></tr><tr><td align="left"><strong>有序性</strong></td><td align="left"><strong>保证</strong>有序性（禁止指令重排序）</td><td align="left"><strong>保证</strong>有序性（一个unlock操作先于后面对同一个锁的lock操作）</td></tr><tr><td align="left"><strong>线程阻塞</strong></td><td align="left"><strong>不会</strong>引起线程阻塞</td><td align="left"><strong>会</strong>引起线程阻塞（互斥同步，是悲观锁）</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">单一变量的可见性、状态标志</td><td align="left">多行代码的复合操作，需要保证原子性</td></tr></tbody></table><h2 id="MESI（缓存一致性协议）"><a href="#MESI（缓存一致性协议）" class="headerlink" title="MESI（缓存一致性协议）"></a>MESI（缓存一致性协议）</h2><p>MESI是一种比较常用的缓存一致性协议，MESI表示缓存行的四种状态，分别是：<br>1、M(Modify) 表示共享数据只缓存在当前 CPU 缓存中，并且是被修改状态，也就是缓存的数据和主内存中的数据不一致<br>2、E(Exclusive) 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改<br>3、S(Shared) 表示数据可能被多个 CPU 缓存，并且各个缓存中的数据和主内存数据一致<br>4、I(Invalid) 表示缓存已经失效<br>在 MESI 协议中，每个缓存的缓存控制器不仅知道自己的读写操作，而且也监听(snoop)其它CPU的读写操作。<br>对于 MESI 协议，从 CPU 读写角度来说会遵循以下原则：<br><strong>CPU读请求</strong>：缓存处于 M、E、S 状态都可以被读取，I 状态CPU 只能从主存中读取数据<br><strong>CPU写请求</strong>：缓存处于 M、E 状态才可以被写。对于S状态的写，需要将其他CPU中缓存行置为无效才行。</p><p>end?</p>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode:回溯的j--和j-1和--j</title>
    <link href="/2025/09/15/leetcode-%E5%9B%9E%E6%BA%AF%E7%9A%84j-%E5%92%8Cj-1%E5%92%8C-j/"/>
    <url>/2025/09/15/leetcode-%E5%9B%9E%E6%BA%AF%E7%9A%84j-%E5%92%8Cj-1%E5%92%8C-j/</url>
    
    <content type="html"><![CDATA[<h1 id="x看问题"><a href="#x看问题" class="headerlink" title="x看问题"></a>x看问题</h1><p>为什么下面两段代码不一样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combine(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; ans =<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        dfs(n,k,<span class="hljs-type">path</span>,ans);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>    <span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> k, List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>, List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; ans) &#123;<br>        <span class="hljs-type">int</span> d =k-<span class="hljs-type">path</span>.size();<br>        <span class="hljs-keyword">if</span>(d==<span class="hljs-number">0</span>)&#123;<br>            ans.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(<span class="hljs-type">path</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j =i;j &gt;=d;j<span class="hljs-comment">--)&#123;</span><br>            <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(j);<br>            dfs(j<span class="hljs-number">-1</span>,k,<span class="hljs-type">path</span>,ans); //这是对的<br>            <span class="hljs-type">path</span>.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combine(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; ans =<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        dfs(n,k,<span class="hljs-type">path</span>,ans);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>    <span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> k, List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>, List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; ans) &#123;<br>        <span class="hljs-type">int</span> d =k-<span class="hljs-type">path</span>.size();<br>        <span class="hljs-keyword">if</span>(d==<span class="hljs-number">0</span>)&#123;<br>            ans.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(<span class="hljs-type">path</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j =i;j &gt;=d;j<span class="hljs-comment">--)&#123;</span><br>            <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(j);<br>            dfs(j<span class="hljs-comment">--,k,path,ans);//此处错了</span><br>            <span class="hljs-type">path</span>.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要的区别在于递归调用 <code>dfs</code> 时传入的第一个参数：</p><ol><li><strong>第一段代码:</strong> <code>dfs(j--, k, path, ans);</code></li><li><strong>第二段代码:</strong> <code>dfs(j - 1, k, path, ans);</code></li></ol><p><strong>关键点：<code>j--</code> vs <code>j - 1</code></strong></p><ul><li><strong><code>j - 1</code></strong>: 这是一个<strong>表达式</strong>，它计算 <code>j</code> 的值减 1，但<strong>不改变 <code>j</code> 本身的值</strong>。例如，如果 <code>j</code> 是 5，<code>j - 1</code> 的结果是 4，但 <code>j</code> 本身的值在这一行代码执行后仍然是 5。</li><li><strong><code>j--</code></strong>: 这是一个<strong>后置递减运算符</strong>。它会<strong>先返回 <code>j</code> 的当前值</strong>用于表达式（在这里是作为参数传递给 <code>dfs</code>），<strong>然后才将 <code>j</code> 本身的值减 1</strong>。</li></ul><p><strong>分析第一段代码 (<code>j--</code>):</strong></p><ol><li><p>假设当前循环中 <code>j</code> 的值是 5。</p></li><li><p>执行 <code>path.add(5);</code> 将 5 添加到当前路径 <code>path</code>。</p></li><li><p>执行</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">dfs</span>(j--, k, path, ans);<br></code></pre></td></tr></table></figure><p>：</p><ul><li>首先，<code>j--</code> 表达式的值是 <code>j</code> 的当前值，即 5。所以 <code>dfs</code> 被调用时，传入的第一个参数是 5。</li><li>然后，<code>j--</code> 运算符将 <code>j</code> 本身的值减 1。所以 <code>j</code> 的值现在变成了 4。</li></ul></li><li><p>当递归调用返回后，执行 <code>path.removeLast();</code> 移除刚刚添加的 5。</p></li><li><p>现在回到 <code>for</code> 循环的更新部分 (<code>j--</code>)。循环会再次执行 <code>j--</code>，将 <code>j</code> 的值从 4 减到 3。</p></li><li><p>下一次循环迭代时，<code>j</code> 的值是 3，而不是预期的 4。</p></li></ol><p><strong>问题所在：</strong></p><ul><li>在第一段代码中，<code>j--</code> 在 <code>dfs</code> 调用中不仅影响了传递给下一层递归的值（这是期望的，即传递 <code>j-1</code>），<strong>还修改了当前循环变量 <code>j</code> 本身的值</strong>。</li><li>这导致 <code>for</code> 循环的正常递减 (<code>j--</code>) 被 <code>dfs</code> 调用中的 <code>j--</code> 干扰，使得循环跳过了某些元素，无法正确地遍历所有可能的组合。</li><li>这会破坏回溯算法的正确性，导致生成的结果不完整或不正确。</li></ul><p><strong>分析第二段代码 (<code>j - 1</code>):</strong></p><ol><li><p>假设当前循环中 <code>j</code> 的值是 5。</p></li><li><p>执行 <code>path.add(5);</code> 将 5 添加到当前路径 <code>path</code>。</p></li><li><p>执行</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">dfs</span>(j - <span class="hljs-number">1</span>, k, path, ans);<br></code></pre></td></tr></table></figure><p>：</p><ul><li>计算 <code>j - 1</code>，结果是 4。将 4 作为第一个参数传递给 <code>dfs</code>。</li><li><code>j</code> 本身的值<strong>保持不变</strong>，仍然是 5。</li></ul></li><li><p>当递归调用返回后，执行 <code>path.removeLast();</code> 移除刚刚添加的 5。</p></li><li><p>回到 <code>for</code> 循环的更新部分 (<code>j--</code>)。<code>j</code> 的值从 5 减到 4。</p></li><li><p>下一次循环迭代时，<code>j</code> 的值是 4，符合预期。</p></li></ol><p><strong>结论：</strong></p><ul><li>第二段代码 (<code>j - 1</code>) 是正确的。它在递归调用时传递了正确的下一个起始值（<code>j - 1</code>），同时没有副作用地修改循环变量 <code>j</code>。</li><li>第一段代码 (<code>j--</code>) 是错误的。<code>j--</code> 运算符的副作用意外地修改了循环变量 <code>j</code>，导致循环逻辑出错，无法生成正确的组合结果。</li></ul><p>因此，两段代码的结果不一样，是因为第一段代码由于使用了 <code>j--</code> 而破坏了循环的正确迭代，导致算法逻辑错误。第二段代码使用 <code>j - 1</code> 是正确的实现方式。</p><h1 id="原因：j只能被循环修改"><a href="#原因：j只能被循环修改" class="headerlink" title="原因：j只能被循环修改"></a>原因：j只能被循环修改</h1>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode:快排模板</title>
    <link href="/2025/08/08/leetcode-%E5%BF%AB%E6%8E%92%E6%A8%A1%E6%9D%BF/"/>
    <url>/2025/08/08/leetcode-%E5%BF%AB%E6%8E%92%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>&#x2F;&#x2F; 快速排序函数（Hoare 分区方案实现）<br>void quickSort1(vector<int>&amp; nums, int l, int r) {<br>&#x2F;&#x2F; 1. 递归终止条件：当子数组长度为1或空时，无需排序<br>if (l &gt;&#x3D; r) return;</p><pre><code class="hljs">// 2. 初始化分区参数：// - i 初始在左边界左侧（l-1）// - j 初始在右边界右侧（r+1）// - 基准值 x 选中间元素（避免极端情况如全排序数组导致最坏时间复杂度）int i = l - 1, j = r + 1;int x = nums[(l + r) &gt;&gt; 1]; // 位运算代替 (l + r) / 2，等价且更高效// 3. Hoare 分区循环：双指针从两端向中间移动while (i &lt; j) &#123;    // 3.1 移动左指针 i：跳过所有小于 x 的元素，直到找到 &gt;=x 的元素    do i++; while (nums[i] &lt; x);    // 3.2 移动右指针 j：跳过所有大于 x 的元素，直到找到 &lt;=x 的元素    do j--; while (nums[j] &gt; x);    // 3.3 如果指针未交错，交换左右指针的元素（确保左边 &lt;=x，右边 &gt;=x）    if (i &lt; j) swap(nums[i], nums[j]);&#125;// 4. 递归排序左右子数组：// - 分区点为 j（因为当 i &gt;= j 时，j 是左半部分的最右端）// - 左子数组：[l, j]（所有元素 &lt;=x）// - 右子数组：[j+1, r]（所有元素 &gt;=x）quickSort1(nums, l, j);quickSort1(nums, j + 1, r);</code></pre><p>}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode:最小栈</title>
    <link href="/2025/07/24/leetcode-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2025/07/24/leetcode-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MinStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;top&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>]<br>[[],[<span class="hljs-number">-2</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">-3</span>],[],[],[],[]]<br><br>输出：<br>[null,null,null,null,<span class="hljs-number">-3</span>,null,<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>]<br><br>解释：<br><span class="hljs-symbol">MinStack</span> minStack = new <span class="hljs-symbol">MinStack</span>();<br>minStack.push(<span class="hljs-number">-2</span>);<br>minStack.push(<span class="hljs-number">0</span>);<br>minStack.push(<span class="hljs-number">-3</span>);<br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-3.</span><br>minStack.pop();<br>minStack.top();      --&gt; 返回 <span class="hljs-number">0.</span><br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-2.</span><br></code></pre></td></tr></table></figure><p> 字节一面 要求额外O（1）辅助空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    Stack&lt;Long&gt; st; <span class="hljs-comment">// 存储当前值相对于minVal的偏移量</span><br>    <span class="hljs-type">long</span> minVal; <span class="hljs-comment">// 存储最小值</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        minVal = <span class="hljs-number">0L</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (st.isEmpty()) &#123; <span class="hljs-comment">// 如果栈为空，则minVal为当前值，偏移量为0</span><br>            st.push(<span class="hljs-number">0L</span>);<br>            minVal = (<span class="hljs-type">long</span>)val;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果栈不为空</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> val - minVal; <span class="hljs-comment">// 计算当前值与minVal的偏移量</span><br>            st.push(diff); <span class="hljs-comment">// 入栈偏移量</span><br>            <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>) minVal = val; <span class="hljs-comment">// 更新最小值，用当前val更新minVal</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> st.pop(); <span class="hljs-comment">// 出栈偏移量</span><br>        <span class="hljs-comment">// 如果偏移量为负数，则minVal为更新过后的最小值，需要将minVal更新为前一个最小值</span><br>        <span class="hljs-comment">// 根据push时的式子 diff = val - minVal，有minVal = val - diff，其中val则为当前的minVal</span><br>        <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>) minVal -= diff;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> st.peek(); <span class="hljs-comment">// 获取偏移量</span><br>        <span class="hljs-comment">// 如果为正数，则 当前值 = minVal + 偏移量</span><br>        <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(minVal + diff);<br>        <span class="hljs-comment">// 如果为负数，则 当前值 = minVal</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)minVal;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)minVal;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode:环形链表分成三等份</title>
    <link href="/2025/07/23/leetcode-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%88%86%E6%88%90%E4%B8%89%E7%AD%89%E4%BB%BD/"/>
    <url>/2025/07/23/leetcode-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%88%86%E6%88%90%E4%B8%89%E7%AD%89%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<p>遇到了之前某度的一道链表题，虽然只是寥寥几字但却属实不简单，特将做题思路记录下来，能力有限，如果理解有误还请大佬指出</p><p>题目描述<br>给一个环形链表，请你将他三等分</p><p>思路分析<br>对于边界值的考虑<br>是否满足至少三个节点的条件，对于环形链表需要注意将环断开<br>if (!head) {<br>return [null, null, null];<br>}<br>&#x2F;&#x2F; 当前节点与下一节点相同，说明只有一个节点<br>if (!head.next || head.next &#x3D;&#x3D;&#x3D; head) {<br>head.next &#x3D; null;<br>return [head, null, null];<br>}</p><pre><code class="hljs">// 当前节点与下下个节点相同，说明只有两个节点if (head.next.next === head) &#123;    const next = head.next.next;    head.next = null;    next.next = null;    return [head, next, null];&#125;</code></pre><p>是否是三的倍数<br>我们判断是否是一个数的倍数，首先需要知道总的长度</p><p>如何统计环形链表的长度<br>&#x2F;&#x2F; 我们需要判断当前节点是否等于头结点，所以我们从头节点的下一个节点开始，所以从开始计数<br>let cur &#x3D; head.next;<br>let count &#x3D; 1;<br>while (cur.next &amp;&amp; cur !&#x3D;&#x3D; head) {<br>count +&#x3D; 1;<br>cur &#x3D; cur.next;<br>}<br>是三的倍数如何进行三等分<br>同比寻找中点的一个常见套路，定义一个两个指针，慢指针每次走一步，快指针每次走两步，当快指针到达尾部时，慢指针刚好指向中间节点。</p><pre><code class="hljs">// 快中慢三个指针，迭代结束时，恰好将链表三等分let p1 = head;let p2 = head.next;let p3 = head.next.next;while (p3!.next !== head) &#123;    p1 = p1.next;    p2 = p2.next.next;    p3 = p3.next.next.next;&#125;</code></pre><p>不是三的倍数如何进行三等分<br>此时每一份的数量并不一定是严格相等的，我们固定前两份的数量相同，剩下的就是最后一份的。例如链表总长度10，分为3,3,4；总长度11则为4,4,3。</p><pre><code class="hljs">// 结束时，p1位于的第一个等分点，p2位于第二个等分点let k = Math.floor(count / 3) - 1; while (k !== 0) &#123;    p1 = p1.next!;    p2 = p2!.next!.next!;    k -= 1; &#125;</code></pre><p>完整代码<br>const trisector &#x3D; (head: ListNode | null) &#x3D;&gt; {<br>&#x2F;&#x2F; 环形链表, 先处理边界，将环断开<br>if (!head) {<br>return [null, null, null];<br>}<br>&#x2F;&#x2F; 当前节点与下一节点相同，说明只有一个节点<br>if (!head.next || head.next &#x3D;&#x3D;&#x3D; head) {<br>head.next &#x3D; null;<br>return [head, null, null];<br>}</p><pre><code class="hljs">// 当前节点与下下个节点相同，说明只有两个节点if (head.next.next === head) &#123;    const next = head.next.next;    head.next = null;    next.next = null;    return [head, next, null];&#125;// 处理满足至少三个节点的情况let p1 = head;let p2 = head.next;let p3 = head.next.next;// 计算节点个数let cur = head.next;let count = 1; // 计算结束条件是当前指针是否指向头部，从头结点的后一个节点开始，所以起始数为1while (cur.next &amp;&amp; cur !== head) &#123;    count += 1;    cur = cur.next;&#125;// 分情况讨论是否是3的倍数if (count % 3 === 0) &#123;    // 快中慢三个指针，迭代结束时，恰好将链表三等分    while (p3!.next !== head) &#123;        p1 = p1.next!;        p2 = p2!.next!.next!;        p3 = p3!.next!.next!.next;    &#125;    // 注意： 此时指针指向每个等分的尾部，调整指向获取头部    let a1 = p3!.next;    let a2 = p1!.next;    let a3 = p2!.next;    // 断开链    p1.next = null;    p2.next = null;    p3!.next = null;    return [a1, a2, a3];&#125; else &#123;    let k = Math.floor(count / 3) - 1; // 决定前两等分的个数，可以通过4 4 3，3 3 4两种结果来推理    // 结束时，p1位于的第一个等分点，p2位于第二个等分点    while (k !== 0) &#123;        p1 = p1.next!;        p2 = p2!.next!.next!;        k -= 1;    &#125;    // 指向尾部，即最后一个等分点    while (p3!.next !== head) &#123;        p3 = p3!.next;    &#125;    // 等分点的下一个节点，是下一段等分的开始    let a1 = p3!.next;    let a2 = p1!.next;    let a3 = p2!.next;    // 断开链    p1.next = null;    p2.next = null;    p3!.next = null;    return [a1, a2, a3];&#125;</code></pre><p>};<br>验证代码<br>class ListNode {<br>val: number;<br>next: ListNode | null;<br>constructor(val?: number, next?: ListNode | null) {<br>this.val &#x3D; val &#x3D;&#x3D;&#x3D; undefined ? 0 : val;<br>this.next &#x3D; next &#x3D;&#x3D;&#x3D; undefined ? null : next;<br>}<br>}</p><p>const makeCircleListNode &#x3D; (arr: number[]) &#x3D;&gt; {<br>const dummy &#x3D; new ListNode();<br>let cur &#x3D; dummy;<br>arr.forEach(item &#x3D;&gt; {<br>cur.next &#x3D; new ListNode(item);<br>cur &#x3D; cur.next;<br>});<br>cur.next &#x3D; dummy.next;<br>return dummy.next;<br>};<br>const circleList &#x3D; makeCircleListNode([1, 2, 3, 4, 5, 6, 7, 8, 9]);<br>trisector(circleList)<br>总结<br>针对普通链表，常见的有迭代和递归处理，需要判断好边界的情况<br>环形链表需要注意断开链，不然可能会进入死循环<br>双指针在栈和队列中很常见，对于快慢指针判断中点的小套路也可以引申到其他题中</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>146:LRU缓存</title>
    <link href="/2025/07/23/%E5%8A%9B%E6%89%A3146LRU%E7%BC%93%E5%AD%98/"/>
    <url>/2025/07/23/%E5%8A%9B%E6%89%A3146LRU%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>说说怎么背这道题。</p><p>需要运用 双端队列和哈希表，这是一种复合数据结构，如python中的OrderedDict<br>哈希表只是根据key,能找到对应的node,即&lt;key,node*&gt;<br>双端队列是双值双指针的形式,key,value,*prev,*next<br>哈希表的操作，API已经提供了，现在就是看自己创建双端队列，并看其需要哪些操作。<br>python中API叫 move_to_end，所谓move操作，就是一个删除操作，一个插入操作。<br>所以双端队列的基本操作需要删掉节点，和插入节点到最新这两个。<br>3.到目前位置双端队列和哈希表的基本操作都够了，现在就是LRUCache这个复合类需要哪些操作。get_node这个名字起的很好，我开始觉得应该叫做find_node,因为是根据key，找到返回node,找不到返回nullptr,但这个题让我们写一个API叫做put,根据key，找到返回value，找不到返回-1。那我们这个额外的API叫做get_node那就再合适不过了。<br>4.到目前位置put,和get怎么写其实就很简单了。<br>get操作，只会更新双端队列类的元素<br>put操作，即会更新双端队列类的操作，也会更新哈希表类的元素。<br>总结一下：<br>1.两个数据结构，双端队列和哈希表<br>2.需要自己自定义双端队列和其基本操作删除和插入操作<br>3.定义get_node API，这个才是这个复合数据结构的操作，剩下就是记得怎么更新双端队列和哈希表了</p><p>额外说下dummy的作用：<br>1.快速找到双端队列中最末尾的节点<br>2.插入时，快速找到最新位置<br>3.操作可以不区分head节点和tail节点，让其更普通节点一样</p><p>总结：同化了head节点和tail节点的操作，要提供了快速找到head和tail的方法。额外的一点空间却极大简化的操作。妙！</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>List一些问题</title>
    <link href="/2025/07/20/List%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2025/07/20/List%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>在Java集合中，ArrayList是最常用到的数据结构，无论是在日常开发还是面试中，但是很多人对它的源码并不了解。下面提问几个问题，检验一下大家对ArrayList的了解程度。</p><ol><li>ArrayList的初始容量是多少？（90%的人都会答错）</li><li>ArrayList的扩容机制</li><li>并发修改ArrayList元素会有什么问题</li><li>如何快速安全的删除ArrayList中的元素</li></ol><p>接下来一块分析一下ArrayList的源码，看完ArrayList源码之后，可以轻松解答上面四个问题。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>ArrayList底层基于数组实现，可以随机访问，内部使用一个Object数组来保存元素。它维护了一个 <code>elementData</code> 数组和一个 <code>size</code> 字段，<code>elementData</code>数组用来存放元素，<code>size</code>字段用于记录元素个数。它允许元素是null，可以动态扩容。</p><p><img src="https://pic4.zhimg.com/v2-95923250063b6d7327c36e08fdbbae73_1440w.jpg" alt="img"></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h2><p>当我们调用ArrayList的构造方法的时候，底层实现逻辑是什么样的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用无参构造方法，初始化ArrayList</span><br>List&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 调用有参构造方法，初始化ArrayList，指定容量为10</span><br>List&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>看一下底层源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认容量大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 空数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">// 默认容量的数组对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">// 存储元素的数组</span><br><span class="hljs-keyword">transient</span> Object[] elementData;<br><br><span class="hljs-comment">// 数组中元素个数，默认是0</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-comment">// 无参初始化，默认是空数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-comment">// 有参初始化，指定容量大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 直接使用指定的容量大小</span><br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+initialCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到当我们调用ArrayList的无参构造方法 <code>new ArraryList&lt;&gt;()</code> 的时候，只是初始化了一个空对象，并没有指定数组大小，所以初始容量是零。至于什么时候指定数组大小，接着往下看。</p><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a><strong>添加元素</strong></h2><p>再看一下往ArrayList种添加元素时，调用的 <code>add() </code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>  <span class="hljs-comment">// 确保数组容量够用，size是元素个数</span><br>  ensureCapacityInternal(size + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 直接在下个位置赋值</span><br>  elementData[size++] = e;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 确保数组容量够用</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><br><span class="hljs-comment">// 计算所需最小容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>   <span class="hljs-comment">// 如果数组等于空数组，就设置默认容量为10</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><br><span class="hljs-comment">// 确保容量够用</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>   <span class="hljs-comment">// 如果所需最小容量大于数组长度，就进行扩容</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>看一下扩容逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 扩容，就是把旧数据拷贝到新数组里面</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>  <span class="hljs-comment">// 计算新数组的容量大小，是旧容量的1.5倍</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">// 如果扩容后的容量小于最小容量，扩容后的容量就等于最小容量</span><br>  <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>    newCapacity = minCapacity;<br><br>  <span class="hljs-comment">// 如果扩容后的容量大于Integer的最大值，就用Integer最大值</span><br>  <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>    newCapacity = hugeCapacity(minCapacity);<br> <br>  <span class="hljs-comment">// 扩容并赋值给原数组</span><br>  elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：</p><ul><li>扩容的触发条件是数组全部被占满</li><li>扩容是以旧容量的1.5倍扩容，并不是2倍扩容</li><li>最大容量是Integer的最大值</li><li>添加元素时，没有对元素校验，允许为null，也允许元素重复。</li></ul><p>再看一下数组拷贝的逻辑，这里都是Arrays类里面的方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> original  原数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> newLength 新的容量大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="hljs-type">int</span> newLength) &#123;<br>    <span class="hljs-keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="hljs-type">int</span> newLength, Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>[]&gt; newType) &#123;<br>    <span class="hljs-comment">// 创建一个新数组，容量是新的容量大小</span><br>    T[] copy = ((Object)newType == (Object)Object[].class)<br>        ? (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newLength]<br>        : (T[]) Array.newInstance(newType.getComponentType(), newLength);<br>   <span class="hljs-comment">// 把原数组的元素拷贝到新数组</span><br>    System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,<br>                     Math.min(original.length, newLength));<br>    <span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终调用了System类的数组拷贝方法，是native方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> src     原数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> srcPos  原数组的开始位置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dest    目标数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> destPos 目标数组的开始位置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> length  被拷贝的长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-type">int</span>  srcPos,</span><br><span class="hljs-params">                                    Object dest, <span class="hljs-type">int</span> destPos,</span><br><span class="hljs-params">                                    <span class="hljs-type">int</span> length)</span>;<br></code></pre></td></tr></table></figure><p>总结一下ArrayList的 <code>add()</code> 方法的逻辑：</p><ol><li>检查容量是否够用，如果够用，直接在下一个位置赋值结束。</li><li>如果是第一次添加元素，则设置容量默认大小为10。</li><li>如果不是第一次添加元素，并且容量不够用，则执行扩容操作。扩容就是创建一个新数组，容量是原数组的1.5倍，再把原数组的元素拷贝到新数组，最后用新数组对象覆盖原数组。</li></ol><p>需要注意的是，每次扩容都会创建新数组和拷贝数组，会有一定的时间和空间开销。在创建ArrayList的时候，如果我们可以提前预估元素的数量，最好通过有参构造函数，设置一个合适的初始容量，以减少动态扩容的次数。</p><h2 id="删除单个元素"><a href="#删除单个元素" class="headerlink" title="删除单个元素"></a><strong>删除单个元素</strong></h2><p>再看一下删除元素的方法 <code>remove()</code> 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>   <span class="hljs-comment">// 判断要删除的元素是否为null</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>       <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>           <span class="hljs-comment">// 如果和当前位置上的元素相等，就删除当前位置上的元素</span><br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>           <span class="hljs-comment">// 如果和当前位置上的元素相等，就删除当前位置上的元素</span><br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除该位置上的元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    modCount++;<br>   <span class="hljs-comment">// 计算需要移动的元素的个数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>       <span class="hljs-comment">// 从index+1位置开始拷贝，也就是后面的元素整体向左移动一个位置</span><br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index, numMoved);<br>   <span class="hljs-comment">// 设置数组最后一个元素赋值为null，防止会导致内存泄漏</span><br>    elementData[--size] = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除元素的流程是：</p><ol><li>判断要删除的元素是否为null，如果为null，则遍历数组，使用双等号比较元素是否相等。如果不是null，则使用 <code>equals()</code> 方法比较元素是否相等。这里就显得啰嗦了，可以使用 <code>Objects.equals()</code>方法，合并ifelse逻辑。</li><li>如果找到相等的元素，则把后面位置的所有元素整体相左移动一个位置，并把数组最后一个元素赋值为null结束。</li></ol><p>可以看到遍历数组的时候，找到相等的元素，删除就结束了。如果ArrayList中存在重复元素，也只会删除其中一个元素。</p><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a><strong>批量删除</strong></h2><p>再看一下批量删除元素方法 <code>removeAll()</code> 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 批量删除ArrayList和集合c都存在的元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> &#123;<br>    <span class="hljs-comment">// 非空校验</span><br>    Objects.requireNonNull(c);<br>    <span class="hljs-comment">// 批量删除</span><br>    <span class="hljs-keyword">return</span> batchRemove(c, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">batchRemove</span><span class="hljs-params">(Collection&lt;?&gt; c, <span class="hljs-type">boolean</span> complement)</span>&#123;<br>    <span class="hljs-keyword">final</span> Object[] elementData = <span class="hljs-built_in">this</span>.elementData;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, w = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">modified</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (; r &lt; size; r++)<br>            <span class="hljs-keyword">if</span> (c.contains(elementData[r]) == complement)<br>                <span class="hljs-comment">// 把需要保留的元素左移</span><br>                elementData[w++] = elementData[r];<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-comment">// 当出现异常情况的时候，可能不相等</span><br>        <span class="hljs-keyword">if</span> (r != size) &#123;<br>            <span class="hljs-comment">// 可能是其它线程添加了元素，把新增的元素也左移</span><br>            System.arraycopy(elementData, r,<br>                             elementData, w,<br>                             size - r);<br>            w += size - r;<br>        &#125;<br>       <span class="hljs-comment">// 把不需要保留的元素设置为null</span><br>        <span class="hljs-keyword">if</span> (w != size) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> w; i &lt; size; i++)<br>                elementData[i] = <span class="hljs-literal">null</span>;<br>            modCount += size - w;<br>            size = w;<br>            modified = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> modified;<br>&#125;<br></code></pre></td></tr></table></figure><p>批量删除元素的逻辑，并不是大家想象的：</p><blockquote><p>遍历数组，判断要删除的集合中是否包含当前元素，如果包含就删除当前元素。删除的流程就是把后面位置的所有元素整体左移，然后把最后位置的元素设置为null。</p></blockquote><p>这样删除的操作，涉及到多次的数组拷贝，性能较差，而且还存在并发修改的问题，就是一边遍历，一边更新原数组。 批量删除元素的逻辑，设计充满了巧思，具体流程就是：</p><ol><li>把需要保留的元素移动到数组左边，使用下标 <code>w</code> 做统计，下标 <code>w</code> 左边的是需要保留的元素，下标 <code>w</code> 右边的是需要删除的元素。</li><li>虽然ArrayList不是线程安全的，也考虑了并发修改的问题。如果上面过程中，有其他线程新增了元素，把新增的元素也移动到数组左边。</li><li>最后把数组中下标 <code>w</code> 右边的元素都设置为null。</li></ol><p>所以当需要批量删除元素的时候，尽量使用 <code>removeAll()</code> 方法，性能更好。</p><h2 id="并发修改的问题"><a href="#并发修改的问题" class="headerlink" title="并发修改的问题"></a><strong>并发修改的问题</strong></h2><p>当遍历ArrayList的过程中，同时增删ArrayList中的元素，会发生什么情况？测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建ArrayList，并添加4个元素</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 遍历ArrayList</span><br>        <span class="hljs-keyword">for</span> (Integer key : list) &#123;<br>            <span class="hljs-comment">// 判断如果元素等于2，则删除</span><br>            <span class="hljs-keyword">if</span> (key.equals(<span class="hljs-number">2</span>)) &#123;<br>                list.remove(key);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException<br> at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:911)<br> at java.util.ArrayList$Itr.next(ArrayList.java:861)<br> at com.yideng.Test.main(Test.java:14)<br></code></pre></td></tr></table></figure><p>报出了并发修改的错误，<code>ConcurrentModificationException</code>。 这是因为 <code>forEach</code> 使用了ArrayList内置的迭代器，这个迭代器在迭代的过程中，会校验修改次数 <code>modCount</code>，如果 <code>modCount</code> 被修改过，则抛出<code>ConcurrentModificationException</code>异常，快速失败，避免出现不可预料的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ArrayList内置的迭代器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">int</span> cursor;       <br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br>    <br>    <span class="hljs-comment">// 迭代下个元素</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 校验 modCount</span><br>        checkForComodification();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>        <span class="hljs-keyword">if</span> (i &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        cursor = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> (E)elementData[lastRet = i];<br>    &#125;<br><br>    <span class="hljs-comment">// 校验 modCount 是否被修改过</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要安全的删除某个元素，可以使用 <code>remove(int index)</code> 或者 <code>removeIf()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建ArrayList，并添加4个元素</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 使用 remove(int index) 删除元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (list.get(i).equals(<span class="hljs-number">2</span>)) &#123;<br>                list.remove(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 使用removeIf删除元素</span><br>        list.removeIf(key -&gt; key.equals(<span class="hljs-number">2</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>现在可以回答文章开头提出的问题了吧：</p><ol><li>ArrayList的初始容量是多少？</li></ol><p>答案：初始容量是0，在第一次添加元素的时候，才会设置容量为10。</p><ol><li>ArrayList的扩容机制</li></ol><p>答案：</p><ol><li>创建新数组，容量是原来的1.5倍。</li><li>把旧数组元素拷贝到新数组中</li><li>使用新数组覆盖旧数组对象</li><li>并发修改ArrayList元素会有什么问题</li></ol><p>答案：会快速失败，抛出<code>ConcurrentModificationException</code>异常。</p><ol><li>如何快速安全的删除ArrayList中的元素</li></ol><p>答案：使用<code>remove(int index)</code> 、 <code>removeIf()</code> 或者 <code>removeAll()</code> 方法。 我们知道ArrayList并不是线程安全的，原因是它的 <code>add()</code> 、<code>remove()</code> 方法、<code>扩容</code>操作都没有加锁，多个线程并发操作ArrayList的时候，会出现数据不一致的情况。 想要线程安全，其中一种方式是初始化ArrayList的时候使用 <code>Collections.synchronizedCollection()</code> 修饰。这样ArrayList所有操作都变成同步操作，性能较差。还有一种性能较好，又能保证线程安全的方式是使用 <code>CopyOnWriteArrayList</code>，就是下章要讲的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一种方式，使用 Collections.synchronizedCollection() 修饰</span><br>List&lt;Integer&gt; list1 = Collections.synchronizedCollection(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br><br><span class="hljs-comment">// 第二种方式，使用 CopyOnWriteArrayList</span><br>List&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>右视图</title>
    <link href="/2025/07/11/%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <url>/2025/07/11/%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1：</strong></p><p>**输入：**root &#x3D; [1,2,3,null,5,null,4]</p><p><strong>输出：</strong>[1,3,4]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png" alt="img"></p><p><strong>示例 2：</strong></p><p>**输入：**root &#x3D; [1,2,3,4,null,null,null,5]</p><p><strong>输出：</strong>[1,3,4,5]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png" alt="img"></p><p><strong>示例 3：</strong></p><p>**输入：**root &#x3D; [1,null,3]</p><p><strong>输出：</strong>[1,3]</p><p><strong>示例 4：</strong></p><p>**输入：**root &#x3D; []</p><p><strong>输出：</strong>[]</p><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,100]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>方法一：深度优先搜索<br>思路</p><p>我们对树进行深度优先搜索，在搜索过程中，我们总是先访问右子树。那么对于每一层来说，我们在这层见到的第一个结点一定是最右边的结点。</p><p>算法</p><p>这样一来，我们可以存储在每个深度访问的第一个结点，一旦我们知道了树的层数，就可以得到最终的结果数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        dfs(root, <span class="hljs-number">1</span>, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> i, List&lt;Integer&gt; ans)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &gt; ans.size()) &#123;<br>            ans.add(node.val);<br>        &#125;<br>        dfs(node.right, ++i, ans);<br>        dfs(node.left, i, ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h4><p><strong>思路</strong></p><p>我们可以对二叉树进行层次遍历，那么对于每层来说，最右边的结点一定是最后被遍历到的。二叉树的层次遍历可以用广度优先搜索实现。</p><p><strong>算法</strong></p><p>执行广度优先搜索，左结点排在右结点之前，这样，我们对每一层都从左到右访问。因此，只保留每个深度最后访问的结点，我们就可以在遍历完整棵树后得到每个深度最右的结点。除了将栈改成队列，并去除了 <code>rightmost_value_at_depth</code> 之前的检查外，算法没有别的改动。</p><p><img src="https://assets.leetcode-cn.com/solution-static/199/fig2.png" alt="fig2"></p><p>上图表示了同一个示例，红色结点自上而下组成答案，边缘以访问顺序标号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> size;<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (size == temp) &#123;<br>                    ans.add(poll.val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (poll.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(poll.right);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (poll.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(poll.left);<br>                &#125;<br>                size--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>讲解#大括号和$大括号</title>
    <link href="/2025/07/10/Mybatis%E7%9A%84%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"/>
    <url>/2025/07/10/Mybatis%E7%9A%84%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhida.zhihu.com/search?content_id=113073721&content_type=Article&match_order=1&q=Mybatis&zhida_source=entity">Mybatis</a>的<a href="https://zhida.zhihu.com/search?content_id=113073721&content_type=Article&match_order=1&q=Mapper%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6&zhida_source=entity">Mapper映射文件</a>中，有两种方式可以引用形参变量进行取值: #{} 和 ${}。本文将简述两种方式的区别和适用场景</p><h2 id="取值引用"><a href="#取值引用" class="headerlink" title="取值引用"></a>取值引用</h2><h2 id="方式"><a href="#方式" class="headerlink" title="#{} 方式"></a>#{} 方式</h2><p>#{}: 解析为SQL时，会将形参变量的值取出，并自动给其添加引号。 例如：当实参username&#x3D;”Amy”时，传入下Mapper映射文件后</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">......<br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findByName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentResultMap&quot;</span>&gt;</span><br>        SELECT * FROM user WHERE username=#&#123;value&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    ....<br></code></pre></td></tr></table></figure><p>SQL将解析为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> username<span class="hljs-operator">=</span>&quot;Amy&quot;<br></code></pre></td></tr></table></figure><h2 id="方式-1"><a href="#方式-1" class="headerlink" title="${} 方式"></a>${} 方式</h2><p>${}: 解析为SQL时，将形参变量的值直接取出，直接拼接显示在SQL中</p><p>例如：当实参username&#x3D;”Amy”时，传入下Mapper映射文件后</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">......<br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findByName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentResultMap&quot;</span>&gt;</span><br>        SELECT * FROM user WHERE username=$&#123;value&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    ....<br></code></pre></td></tr></table></figure><p>SQL将解析如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> username<span class="hljs-operator">=</span>Amy<br></code></pre></td></tr></table></figure><p>显而该SQL无法正常执行，故需要在mppaer映射文件中的${value}前后手动添加引号，如下所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">......<br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findByName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentResultMap&quot;</span>&gt;</span><br>        SELECT * FROM user WHERE username=&#x27;$&#123;value&#125;&#x27;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    ....<br></code></pre></td></tr></table></figure><p>SQL将解析为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Amy&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><p>${}方式是将形参和SQL语句直接拼接形成完整的SQL命令后，再进行编译，所以可以通过精心设计的形参变量的值，来改变原SQL语句的使用意图从而产生安全隐患，即为<a href="https://zhida.zhihu.com/search?content_id=113073721&content_type=Article&match_order=1&q=SQL%E6%B3%A8%E5%85%A5&zhida_source=entity">SQL注入</a>攻击。现举例说明：</p><p>现有Mapper映射文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">......<br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findByName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentResultMap&quot;</span>&gt;</span><br>        SELECT * FROM user WHERE username=&#x27;$&#123;value&#125;&#x27;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    ....<br></code></pre></td></tr></table></figure><p>当 username &#x3D; “‘ OR 1&#x3D;1 OR ‘“ 传入后，${}将变量内容直接和SQL语句进行拼接，结果如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">OR</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">OR</span> <span class="hljs-string">&#x27;&#x27;</span>;<br></code></pre></td></tr></table></figure><p>显而易见，上述语句将把整个数据库内容直接暴露出来了</p><p>#{}方式则是先用占位符代替参数将SQL语句先进行<a href="https://zhida.zhihu.com/search?content_id=113073721&content_type=Article&match_order=1&q=%E9%A2%84%E7%BC%96%E8%AF%91&zhida_source=entity">预编译</a>，然后再将参数中的内容替换进来。由于SQL语句已经被预编译过，其SQL意图将无法通过非法的参数内容实现更改，其参数中的内容，无法变为SQL命令的一部分。故，<strong>#{}可以防止SQL注入而${}却不行</strong></p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><h2 id="和-均适用场景"><a href="#和-均适用场景" class="headerlink" title="#{} 和 ${} 均适用场景"></a>#{} 和 ${} 均适用场景</h2><p>由于SQL注入的原因，${}和#{}在都可以使用的场景下，很明显推荐使用#{}。这里除了上文的WHERE语句例子，再介绍一个LIKE模糊查询的场景(username &#x3D; “Amy”):</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAddByName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentResultMap&quot;</span>&gt;</span><br>        SELECT * FROM user WHERE username LIKE &#x27;%$&#123;value&#125;%&#x27;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>该SQL解析为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Amy%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>上述通过${}虽然可以实现对包含”Amy”对模糊查询，但是不安全，可以改用#{}，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAddByName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentResultMap&quot;</span>&gt;</span><br>        SELECT * FROM USER WHERE username LIKE CONCAT(&#x27;%&#x27;, #&#123;username&#125;, &#x27;%&#x27;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>该SQL解析为下文所示，其效果和上文方式一致</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> CONCAT(<span class="hljs-string">&#x27;%&#x27;</span>, <span class="hljs-string">&#x27;Amy&#x27;</span>,<span class="hljs-string">&#x27;%&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="只能使用-的场景"><a href="#只能使用-的场景" class="headerlink" title="只能使用${}的场景"></a>只能使用${}的场景</h2><p>由于#{}会给参数内容自动加上引号，会在有些需要表示字段名、表名的场景下，SQL将无法正常执行。现举一例说明：</p><p>期望查询结果按sex字段升序排列，参数String orderCol &#x3D; “sex”,mapper映射文件使用#{}：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAddByName3&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentResultMap&quot;</span>&gt;</span><br>        SELECT * FROM USER WHERE username LIKE &#x27;%Am%&#x27; ORDER BY #&#123;value&#125; ASC<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>则SQL解析及执行结果如下所示，很明显 ORDER 子句的字段名错误的被加上了引号，致使查询结果没有按期排序输出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Am%&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;sex&#x27;</span> <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><p><img src="https://pica.zhimg.com/v2-8422c3a75cc036904ba7e6f3b4a7cb76_1440w.jpg" alt="img"></p><p>这时，现改为${}测试效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAddByName3&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentResultMap&quot;</span>&gt;</span><br>        SELECT * FROM USER WHERE username LIKE &#x27;%Am%&#x27; ORDER BY $&#123;value&#125; ASC<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>则SQL解析及执行结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Am%&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sex <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>${}是Spring框架中使用的占位符，也被称为属性占位符。它用于在配置文件中引用外部属性或配置项的值。例如，可以在Spring配置文件中使用${database.url}来引用数据库连接的URL。这个占位符会在运行时被解析，并替换为实际的属性值。${}占位符通常在Spring的配置文件（如application.properties）中使用。<br>以及：</p><p>还有传map的时候key必须用${}</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原始数据类型不能为null</title>
    <link href="/2025/07/05/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8D%E8%83%BD%E4%B8%BAnull/"/>
    <url>/2025/07/05/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8D%E8%83%BD%E4%B8%BAnull/</url>
    
    <content type="html"><![CDATA[<p>在 Java 中，<strong>原始数据类型（基本数据类型）不能为 <code>null</code></strong>，这是由 Java 的语言设计和类型系统决定的。以下是详细解释：</p><hr><h3 id="1-基本数据类型与引用类型的区别"><a href="#1-基本数据类型与引用类型的区别" class="headerlink" title="1. 基本数据类型与引用类型的区别"></a><strong>1. 基本数据类型与引用类型的区别</strong></h3><p>Java 的数据类型分为两类：</p><ul><li><p><strong>基本数据类型（Primitive Types）</strong>：<br>包括 <code>int</code>、<code>double</code>、<code>boolean</code> 等，它们是值类型，直接存储具体的数值（如 <code>int</code> 存储整数，<code>boolean</code> 存储 <code>true</code> 或 <code>false</code>）。<br><strong>特点</strong>：</p><ul><li>不能为 <code>null</code>，因为它们的存储单元直接包含值。</li><li>默认值是固定的（例如 <code>int</code> 默认为 <code>0</code>，<code>boolean</code> 默认为 <code>false</code>）。</li></ul></li><li><p><strong>引用类型（Reference Types）</strong>：<br>包括类（如 <code>String</code>）、接口、数组等，它们存储的是对象的引用（内存地址）。<br><strong>特点</strong>：</p><ul><li>可以为 <code>null</code>，表示该引用不指向任何对象。</li></ul></li></ul><hr><h3 id="2-为什么基本类型不能为-null"><a href="#2-为什么基本类型不能为-null" class="headerlink" title="2. 为什么基本类型不能为 null"></a><strong>2. 为什么基本类型不能为 <code>null</code></strong></h3><h4 id="1-内存模型设计"><a href="#1-内存模型设计" class="headerlink" title="(1) 内存模型设计"></a><strong>(1) 内存模型设计</strong></h4><ul><li><strong>基本类型直接存储值</strong>：<br>例如，<code>int a = 5;</code> 中的 <code>a</code> 是一个 4 字节的内存空间，直接存储整数 <code>5</code>，而不是指向某个对象的地址。因此，它无法表示 “无值” 或 <code>null</code>。</li><li><strong>引用类型存储地址</strong>：<br>例如，<code>Integer b = null;</code> 中的 <code>b</code> 是一个 4 字节（32 位 JVM）或 8 字节（64 位 JVM）的内存空间，存储的是对象的地址。<code>null</code> 表示该地址无效（未指向任何对象）。</li></ul><h4 id="2-类型系统的安全性"><a href="#2-类型系统的安全性" class="headerlink" title="(2) 类型系统的安全性"></a><strong>(2) 类型系统的安全性</strong></h4><ul><li><strong>基本类型的意义明确</strong>：<br><code>int</code> 表示整数，<code>boolean</code> 表示布尔值。它们的取值范围是固定的（如 <code>boolean</code> 只能是 <code>true</code> 或 <code>false</code>），没有 “未定义” 的状态。</li><li><strong>引用类型的灵活性</strong>：<br>引用类型可以通过 <code>null</code> 表示 “未初始化” 或 “无效值”，但这也带来了潜在的 <code>NullPointerException</code> 风险。</li></ul><h4 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="(3) 性能优化"></a><strong>(3) 性能优化</strong></h4><ul><li><strong>基本类型的高效性</strong>：<br>基本类型直接存储在栈内存中，访问速度更快。如果允许 <code>null</code>，就需要额外的检查和处理，降低性能。</li><li><strong>引用类型的开销</strong>：<br>引用类型需要分配堆内存，并通过地址访问，天然支持 <code>null</code> 的语义。</li></ul><hr><h3 id="3-典型错误示例"><a href="#3-典型错误示例" class="headerlink" title="3. 典型错误示例"></a><strong>3. 典型错误示例</strong></h3><h4 id="1-错误代码"><a href="#1-错误代码" class="headerlink" title="(1) 错误代码"></a><strong>(1) 错误代码</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 编译错误！</span><br></code></pre></td></tr></table></figure><ul><li><strong>原因</strong>：<code>int</code> 是基本类型，不能存储 <code>null</code>（只能存储整数）。</li><li><strong>正确做法</strong>：使用包装类 <code>Integer</code>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 合法</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-错误比较"><a href="#2-错误比较" class="headerlink" title="(2) 错误比较"></a><strong>(2) 错误比较</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 编译错误！</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>原因</strong>：<code>boolean</code> 是基本类型，不能与 <code>null</code> 比较。</li><li><strong>正确做法</strong>：使用包装类 <code>Boolean</code>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 合法</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="4-如何处理可能为-null-的数值"><a href="#4-如何处理可能为-null-的数值" class="headerlink" title="4. 如何处理可能为 null 的数值"></a><strong>4. 如何处理可能为 <code>null</code> 的数值</strong></h3><p>如果需要表示一个可能为 <code>null</code> 的数值，必须使用基本类型的包装类（如 <code>Integer</code>、<code>Double</code>、<code>Boolean</code>）。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从数据库查询可能为 null 的数值</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> getAgeFromDatabase(); <span class="hljs-comment">// 可能返回 null</span><br><br><span class="hljs-keyword">if</span> (age == <span class="hljs-literal">null</span>) &#123;<br>    System.out.println(<span class="hljs-string">&quot;年龄未提供&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;年龄为：&quot;</span> + age);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-自动装箱与拆箱的陷阱"><a href="#5-自动装箱与拆箱的陷阱" class="headerlink" title="5. 自动装箱与拆箱的陷阱"></a><strong>5. 自动装箱与拆箱的陷阱</strong></h3><p>Java 提供了<strong>自动装箱（Autoboxing）</strong> 和 <strong>拆箱（Unboxing）</strong> 机制，但需注意以下问题：</p><h4 id="1-自动拆箱可能导致-NullPointerException"><a href="#1-自动拆箱可能导致-NullPointerException" class="headerlink" title="(1) 自动拆箱可能导致 NullPointerException"></a><strong>(1) 自动拆箱可能导致 <code>NullPointerException</code></strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> num; <span class="hljs-comment">// 自动拆箱：抛出 NullPointerException</span><br></code></pre></td></tr></table></figure><ul><li><strong>原因</strong>：<code>num</code> 是 <code>null</code>，无法转换为基本类型 <code>int</code>。</li></ul><h4 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="(2) 解决方法"></a><strong>(2) 解决方法</strong></h4><p>在拆箱前进行 <code>null</code> 检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (num != <span class="hljs-literal">null</span>) ? num : <span class="hljs-number">0</span>; <span class="hljs-comment">// 安全处理</span><br></code></pre></td></tr></table></figure><hr><h3 id="6-为什么-Java-设计如此？"><a href="#6-为什么-Java-设计如此？" class="headerlink" title="6. 为什么 Java 设计如此？"></a><strong>6. 为什么 Java 设计如此？</strong></h3><ul><li><strong>历史原因</strong>：<br>Java 的设计者（如 James Gosling）希望基本类型具有高性能和明确语义，而引用类型通过 <code>null</code> 提供灵活性。</li><li><strong>安全与效率的权衡</strong>：<br>允许基本类型为 <code>null</code> 会增加运行时检查的开销，且违背其设计初衷（存储固定值）。</li><li><strong>现代改进</strong>：<br>Java 8 引入 <code>Optional&lt;T&gt;</code> 类（如 <code>Optional&lt;Integer&gt;</code>）来更安全地处理可能为 <code>null</code> 的值，减少空指针异常。</li></ul><hr><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h3><table><thead><tr><th>特性</th><th>基本类型（如 <code>int</code>）</th><th>引用类型（如 <code>Integer</code>）</th></tr></thead><tbody><tr><td>是否可以为 <code>null</code></td><td>❌ 不可以</td><td>✅ 可以</td></tr><tr><td>存储方式</td><td>直接存储值</td><td>存储对象引用</td></tr><tr><td>默认值</td><td><code>0</code>（<code>int</code>）、<code>false</code>（<code>boolean</code>）</td><td><code>null</code></td></tr><tr><td>适用场景</td><td>高效计算、确定有值的场景</td><td>可能为 <code>null</code> 的场景</td></tr></tbody></table><p>如果需要处理可能为 <code>null</code> 的数值，<strong>请使用包装类或 <code>Optional&lt;T&gt;</code></strong>，并始终进行 <code>null</code> 检查以避免运行时错误。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么使用可重入锁</title>
    <link href="/2025/07/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    <url>/2025/07/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>在 Java 并发编程中，<strong>可重入锁（Reentrant Lock）</strong> 是一种核心的同步机制，其设计目的是为了解决多线程环境下资源竞争、死锁等问题，同时提升代码的灵活性和可维护性。以下是 Java 并发编程需要实现可重入锁的详细原因和原理：</p><hr><h3 id="1-为什么需要可重入锁？"><a href="#1-为什么需要可重入锁？" class="headerlink" title="1. 为什么需要可重入锁？"></a><strong>1. 为什么需要可重入锁？</strong></h3><h4 id="1-避免线程因重复请求锁导致的死锁"><a href="#1-避免线程因重复请求锁导致的死锁" class="headerlink" title="(1) 避免线程因重复请求锁导致的死锁"></a><strong>(1) 避免线程因重复请求锁导致的死锁</strong></h4><ul><li><strong>问题场景</strong>：<br>如果一个线程在持有锁的情况下再次请求同一把锁，且锁不支持可重入性，线程会因为无法获取锁而阻塞，最终导致<strong>死锁</strong>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 递归调用</span><br>            recursiveIncrement();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursiveIncrement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 如果锁不可重入，这里会死锁！</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>问题</strong>：<code>increment()</code> 方法内部调用 <code>recursiveIncrement()</code>，而两者都使用 <code>synchronized(lock)</code>，如果锁不可重入，线程会在 <code>recursiveIncrement()</code> 中尝试获取已经持有的锁时被阻塞，从而卡死。</li><li><strong>解决方案</strong>：可重入锁允许线程在持有锁的情况下多次获取同一把锁，避免死锁。</li></ul></li></ul><h4 id="2-支持嵌套同步方法调用"><a href="#2-支持嵌套同步方法调用" class="headerlink" title="(2) 支持嵌套同步方法调用"></a><strong>(2) 支持嵌套同步方法调用</strong></h4><ul><li><strong>典型场景</strong>：<br>在继承关系中，子类的同步方法调用父类的同步方法时，若锁不可重入，会导致线程无法进入父类方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.doSomething(); <span class="hljs-comment">// 如果锁不可重入，会死锁！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>问题</strong>：<code>Child</code> 的 <code>doSomething()</code> 方法调用了 <code>Parent</code> 的 <code>doSomething()</code>，两者都使用内置锁（<code>synchronized</code>）。若锁不可重入，线程会因无法再次获取锁而卡死。</li><li><strong>解决方案</strong>：Java 的 <code>synchronized</code> 锁和 <code>ReentrantLock</code> 都是可重入的，允许这种嵌套调用。</li></ul></li></ul><h4 id="3-提升代码的封装性和灵活性"><a href="#3-提升代码的封装性和灵活性" class="headerlink" title="(3) 提升代码的封装性和灵活性"></a><strong>(3) 提升代码的封装性和灵活性</strong></h4><ul><li><strong>优势</strong>：<br>可重入锁允许开发者将同步逻辑封装在多个方法中，而无需担心线程因重复请求锁导致的死锁问题。这简化了并发代码的设计和维护。</li></ul><hr><h3 id="2-可重入锁的实现原理"><a href="#2-可重入锁的实现原理" class="headerlink" title="2. 可重入锁的实现原理"></a><strong>2. 可重入锁的实现原理</strong></h3><p>Java 的可重入锁（如 <code>ReentrantLock</code> 和 <code>synchronized</code>）通过 <strong>计数器（State）和持有线程</strong> 实现可重入性：</p><ol><li><strong>计数器机制</strong>：<ul><li>每个锁关联一个计数器（<code>state</code>）和一个持有线程。</li><li><strong>首次获取锁</strong>：计数器从 <code>0</code> 增加到 <code>1</code>，线程成为锁的持有者。</li><li><strong>重入获取锁</strong>：计数器递增（如 <code>state++</code>）。</li><li><strong>释放锁</strong>：计数器递减（如 <code>state--</code>），当计数器为 <code>0</code> 时，锁被完全释放，其他线程可以竞争。</li></ul></li><li><strong>线程检查机制</strong>：<ul><li>当线程尝试获取锁时，会检查当前线程是否是锁的持有者。</li><li><strong>如果是</strong>：允许重入，并增加计数器。</li><li><strong>如果不是</strong>：阻塞线程，加入等待队列。</li></ul></li></ol><h4 id="1-ReentrantLock-的实现"><a href="#1-ReentrantLock-的实现" class="headerlink" title="(1) ReentrantLock 的实现"></a><strong>(1) <code>ReentrantLock</code> 的实现</strong></h4><ul><li><strong>基于 AQS（AbstractQueuedSynchronizer）</strong>：<ul><li><code>ReentrantLock</code> 使用 AQS 的 <code>state</code> 字段记录锁的重入次数。</li><li><strong>获取锁</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (当前线程是持有者) &#123;<br>    state += <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    CAS 尝试将 state 从 <span class="hljs-number">0</span> 改为 <span class="hljs-number">1</span>；<br>    如果成功，线程成为持有者；<br>    否则，阻塞线程并加入等待队列。<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>释放锁</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">state -= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (state == <span class="hljs-number">0</span>) &#123;<br>    唤醒等待队列中的线程；<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-synchronized-的实现"><a href="#2-synchronized-的实现" class="headerlink" title="(2) synchronized 的实现"></a><strong>(2) <code>synchronized</code> 的实现</strong></h4><ul><li><strong>JVM 内置的可重入锁</strong>：<ul><li>每个对象都有一个关联的监视器锁（Monitor Lock）。</li><li><strong>计数器</strong>：JVM 为每个锁维护一个计数器，记录当前线程持有锁的次数。</li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">outerMethod</span><span class="hljs-params">()</span> &#123;<br>    innerMethod(); <span class="hljs-comment">// 调用另一个 synchronized 方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">innerMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 可重入：同一线程可再次获取锁</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="3-可重入锁的优势"><a href="#3-可重入锁的优势" class="headerlink" title="3. 可重入锁的优势"></a><strong>3. 可重入锁的优势</strong></h3><h4 id="1-避免死锁"><a href="#1-避免死锁" class="headerlink" title="(1) 避免死锁"></a><strong>(1) 避免死锁</strong></h4><ul><li>允许线程在持有锁的情况下再次获取同一把锁，避免因重复请求锁导致的死锁。</li></ul><h4 id="2-支持递归调用"><a href="#2-支持递归调用" class="headerlink" title="(2) 支持递归调用"></a><strong>(2) 支持递归调用</strong></h4><ul><li>适用于递归函数、嵌套同步方法等场景。</li></ul><h4 id="3-提高代码灵活性"><a href="#3-提高代码灵活性" class="headerlink" title="(3) 提高代码灵活性"></a><strong>(3) 提高代码灵活性</strong></h4><ul><li>可重入锁（如 <code>ReentrantLock</code>）比 <code>synchronized</code> 更灵活，支持：<ul><li><strong>公平锁&#x2F;非公平锁</strong>：公平锁按等待顺序分配锁，避免线程饥饿。</li><li><strong>尝试获取锁</strong>：通过 <code>tryLock()</code> 方法尝试获取锁，避免无限阻塞。</li><li><strong>超时获取锁</strong>：通过 <code>tryLock(timeout, unit)</code> 设置超时时间。</li><li><strong>中断响应</strong>：通过 <code>lockInterruptibly()</code> 支持中断操作。</li></ul></li></ul><hr><h3 id="4-可重入锁的应用场景"><a href="#4-可重入锁的应用场景" class="headerlink" title="4. 可重入锁的应用场景"></a><strong>4. 可重入锁的应用场景</strong></h3><h4 id="1-递归函数"><a href="#1-递归函数" class="headerlink" title="(1) 递归函数"></a><strong>(1) 递归函数</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">(<span class="hljs-type">int</span> depth)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            count++;<br>            <span class="hljs-keyword">if</span> (depth &gt; <span class="hljs-number">0</span>) &#123;<br>                increment(depth - <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归调用</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>关键</strong>：线程在递归调用中多次获取同一把锁，不会被阻塞。</li></ul><h4 id="2-父类与子类的同步方法调用"><a href="#2-父类与子类的同步方法调用" class="headerlink" title="(2) 父类与子类的同步方法调用"></a><strong>(2) 父类与子类的同步方法调用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.doSomething(); <span class="hljs-comment">// 可重入：同一线程可再次获取锁</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-复杂的业务逻辑"><a href="#3-复杂的业务逻辑" class="headerlink" title="(3) 复杂的业务逻辑"></a><strong>(3) 复杂的业务逻辑</strong></h4><ul><li>在业务逻辑中，多个方法可能需要共享同一把锁，而无需担心死锁问题。</li></ul><hr><h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a><strong>5. 注意事项</strong></h3><h4 id="1-可重入锁不能完全避免死锁"><a href="#1-可重入锁不能完全避免死锁" class="headerlink" title="(1) 可重入锁不能完全避免死锁"></a><strong>(1) 可重入锁不能完全避免死锁</strong></h4><ul><li><strong>死锁的根本原因是循环依赖</strong>，例如多个线程互相持有对方需要的锁。可重入锁只能避免<strong>同一线程因重复请求锁导致的死锁</strong>，但无法解决<strong>多线程间的死锁</strong>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread1: lockA -&gt; lockB  <br>Thread2: lockB -&gt; lockA<br></code></pre></td></tr></table></figure><ul><li><strong>解决方案</strong>：遵循统一的锁获取顺序，或使用工具分析死锁。</li></ul></li></ul><h4 id="2-避免过度依赖可重入性"><a href="#2-避免过度依赖可重入性" class="headerlink" title="(2) 避免过度依赖可重入性"></a><strong>(2) 避免过度依赖可重入性</strong></h4><ul><li>过度依赖可重入性可能导致代码逻辑复杂，建议在必要时使用。</li></ul><h4 id="3-性能权衡"><a href="#3-性能权衡" class="headerlink" title="(3) 性能权衡"></a><strong>(3) 性能权衡</strong></h4><ul><li><strong>公平锁</strong>：性能较低，但避免线程饥饿。</li><li><strong>非公平锁</strong>：性能较高，但可能导致某些线程长时间等待。</li></ul><hr><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>可重入锁</strong></th></tr></thead><tbody><tr><td><strong>核心目的</strong></td><td>避免线程因重复请求锁导致的死锁，支持嵌套同步方法调用</td></tr><tr><td><strong>实现机制</strong></td><td>计数器（State） + 持有线程检查</td></tr><tr><td><strong>典型实现</strong></td><td><code>ReentrantLock</code>（显式锁）、<code>synchronized</code>（内置锁）</td></tr><tr><td><strong>优势</strong></td><td>避免死锁、支持递归&#x2F;嵌套调用、灵活控制锁行为</td></tr><tr><td><strong>适用场景</strong></td><td>递归函数、父子类同步方法、复杂的业务逻辑</td></tr><tr><td><strong>注意事项</strong></td><td>不能完全避免死锁、需合理设计锁的获取顺序、性能权衡</td></tr></tbody></table><p>通过可重入锁，Java 并发编程能够在复杂场景下保持代码的简洁性和安全性，是多线程开发中不可或缺的工具。</p>]]></content>
    
    
    
    <tags>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可重入锁的引入：不可重入锁中的死锁问题</title>
    <link href="/2025/07/05/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%BC%95%E5%85%A5%EF%BC%9A%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <url>/2025/07/05/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%BC%95%E5%85%A5%EF%BC%9A%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>重入锁（ReentrantLock）</strong>，顾名思义，就是支持重复进入的锁，它表示该锁能够支持同一个线程对一个资源的重复加锁。也就是说，如果某个线程试图获得一个已经由它自己持有的可重入锁，那个这个请求就会成功。</p><p>相反，<strong>不可重入锁</strong>就是指该锁不支持同一个线程对一个资源的重复加锁，由于 Java 中并没有现成的可重入锁可供使用，下面简单实现一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonReentrantLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isLocked</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (isLocked) &#123;<br>            wait();<br>        &#125;<br>        isLocked = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        isLocked = <span class="hljs-literal">false</span>;<br>        notify();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，isLocked 变量用于表示锁是否被占用的标志，lock 和 unlock 方法都是同步方法，确保在多线程环境下只有一个线程可以获得&#x2F;释放锁，当锁已经被占用时，线程将通过调用在 while 循环中调用 wait 方法进行等待，直到锁被释放。</p><p><strong>之后，我们再来看一个「不可重入锁中的死锁问题」：</strong></p><p>下面是一个 Parent 类，它包含了一个不可重入锁 nonReentrantLock 和一个 method 方法 。在 method 方法中使用不可重入锁加锁，并且打印一条语句，之后在 finally 块中释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">NonReentrantLock</span> <span class="hljs-variable">nonReentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        nonReentrantLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Parent method&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            nonReentrantLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在有一个 Child 类，它继承自 Parent ，并覆盖了 method 方法，并且也在其中使用了不可重入锁进行加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        nonReentrantLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Child method&quot;</span>);<br>            <span class="hljs-built_in">super</span>.method();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            nonReentrantLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面编写测试类进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Child</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>        child.method();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p>![屏幕截图 2025-07-05 161102](..\img\屏幕截图 2025-07-05 161102.png)</p><p>可以看到，程序只显示了 Child 类的打印语句，并且一直在运行，说明发生了死锁。</p><p><strong>分析：</strong></p><p>由于 Child 和 Parent 类中的 method 方法执行时都需要先加锁，即每个 method 方法在执行前都会获取 Parent 中的 nonReentrantLock 锁。</p><p>当程序运行到 Child 类的 <code>super.method()</code> 时，因为 nonReentrantLock 锁是不可重入锁，且线程在调用 <code>child.method()</code> 时已经持有了这个锁，所以线程会在此时永远停顿下去，等待一个永远也无法获得的锁。进而发生死锁。</p><p><strong>解决：</strong></p><p>想要解决这个问题非常简单：使用可重入锁。例如使用 ReentrantLock ，或者仅使用 synchronized 关键字修饰两个类的 method 方法即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode：删除链表的倒数第N个节点</title>
    <link href="/2025/07/03/leetcode%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2025/07/03/leetcode%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="s双指针"><a href="#s双指针" class="headerlink" title="s双指针"></a>s双指针</h2><p>想象有一把长度固定的尺子，左端点在链表头部，右端点在正数第 n 个节点。向右移动尺子，当尺子右端点到达链表末尾时，左端点就在倒数第 n 个节点。</p><p>由于需要删除节点，我们需要找倒数第 n 个节点的前一个节点（倒数第 n+1 个节点），这样才能做删除操作。</p><p>修改：左端点在链表头部，右端点在正数第 n+1 个节点。向右移动尺子，当尺子右端点到达链表末尾时，左端点就在倒数第 n+1 个节点。</p><p>细节：如果 n 等于链表长度呢？没有正数第 n+1 个节点。难道要特判这种情况？</p><p>不需要。我们可以在头节点的前面插入一个哨兵节点（dummy node），把它当作链表的头节点，这样就有正数第 n+1 个节点了。换句话说，如果遇到需要删除头节点的题目，添加哨兵节点可以简化代码逻辑，请记住这个技巧。</p><p>具体请看视频讲解：【基础算法精讲 08】，制作不易，欢迎点赞关注~</p><p>答疑<br>问：前后指针的做法为什么算作「一次遍历」？链表节点不是会被遍历两次吗？</p><p>答：链表节点是会被遍历两次。其实我觉得这题本质上想考察的是，在不知道链表长度的前提下，设计一个算法，在「到达链表末尾的瞬间」就能知道倒数第 n 个节点。</p><p>问：一般在做链表题时，什么时候要写 while node，什么时候要写 while node.next？</p><p>答：如果要遍历到最后一个节点，需要写 while node；如果要遍历到倒数第二个节点，需要写 while node.next。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 由于可能会删除链表头部，用哨兵节点简化代码</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>) &#123;<br>            right = right.next; <span class="hljs-comment">// 右指针先向右走 n 步</span><br>        &#125;<br>        <span class="hljs-keyword">while</span> (right.next != <span class="hljs-literal">null</span>) &#123;<br>            left = left.next;<br>            right = right.next; <span class="hljs-comment">// 左右指针一起走</span><br>        &#125;<br>        left.next = left.next.next; <span class="hljs-comment">// 左指针的下一个节点就是倒数第 n 个节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要解决“从链表末尾删除第 n 个节点”的问题，并且要求使用 <strong>反转两次链表</strong> 的方法，我们可以按照以下步骤进行：</p><hr><h3 id="✅-解题思路"><a href="#✅-解题思路" class="headerlink" title="✅ 解题思路"></a>✅ 解题思路</h3><ol><li><strong>第一次反转链表</strong><br> 将原链表反转。这样，原链表的<strong>倒数第 n 个节点</strong>就变成了<strong>正数第 n 个节点</strong>。</li><li><strong>删除反转后的第 n 个节点</strong><br> 利用哑节点（dummy node）处理头节点被删除的情况，确保删除操作不会出错。</li><li><strong>第二次反转链表</strong><br> 再次反转链表，将删除后的链表还原回原来的顺序。</li></ol><hr><h3 id="🧠-关键点说明"><a href="#🧠-关键点说明" class="headerlink" title="🧠 关键点说明"></a>🧠 关键点说明</h3><ul><li><strong>为什么反转两次？</strong><br> 反转链表后，原本难以定位的倒数第 n 个节点就变成了易于访问的正数第 n 个节点。删除后，再反转回来即可得到最终结果。</li><li><strong>如何删除第 n 个节点？</strong><br> 使用哑节点 <code>dummy</code> 来统一处理头节点被删除的情况，然后通过移动指针找到第 n 个节点并删除。</li><li><strong>反转链表的标准写法</strong><br> 反转链表时必须确保每个节点都被处理，因此循环条件应为 <code>cur != null</code>，而不是 <code>cur.next != null</code>。</li></ul><hr><h3 id="🧩-示例代码（Java）"><a href="#🧩-示例代码（Java）" class="headerlink" title="🧩 示例代码（Java）"></a>🧩 示例代码（Java）</h3><p>java</p><p>深色版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">// 第一步：反转链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">reversedHead</span> <span class="hljs-operator">=</span> reverseList(head);<br>        <br>        <span class="hljs-comment">// 第二步：删除反转后的链表中第n个节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy.next = reversedHead;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> reversedHead;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span> &amp;&amp; current != <span class="hljs-literal">null</span>; i++) &#123;<br>            prev = prev.next;<br>            current = current.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 删除第n个节点</span><br>        prev.next = current.next;<br><br>        <span class="hljs-comment">// 第三步：再次反转链表，恢复原顺序</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> reverseList(dummy.next);<br><br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="🧪-示例说明"><a href="#🧪-示例说明" class="headerlink" title="🧪 示例说明"></a>🧪 示例说明</h3><p>假设输入链表为 <code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</code>，<code>n = 2</code>：</p><ol><li><strong>第一次反转</strong>：链表变成 <code>5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</code>。</li><li><strong>删除第2个节点</strong>：删除 <code>4</code>，得到 <code>5 -&gt; 3 -&gt; 2 -&gt; 1</code>。</li><li><strong>第二次反转</strong>：链表还原为 <code>1 -&gt; 2 -&gt; 3 -&gt; 5</code>。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode：k个一组链表倒转</title>
    <link href="/2025/06/28/leetcode%EF%BC%9Ak%E4%B8%AA%E4%B8%80%E7%BB%84%E9%93%BE%E8%A1%A8%E5%80%92%E8%BD%AC/"/>
    <url>/2025/06/28/leetcode%EF%BC%9Ak%E4%B8%AA%E4%B8%80%E7%BB%84%E9%93%BE%E8%A1%A8%E5%80%92%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[2,1,4,3,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[3,2,1,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><p>出自0x3f:<a href="https://www.bilibili.com/video/BV1sd4y1x7KN/?vd_source=e9af65243db3099fe9a2f826325febdd">反转链表【基础算法精讲 06】_哔哩哔哩_bilibili</a></p><p><img src="/..%5Cimg%5Cimage-20250628093741061.png" alt="image-20250628093741061"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 统计节点个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head; cur != <span class="hljs-literal">null</span>; cur = cur.next) &#123;<br>            n++;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p0</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br><br>        <span class="hljs-comment">// k 个一组处理</span><br>        <span class="hljs-keyword">for</span> (; n &gt;= k; n -= k) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123; <span class="hljs-comment">// 同 92 题</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> cur.next;<br>                cur.next = pre; <span class="hljs-comment">// 每次循环只修改一个 next，方便大家理解</span><br>                pre = cur;<br>                cur = nxt;<br>            &#125;<br><br>            <span class="hljs-comment">// 见视频</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span> p0.next;<br>            p0.next.next = cur;<br>            p0.next = pre;<br>            p0 = nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br><br>作者：灵茶山艾府<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/reverse-nodes-in-k-group/solutions/1992228/you-xie-cuo-liao-yi-ge-shi-pin-jiang-tou-plfs/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode：链表倒转</title>
    <link href="/2025/06/28/leetcode%EF%BC%9A%E9%93%BE%E8%A1%A8%E5%80%92%E8%BD%AC/"/>
    <url>/2025/06/28/leetcode%EF%BC%9A%E9%93%BE%E8%A1%A8%E5%80%92%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="92-反转链表2"><a href="#92-反转链表2" class="headerlink" title="92.反转链表2"></a>92.反转链表2</h1><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3,4,5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">4</span><br>输出：<span class="hljs-selector-attr">[1,4,3,2,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">1</span>, right = <span class="hljs-number">1</span><br>输出：<span class="hljs-selector-attr">[5]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目为 <code>n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-500 &lt;= Node.val &lt;= 500</code></li><li><code>1 &lt;= left &lt;= right &lt;= n</code></li></ul><p>0x3f：</p><p>关键性质：</p><p>![屏幕截图 2025-06-28 091618](..\img\屏幕截图 2025-06-28 091618.png)</p><p>将内部的倒转之后，还需要处理![屏幕截图 2025-06-28 091811](..\img\屏幕截图 2025-06-28 091811.png)两端的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">p0.next.next = curr;<br>p0.next = pre;<br></code></pre></td></tr></table></figure><p>如果left &#x3D;1；如何解决？</p><p>注意：题目给出的是无头结点的链表，因此我们可以认为给他多设置一个链表头节点：</p><p><img src="/..%5Cimg%5Cimage-20250628092446549.png" alt="image-20250628092446549"></p><p>p0节点不参与，先处理下方的p0的next的next，再处理p0的next</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        ListNode p0=dummy; <span class="hljs-comment">//head节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;left-<span class="hljs-number">1</span>;i++)&#123;<br>            p0 =p0.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span><span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span>p0.next;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;right-left+<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nxt</span> <span class="hljs-operator">=</span>curr.next; <span class="hljs-comment">//内部反转</span><br>            curr.next = pre;<br>            pre = curr;<br>            curr = nxt;<br>        &#125;<br>        p0.next.next = curr; <span class="hljs-comment">//先处理内部的头节点，使其指向外部2号的头</span><br>        <span class="hljs-comment">//先处理next的next，否则next就失踪了</span><br>        p0.next = pre; <span class="hljs-comment">//处理p0（外部1号）的头</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode：旋转图像</title>
    <link href="/2025/06/27/leetcode%EF%BC%9A%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2025/06/27/leetcode%EF%BC%9A%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>螺旋矩阵</title>
    <link href="/2025/06/25/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2025/06/25/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p>哎呦我靠，怎么螺旋矩阵怎么难，感觉接雨水都没这么难，<br>明天开启高三模式了，好累啊<br>过几天更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode238</title>
    <link href="/2025/06/24/Leetcode238/"/>
    <url>/2025/06/24/Leetcode238/</url>
    
    <content type="html"><![CDATA[<p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请 **不要使用除法，**且在 <code>O(n)</code> 时间复杂度内完成此题。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: nums = [<span class="hljs-number">1,2,3,4</span>]<br>输出: [<span class="hljs-number">24,12,8,6</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[-1,1,0,-3,3]</span><br>输出: <span class="hljs-comment">[0,0,9,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li>输入 <strong>保证</strong> 数组 <code>answer[i]</code> 在 <strong>32 位</strong> 整数范围内</li></ul><p>**进阶：**你可以在 <code>O(1)</code> 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 <strong>不被视为</strong> 额外空间。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> suf[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [len];<br>        suf[len-<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            suf[i]=suf[i+<span class="hljs-number">1</span>]*nums[i+<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            suf[i] *= pre;<br>            pre *= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> suf;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>answer[i] 等于 nums 中除了 nums[i] 之外其余各元素的乘积。换句话说，如果知道了 i 左边所有数的乘积，以及 i 右边所有数的乘积，就可以算出 answer[i]。</p><p>于是：</p><p>定义 pre[i] 表示从 nums[0] 到 nums[i−1] 的乘积。<br>定义 suf[i] 表示从 nums[i+1] 到 nums[n−1] 的乘积。</p><p>我们可以先计算出从 nums[0] 到 nums[i−2] 的乘积 pre[i−1]，再乘上 nums[i−1]，就得到了 pre[i]，即</p><p>pre[i]&#x3D;pre[i−1]⋅nums[i−1]<br>同理有</p><p>suf[i]&#x3D;suf[i+1]⋅nums[i+1]</p><p>以上为基础做法</p><p>给出对的空间复杂度为O1，如何实现？</p><p>答案是将suf顺序直接乘进去，前缀和不断乘即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PDF-test</title>
    <link href="/2025/06/23/PDF-test/"/>
    <url>/2025/06/23/PDF-test/</url>
    
    <content type="html"><![CDATA[<p>部署pdf，有点难度</p><div class="pdf-container">  <iframe src="https://noflowcloud.netlify.app//pdfjs/web/viewer.html?file=/PDF/7小时速通SpringCloud.pdf" width="100%" height="500px"></iframe> </div>]]></content>
    
    
    
    <tags>
      
      <tag>PDF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode189：轮转数组</title>
    <link href="/2025/06/23/Leetcode189%EF%BC%9A%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <url>/2025/06/23/Leetcode189%EF%BC%9A%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>方法三：数组翻转<br>该方法基于如下的事实：当我们将数组的元素向右移动 k 次后，尾部 kmodn 个元素会移动至数组头部，其余元素向后移动 kmodn 个位置。</p><p>该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 kmodn 个元素就被移至数组头部，然后我们再翻转 [0,kmodn−1] 区间的元素和 [kmodn,n−1] 区间的元素即能得到最后的答案。</p><p>我们以 n&#x3D;7，k&#x3D;3 为例进行如下展示：</p><pre><code class="hljs">class Solution &#123;    public void rotate(int[] nums, int k) &#123;    k %= nums.length;    reverse(nums, 0, nums.length - 1);    reverse(nums, 0, k - 1);    reverse(nums, k, nums.length - 1);    &#125;public void reverse(int[] nums, int start, int end) &#123;    while (start &lt; end) &#123;        int temp = nums[start];        nums[start] = nums[end];        nums[end] = temp;        start += 1;        end -= 1;    &#125;&#125;&#125;</code></pre><p>复杂度分析</p><p>时间复杂度：O(n)，其中 n 为数组的长度。每个元素被翻转两次，一共 n 个元素，因此总时间复杂度为 O(2n)&#x3D;O(n)。</p><p>空间复杂度：O(1)。</p><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/rotate-array/solutions/551039/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/">https://leetcode.cn/problems/rotate-array/solutions/551039/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/</a><br>来源：力扣（LeetCode）</p><p>引用了美服翻转做法下面的评论(第一条) 希望能帮到大家<br>原地址</p><p>nums &#x3D; “—–&gt;–&gt;”; k &#x3D;3<br>result &#x3D; “–&gt;—–&gt;”;</p><p>reverse “—–&gt;–&gt;” we can get “&lt;–&lt;—–”<br>reverse “&lt;–” we can get “–&gt;&lt;—–”<br>reverse “&lt;—–” we can get “–&gt;—–&gt;”<br>this visualization help me figure it out :)</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chmod读文件之755</title>
    <link href="/2025/06/22/chmod%E8%AF%BB%E6%96%87%E4%BB%B6%E4%B9%8B755/"/>
    <url>/2025/06/22/chmod%E8%AF%BB%E6%96%87%E4%BB%B6%E4%B9%8B755/</url>
    
    <content type="html"><![CDATA[<p>755读文件最经典，r的权限只能看一眼有什么文件，还需要执行权限才能进去看文件内容或者里面的文件夹内容</p><p>注意，要将（比如MySQL这个大类）文件夹设为755，其余人员才能进去，然后将文件夹里面的设置为754，就能实现不能运行了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux的三个问题</title>
    <link href="/2025/06/22/Linux%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <url>/2025/06/22/Linux%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h1><h1 id="1三个问题"><a href="#1三个问题" class="headerlink" title="1三个问题"></a>1三个问题</h1><p>1.Linux怎么样部署测试环境，部署完了之后怎么样知道是否启动成功了这个项目</p><p>2.部署出现问题，用什么命令去查找相关的logo日志</p><p>3.当某个可执行文件的权限不足时候，怎么做</p><p>基本回答如下</p><p>测试环境用容器来部署。这样可以保证所有开发人员环境统一。可以选择docker或者podman，选择对应compose编写部署文件。使用dockerfile编译与打包程序，可以减少自动化测试时环境造成的编译打包问题。</p><p>出现错误可以有多种选择。一，当应用有使用统一的日志管理中间件时可以直接后台查看日志；二，当使用容器部署测试时，可使用exec命令参数进入shell，查看日志目录与日志文件；三，当dockerfile导出日志数据卷时，可直接查看对应的导出目录；四，在shell中可以使用vim，cat，等命令查看日志文件。</p><p>当可执行文件权限不足时，可使用“ls -la 文件名”查看文件是否有执行权限以及文件属于的用户与用户组。若文件属于当前环境使用的用户，则使用chmod命令添加执行权限；若文件不属于当前用户，且当前用户不存在与文件所有者组中时，应人为判断是否可以修改文件所有者或组，亦或是将当前环境使用的用户加入所有者组中，使用chown进行修改。</p><h1 id="2-进阶"><a href="#2-进阶" class="headerlink" title="2 进阶"></a>2 进阶</h1><p>1、如果项目不用docker容器等部署方式你又怎么查？直接ps -ef grep java 或者ps -ef | grep jdk<br>2、vim本质是编辑本文，需要一下加载文本所有数据的，你这样只会卡死， 监听用tail 粗略看用more 详细看用less ，more和less都可以跳行和搜索，cat一下全部加载也不好<br>3、文件权限不足就改文件权限，你真不怕改出事？ 正确方法就是ls -lrt 看文件的权限，看他属于那个用户，再su切换有权限的用户去操作才是正确的</p><h1 id="3综合可得最佳答案为"><a href="#3综合可得最佳答案为" class="headerlink" title="3综合可得最佳答案为"></a>3综合可得最佳答案为</h1><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>部署测试环境</strong>：优先使用容器化（Docker&#x2F;Podman），通过进程、日志、网络检测确认启动。</li><li><strong>查找日志</strong>：容器化使用 <code>docker logs</code>，非容器化使用 <code>tail</code>&#x2F;<code>grep</code>&#x2F;<code>journalctl</code>。</li><li><strong>权限不足</strong>：优先 <code>chmod +x</code>，必要时修改所有者或用户组，避免过度开放权限。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-21</title>
    <link href="/2025/06/21/6-21/"/>
    <url>/2025/06/21/6-21/</url>
    
    <content type="html"><![CDATA[<h2 id="1终于学完ssm了"><a href="#1终于学完ssm了" class="headerlink" title="1终于学完ssm了"></a>1终于学完ssm了</h2><p>真感觉SSM跟SPringboot没有什么重点啊，除了可能要看源码之外，其他直接跟着项目搞就行了</p><h2 id="2终于弄完计组的一堆作业了"><a href="#2终于弄完计组的一堆作业了" class="headerlink" title="2终于弄完计组的一堆作业了"></a>2终于弄完计组的一堆作业了</h2><p>疑似浪费了一天</p><h2 id="3打算把leetcode重新捡起来"><a href="#3打算把leetcode重新捡起来" class="headerlink" title="3打算把leetcode重新捡起来"></a>3打算把leetcode重新捡起来</h2><p>应该关注个人然后偷看ta的进度</p><h1 id="TODOLIST："><a href="#TODOLIST：" class="headerlink" title="TODOLIST："></a>TODOLIST：</h1><p>1.博客的run netlify命令仍然有问题</p><p>2.天选又开始黑屏休眠了，得关</p><p>3.复习（复健）leetcode</p><p>4.LSTM的PPT之类的</p><p>5.争取考试之前学完Linux跟git</p><p>6.眼睛好不舒服啊啊啊啊啊啊</p><p>休息了，睡了晚安</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode03：无重复字符的最长子串</title>
    <link href="/2025/06/21/Leetcode03%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2025/06/21/Leetcode03%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><p>提示</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// 记录字符上一次出现的位置</span><br>        <span class="hljs-type">int</span>[] last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++) &#123;<br>            last[i] = -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 窗口开始位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            start = Math.max(start, last[index] + <span class="hljs-number">1</span>);<br>            res   = Math.max(res, i - start + <span class="hljs-number">1</span>);<br>            last[index] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试着解释了一下，希望对大家有所帮助~</p><p>以这个字符串为例：abcabcbb，</p><p>当i等于3时，也就是指向了第二个a, 此时我就需要查之前有没有出现过a, 如果出现了是在哪一个位置出现的。</p><p>然后通过last[index] 查到等于1, 也就是说，如果start 依然等于0的话，那么当前窗口就有两个a了，也就是字符串重复了，所以我们需要移动当前窗口的start指针，移动到什么地方呢？</p><p>移动到什么地方，窗口内就没有重复元素了呢？<br>对了，就是a上一次出现的位置的下一个位置，就是1 + 1 &#x3D; 2。</p><p>当start &#x3D;&#x3D; 2, 当前窗口就没有了重复元素，那么以当前字符为结尾的最长无重复子串就是bca,然后再和之前的res取最大值。</p><p>然后i指向后面的位置，按照同样思路计算。</p><p>start用于标记重复的</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.20记录</title>
    <link href="/2025/06/20/6-20/"/>
    <url>/2025/06/20/6-20/</url>
    
    <content type="html"><![CDATA[<p>必胜客真好吃吧，感觉是最好吃的西餐了，虽然也没吃过更贵的就是了，生活中的小幸福啊</p><p><img src="F:\MyBlog_hexo\source\img\必胜客.jpg" alt="必胜客"></p>]]></content>
    
    
    
    <tags>
      
      <tag>日常生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo部署之netlify</title>
    <link href="/2025/06/20/netlify%E6%9B%B4%E6%96%B0/"/>
    <url>/2025/06/20/netlify%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="部署后Netlify上未显示最新更改"><a href="#部署后Netlify上未显示最新更改" class="headerlink" title="部署后Netlify上未显示最新更改"></a>部署后Netlify上未显示最新更改</h1><p>关联问题</p><p>[ 为什么Netlify上没有显示最新的更改？](<a href="https://copilot.tencent.com/chat?s=">https://copilot.tencent.com/chat?s=</a> 为什么Netlify上没有显示最新的更改？&amp;fromSource&#x3D;gwzcw.9271037.9271037.9271037&amp;utm_medium&#x3D;cpc&amp;utm_id&#x3D;gwzcw.9271037.9271037.9271037)</p><p>[ Netlify部署后内容未更新怎么办？](<a href="https://copilot.tencent.com/chat?s=">https://copilot.tencent.com/chat?s=</a> Netlify部署后内容未更新怎么办？&amp;fromSource&#x3D;gwzcw.9271037.9271037.9271037&amp;utm_medium&#x3D;cpc&amp;utm_id&#x3D;gwzcw.9271037.9271037.9271037)</p><p>[ 如何确保Netlify显示最新的部署内容？](<a href="https://copilot.tencent.com/chat?s=">https://copilot.tencent.com/chat?s=</a> 如何确保Netlify显示最新的部署内容？&amp;fromSource&#x3D;gwzcw.9271037.9271037.9271037&amp;utm_medium&#x3D;cpc&amp;utm_id&#x3D;gwzcw.9271037.9271037.9271037)</p><p>是因为缓存或者静态文件未正确刷新导致的。下面是解决该问题的一些步骤和技巧：</p><ol><li>清除浏览器缓存：浏览器会缓存静态文件，以提高网页加载速度。但是有时候这会导致最新更改无法及时显示。你可以尝试按下Ctrl + F5（Windows）或者Command + Shift + R（Mac）来强制刷新页面。</li><li>清除Netlify缓存：Netlify也会缓存文件以提高访问速度。你可以进入Netlify的项目设置页面，找到“Build &amp; Deploy”选项，然后点击“Clear cache and deploy site”来清除缓存并重新部署站点。</li><li>检查版本控制：确保你将最新的更改提交到了版本控制系统（如Git）并推送到了Netlify。如果你只是本地修改了文件而没有将其推送到版本控制系统，Netlify将无法检测到更改并进行部署。</li><li>查看部署日志：在Netlify的项目设置页面中，你可以找到“Deploys”选项，并查看最近的部署日志。检查日志中是否有错误或警告信息，以帮助你找出问题所在。</li><li>检查构建设置：如果你使用了构建工具（如Webpack或Gulp），请确保你的构建设置正确。检查构建配置文件，例如webpack.config.js或gulpfile.js，以确保正确设置了文件路径和构建规则。</li><li>强制重新部署：在Netlify的项目设置页面中，你可以手动触发重新部署。这将强制Netlify重新构建和部署站点，以确保最新更改被正确显示。</li></ol><p>总结起来，当部署后Netlify上未显示最新更改时，可以考虑清除浏览器缓存、清除Netlify缓存、检查版本控制、查看部署日志、检查构建设置以及强制重新部署等操作来解决问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/06/20/hello-world/"/>
    <url>/2025/06/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>helloworld</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
